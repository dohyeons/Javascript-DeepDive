# Javascript-DeepDive
다이소 스터디 딥다이브 정리 저장소📖 
# 01장 프로그래밍
## 1.1 프로그래밍이란?
> **💡프로그래밍**: 컴퓨터에게 실행을 요구하는 커뮤니케이션. 즉, ___문제를 명확히 이해하고 그 해결방안을 정의해야함___

사용자에게는

* **문제를 명확히 이해**하고
* **복잡함을 단순하게 분해**하고
* **자료를 정리하고 구분**하며
* **순서에 맞게 행위를 배열**

하는 능력이 요구됨

그러나 가장 중요한 능력은, 컴퓨터의 관점에서 문제를 생각하는 컴퓨팅 사고(Computational Thinking)이다.

> **💡컴퓨팅 사고(Computational Thinking)**: 해결 과제를 작은 단위로 분해하고, 패턴화해서 추출하며, 프로그래밍에서 사용될 모든 개념을 평가가능하도록 정의함

## 1.2 프로그래밍 언어
문제 해결 방법을 수행하는 주체는 컴퓨터 → 기계어로 명령을 전달해야함

따라서, 사람이 이해할 수 있는 문법으로 구성된 프로그래밍 언어로 프로그램을 작성하고, 컴파일러 혹은 인터프리터를 통해 기계어로 번환해줌

> 프로그래밍 언어는 **구문 + 의미**의 조합이다.

## 1.3 구문과 의미
```
const number = '숫자';
console.log(number * number); // NaN
```
프로그래밍 언어에서도 문법과 의미 둘 다 중요하다. 위의 코드는 문법적으로는 문제가 없지만, 의미적으로는 올바르지 않다. number라는 변수에는 숫자가 할당되는 것이 의미적으로 옳다.

문제 해결 방안 역시 프로그래밍 문법을 통해 표현한다. 따라서 프로그래밍 언어 문법도 어긋나지 않고, 요구하는 바를 정확히 수행해야지만이 의미가 있다.

# 02장 자바스크립트의 특징

> 자바스크립트는 개발자가 별도의 컴파일을 하지 않는 **인터프리터 언어** 이다.

| 컴파일러 언어 | 인터프리터 언어 |
| -- | -- |
| 코드 실행 전 컴파일 타임에 코드 전체를 한번에 머신 코드로 변환 후 실행| 런타임에 문 단위로 한줄씩 바이트 코드로 변환한 후 실행 |
| 실행파일 생성 |  실행파일 X |
| 컴파일과 실행 단계가 명시적으로 분리. 컴파일 - 실행 | 인터프리트와 실행단계가 분리 X. 한 줄씩 바이트코드로 변환 후 바로 실행 |
| 컴파일은 단 한번 실행됨 | 코드가 실행될 때마다 인터프리트 과정이 반복 실행됨 |
| 단계가 분리되어 실행속도가 빠름  | 단계가 분리되어있지 않고 반복되어 실행속도가 비교적 느림 |

# 04장 변수
## 변수란 무엇이고 왜 필요한가
* 컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 저장한다.
> 메모리: 메모리 셀(1 바이트 = 8비트)의 집합체. 각 셀은 고유의 주소를 가지며, 주소는 0부터 시작해 메모리 크기만큼 정수로 표현됨.

컴퓨터는 모든 메모리를 2진수로 처리 → 데이터 종류에 상관 없이 2진수로 저장됨.

예를 들어, 
```
10+20
```

에서 10과 20은 메모리 임의의 위치에 저장되고, CPU는 이 값을 읽어와서 연산한다. 결과인 30역시 메모리의 어딘가에 저장된다.

그러나 결과인 30은 재사용 할 수가 없는 문제가 발생한다. 결과를 재사용하고 싶다면 메모리 공간에 직접 접근해야 하지만, 자바스크립트에서는 개발자의 직접적인 메모리 제어를 허용하지 않는다.

이를 위해서 프로그래밍 언어는 값을 메모리에 저장하고, 다시 불러들여 재사용하기위해 

___변수___

라는 메커니즘을 제공한다.

변수의 정의란

> 💡**변수**: 하나의 값을 저장하기 위해 확보한 **메모리 공간 자체 또는 그 공간을 식별하기 위해 붙인 이름**을 말한다.

다시말해, 변수 = 값의 위치를 가리키는 상징적인 이름이다.

10 + 20의 값을 저장하고 재사용하고 싶다면 다음과 같이 작성할 수 있다.

```
const sum = 10 + 20;
```

10 + 20은 연산으로 30을 만들고, 30은 메모리 공간의 임의의 주소에 저장되는데, 이 주소를 'sum' 이라는 이름으로 식별하는 것이다.

## 4.2 변수의 선언
변수의 사용 전에는 반드시 선언이 선행되어야 한다.

* 변수의 선언 = 변수의 생성이다.

var, let, const 키워드가 변수 선언에 사용된다. (단, var키워드가 가진 후술할 문제점들 때문에 ES6에서 let, const가 도입되었다.)

변수의 선언은 두 단계로 나뉜다.

1. 선언 단계: 변수 이름을 등록하고 자바스크립트에 존재를 알림
2. 초기화 단계: 메모리공간을 확보하고 암묵적으로 undefined를 할당해 초기화.

* 메모리 공간에는 이전에 사용한 값이 남아있을 수 있어서, 초기화를 하지 않으면 해당 쓰레기 값을 불러올 위험이 있다.

## 4.3 호이스팅
```
console.log(test);

var test;
```
자바스크립트는 위에서 설명했다시피 인터프리터 언어이고, 때문에 한줄씩 실행되어 Reference Error가 발생할 것처럼 보인다.
그러나 출력된 값은 undefined이다.

> 💡***변수 선언이 런타임이 아니라 그 이전 단계에서 먼저 발생했기 때문이다.***

**자바스크립트는 런타임 전 소스코드 평가과정에서 모든 선언문을 찾아 먼저 실행한다. 따라서 변수 선언의 위치와 상관없이 변수를 참조할 수 있다.**

즉,

1. 런타임 전 평가과정에서 ``var test`` 가 먼저 실행되어 자바스크립트에 등록된다(= 선언된다).
2. 선언과 동시에, ``test``는 undefined로 초기화 된다.

의 과정을 거치는 것이다. 

이와 같이, 변수의 선언이 마치 스코프의 최상단에서 이루어진 것처럼 작동하는데, 이를 ***호이스팅*** 이라고 한다. 

# 05장 표현식과 문
## 5.1 값
 > **값** =  식이 평가되어 생성된 결과

 평가 = 식을 해석해서 값을 생성하거나 참조하는 것

 ```
 10 + 20
 ```
 위 식은 평가되고 값 30을 생성한다.

 모든 값은 데이터 타입을 가지고, 메모리에 2진수로 저장된다. 값은 데이터 타입에 따라 다르게 해석될 수 있다.

 ## 5.2 리터럴
 리터럴은 값을 생성하는 방법 중 하나이다.

 > **리터럴** = 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법

 ```
1 // 숫자 리터럴
'hello' // 문자열 리터럴
function () {} // 함수 리터럴
 ```

## 5.3 표현식
> **표현식** = 값으로 평가될 수 있는 문

값으로 평가될 수 있는 문은 모두 표현식임에 주목하자. 

```
100;
```
리터럴은 값을 생성하므로 그 자체가 표현식이다. 

```
let score = 100 + 100;
```
100 + 100 역시 평가되어 값을 생성하므로 표현식이다.

```
score;
```
score역시 참조되고, 200으로 평가되므로 표현식이다.

이를 다시 생각해보면, 표현식과 표현식이 평가된 값은 동등한 관계를 가진다.

> 따라서 문법적으로 값이 위치할 수 있는 자리에는 표현식이 위치할 수 있다.

또한, 표현식은 다른 표현식의 일부로 값을 생성할 수 있다.
```
let score2 = score + 100;
```

## 5.4 문
> **문** = 프로그램을 구성하는 기본 단위이자 **최소 실행 단위**

> **토큰** = 문법적 의미가 있고, 더 이상 나눌 수 없는 코드의 기본적인 요소

```
let score = 100 + 100
//let, score, =, 100, +, 100. ; 모두 토큰이다.
```
자바스크립트에서 볼 수 있는 오류 Unexpected Token 오류. 예상치 못한 언어 구조를 맞이했을 때 발생하는 오류이다.

문은 선언문, 할당문, 조건문, 반복문 등으로 구분할 수 있다.

## 5.5 세미콜론 & 세미콜론의 자동 삽입 기능
세미콜론은 문의 종료를 의미하며, 자바스크립트는 세미콜론의 위치를 파악하고 순차적으로 문을 실행한다. 즉, 문의 종료 = 세미콜론의 등장이다.

그러나 코드블록은 자체 종결성을 가지기 때문에 세미콜론을 붙이지 않는다.

> 그러나, 문의 끝에 붙이는 세미콜론은 옵션이다. 자바스크립트 엔진이 세미콜론 자동 삽입 기능이 있기 때문이다.

다만 세미콜론 사용이 권장되는 분위기이다. 개발자의 의도와, 기능의 의도가 어긋날 수 있기 때문이다.

## 5.6 표현식인 문 & 표현식이 아닌 문

* 표현식인 문 = 값으로 평가될 수 있는 문
* 표현식이 아닌 문 = 값으로 평가될 수 없는 문

둘을 구분하는 가장 간단한 방법은 변수에 할당해보는 것이다.

```
let x ; 
x = 100;
// 표현식인 문

let x = let y;
// 표현식이 아닌 문
```

++ 완료 값
개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined를 출력하는데, 이를 **완료 값**이라고 한다. 완료값은 평가 결과가 아니라 할당할 수 없고, 참조할 수 없다.

# 06장 데이터 타입
자바스크립트의 모든 값은 데이터 타입을 가진다.
총 7개의 데이터 타입을 제공한다. 6개의 원시타입 + 객체타입으로 이루어진다.

|원시타입|설명 |
| -- | -- |
|숫자|숫자.(정수, 실수 구분이 없다.)|
|문자열|'문자열'|
|불리언|true, false|
|undefined|var키워드의 초기화에 사용되는 값|
|null| 값이 없음을 의도적으로 표현하는 값|
|심벌|ES6에서 추가된 타입|

객체 타입 - 객체, 함수, 배열

+ 타입이 궁금하다면 typeof를 통해 알아볼 수 있다.

## 6.1 숫자 타입
자바스크립트에서는 10진수를 위한 데이터타입만을 지원하기에 2진수 8진수 16진수 모두 참조시에 10진수로 해석된다.
```
0o101 === 0x41 // true
```
또한 다음의 값들 또한 표현할 수 있다.

* Infinity: 양의 무한대
* -Infinity: 음의 무한대
* NaN: 산술 연산 불가. Not a Number를 의미한다.

```
(10 / 0) // Infinity
(10 / -0) // -Infinity
```

## 6.2 문자열 타입
텍스트 데이터를 나타내는 데 사용한다.
'', "", ``으로 텍스트를 감싼다.
```
'이렇게';
"이렇게";
`이렇게`;	
```

## 6.3 템플릿 리터럴
멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 문자열 처리 기능을 가진 문자열 표기법이다.

오로지 백틱만을 사용한다.

* 멀티라인 문자열
```
console.log(`안녕
하세요`);

// 결과물
안녕
하세요
```

* 표현식 삽입
: ${}으로 표현식을 감싸면 평가결과를 문자열로 바꿔 삽입한다.
```
console.log(`1 + 1 은 ${1 + 1} 입니다.`)
// 1 + 1 은 2 입니다.
```
## 6.4 undefined
 undefined 타입의 값은 undefined가 유일하다.
 undefined는 변수를 초기화하는데 사용된다. 즉, 개발자가 임의로 사용한다면 본래 취지에 어긋나며 혼란을 줄 수 있으므로 권장하지 않는다.
 변수에 값이 없음을 명시하고 싶을떄는 **null**을 사용한다.

 ## 6.5 null
 null 타입의 값 또한 null이 유일하다.
 > 값이 없음을 의도적으로 명시한다. 
 즉, null이 할당된 변수는 더이상 이전의 값을 참조하지 않겠다는 의미이다. 따라서 전에 있던 값의 메모리 공간에 대한 가비지 콜렉션이 수행된다.

 ## 6.6 심벌
> 변경이 불가능한 원시 타입의 값

중복이 되지 않는 유일무이한 값이다. 객체의 프로퍼티 값이 중복없이 유일하기 위해 사용한다.

Symbol 함수를 호출해 생성한다. 외부에 노출되지 않으며, 다른 값과 중복되지 않는다.
```
let key = Symbol('key');
let obj = {};
obj[key] = '값임';
```

## 6.7 데이터 타입의 필요성
### 6.7.1 데이터 타입에 의한 메모리 공간 확보와 참조
메모리 값을 저장하기 위해서는 메모리 공간의 크기를 결정해야 한다.
만약 
```
let num = 100;
```
에서 num을 참조하고 싶으면 어떻게 할까? num에 할당된 값은 숫자 타입으므로 8바이트 단위로 읽지 않으면 값이 훼손된다. 이럴 때 자바스크립트 엔진은 num 변수를 숫자 타입으로 인식해 8바이트 단위로 값을 읽어 들인다. 

### 6.7.2 데이터 타입에 의한 값의 해석
그런데 이 100을 어떻게 해석하느냐의 문제가 남아있다.
모든 값은 메모리에 2진수의 나열로 저장된다. 하지만 데이터 타입에 따라 2진수는 다르게 해석될 수 있기 때문에, 데이터 타입에 따라 다르게 해석될 수 있다.
그러나 num에 숫자 타입의 값이 할당되어 있기 때문에, 자바스크립트 엔진은 이 2진수를 숫자로 해석한다.

## 6.8 동적 타이핑
> 정적 타입 언어(c, 자바): 변수 선언 시 데이터 타입을 사전에 선언해야한다.(명시적 타입 선언).

정적 타입 언어는 컴파일 시 타입 체크를 실시하는데, 이를 통과하지 못하면 프로그램의 실행 자체를 막는다. 

자바스크립트는 변수 선언 시 타입을 선언하지 않고, 키워드만을 사용한다. 따라서 타입에 상관없이 자유로운 할당이 가능하다.  다시말해, 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정된다. 그리고 재할당에 의해 언제든 타입을 바꿀 수 있는데 이를 **동적 타이핑**이라고 하며, 이러한 언어를 **동적 타입 언어**라고 한다. 동적 타입 언어에서는 값에 의해 변수의 타입이 동적으로 결정된다. 

* 동적 타입 언어의 단점
1. 변화하는 변수 값을 추적하기 어려울 수 있다.
2. 값의 확인 전에는 타입을 확신할 수 없다. 즉, 유연성은 높지만 신뢰성은 떨어진다.

* 변수 사용 시 주의사항
1. 꼭 필요한 경우에만 사용
2. 스코프를 최대한 좁게 만들 것
3. 전역 변수는 최대한 사용을 자제할 것
4. 상수를 사용해 변경을 억제
5. 변수 이름은 목적과 의미를 파악할 수 있도록 네이밍 할 것

# 7장 연산자
> 연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산을 수행해 하나의 값을 만든다.

## 7.1 산술 연산자
> 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다.
불가능할 경우, NaN을 반환한다.

### 7.1.1 이항 산술 연산자
> 2개 이상의 피연산자를 산술 연산해 숫자 값을 만든다.
### 7.1.2 단항 산술 연산자
> 1개의 피연산자를 산술 연산해 숫자 값을 만든다.
++, -- 등

이 연산자들은 위치에 의미가 있다.
* 피연산자 앞에 위치할 경우 값을 먼저 증가시킨 뒤, 다른 연산을 수행한다.

숫자 타입이 아닌 값에 +, -를 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다.
```
let test = '1';
console.log(typeof +test)// 'number'
test = true;
console.log(+test) // 1
```
### 7.1.3 문자열 연결 연산자
>+의 피연산자 중 하나라도 문자열인 경우 문자열 연결 연산자로 동작한다. 
```
(1 + '1'); // '11'
1 + true; // 2
```
개발자의 의도와 상관없이 암묵적으로 타입이 변환됨에 주의해야한다. 이를 **암묵적 타입 변환** 혹은 **타입 강제 변환** 이라고 한다.

## 7.2 할당 연산자
> 우항의 피연산자를 좌항의 변수에 할당한다.

## 7.3 비교 연산자
> Object.is는 예측 가능한 정확한 비교 결과를 리턴한다.
```
Object.is(NaN, NaN) // true
```

## 7.4 삼항 조건 연산자
삼항 조건 연산자는 값으로 평가할 수 있는 표현식인 문이다. 따라서 값처럼 다른 표현식의 일부가 될 수 있다.
```
let test = 10;
let result = test % 2 ? '홀수' : '짝수';
```
수행해야 할 문이 여러개라면 if else 문의 가독성이 더 좋다.

## 7.5 그룹 연산자
>우선순위를 정하기 위한 연산자. ()를 사용해 감싸면 우선순위가 가장 높다.
```
10 * 2 + 10; // 30
10 * (2 + 10); // 24 
```

## 7.6 지수 연산자
> 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭제곱한다
```
2 ** 2; // 4
```

## 7.7 연산자의 부수 효과
> 할당 연산자, 증가/감소 연산자, delete연산자는 다른 코드에 영향을 준다.

```
let test = 1;

test++;

console.log(test); // 2

test --;

console.log(test); // 1

let obj = { a: 1};

delete obj.a;

console.log(obj);// {}
```

## 7.8 연산자 우선순위
연산자 우선순위는 모두 기억하기 어렵다. 따라서 ()를 사용하여 명시적으로 조절하는 것이 권장된다.

# 8장 제어문
> 제어문은 조건에 따라 코드블록을 실행하거나 반복 실행할 때 사용한다.

## 8.1 블록문
> 블록문: 0개 이상의 문을 중괄호로 묶은 것(= 코드 블록, 블록)

* 블록문은 하나의 실행 단위이다. 

* 단독 사용이 가능하나 일반적으로는 제어문, 함수 정의에 사용한다.

* 블록문은 자체 종결성을 가지기 때문에 세미콜론을 붙이지 않는다.

```
{
	let five = 5;
	// 이런식으로 사용하는 경우는 거의 없다.
}

function sum(a, b) {
	return a + b;
}
// 이런식으로 함수 정의에 사용되기도 한다.
```

## 8.2 조건문
> 조건문: 주어신 조건식의 평가 결과에 딸 코드 블록의 실행을 결정한다.

자바크립트의 조건문

1. if ...else 문
2. switch문

### 8.2.1 if...else 문
```
if(조건식) {
	// 조건식이 참일때 실행될 코드
} else {
	// 조건식이 거짓일때 실행될 코드
}
```

* 조건식을 Boolean으로 평가되어야한다.

* 만약 조건에 따라 실행될 블록을 늘리고 싶으면 else if 문을 사용한다.

* if와 else 는 2번 이상 사용이 불가능하다.

* 블록 내부의 문이 하나뿐이라면 중괄호를 생략할 수 있다.
```
if(true) return true;
```

* if...else 문은 삼항연산자로 바꿀 수 있다.
<br>삼항 연산자를 사용하는것이 가독성은 좋으나, 조건이 여러개일 경우 if...else의 가독성이 좋다.

### 8.2.2. switch문
> 표현식을 평가하여 그 값과 일치하는 표현식을 가지는 case문으로 실행흐름을 옮긴다.

* switch문의 표현식과 인치하는 case문이 없으면 순서가 default로 이동한다.

* 참/거짓을 따지기보다는 다양한 상황에 따라 실행할 코드 블록을 결정할 때 쓰인다.

```
let age = 19;
let notion;
switch(age) {
	case 19 : notion = '야 나가';
}

console.log(notion); // '야 나가'
```

그러나 switch문에는 되도록이면 break를 써주는 것이 좋다. 다음의 경우를 보면

```
let age = 19;
let notion;
switch(age) {
	case 19 : notion = '야 나가';
	case 20 : notion = '어서오세연!';
  default : notion = '신분증좀 주세연' ;
}

console.log(notion); // '신분증좀 주세연' 
```
`'야 나가'` 이 출력될거라는 예상과 다르게 default의 문이 실행된 것을 볼 수 있다. 이는 코드의 실행은 정상적으로 `case 19`으로 옮겨졌지만, break문이 없어 밑의 case문과 default문을 거치며 실행했기 때문이다. 이처럼 switch문을 탈출하지 못하고 밑의 case와 default를 실행하는 것을 **폴스루**라고 부른다.

break는 코드 블록에서 탈출하는 역할을 한다. 따라서 위는 다음과 같이 쓰여야 한다.
```
let age = 19;
let notion;
switch(age) {
	case 19 : notion = '야 나가';
	break;
	case 20 : notion = '어서오세연!';
	break;
  default : notion = '신분증좀 주세연' ;
}

console.log(notion); // '야 나가'
```

* if...else문으로 해결할 수 있으면 그러는게 좋은, 조건이 너무 많아 가독성에 문제가 있다면 switch문을 사용하는 것이 더 좋을 수 있다.

## 8.3 반복문
> 조건식의 결과가 거짓이 나오기 전까지 코드를 반복해서 실행한다.

* 자바스크립트에서 제공하는 반복문
1. for 문
2. while 문
3. do...while 문

### 8.3.1 for문
> 조건식이 거짓으로 평가될 때까지 코드를 반복 실행한다.

* for문의 변수 선언문, 조건식, 증감식은 옵션이다. 다만, 어떤 식도 선언하지 않으면 코드가 무한 실행된다.
```
for(;;) {
	console.log('무한실행');
}
```
* for문 안의 코드블록에 for문을 또다시 사용할 수 있다. (중첩 for문)

8.3.2 while문
> 조건식이 거짓으로 평가될 때까지 코드를 반복 실행한다. 다만, **반복 횟수가 불명확 할 때 주로 사용한다.**

### 8.3.3 do...while문
> 코드 블록을 먼저 실행한 다음 조건식을 평가한다.

```
let count = 3;
do {
	console.log(count);
	count--;
} while (count > 0);
```

## 8.4 break 문
> 코드 블록을 탈출한다. 다만, **레이블 문, 반복문, switch문 등의 코드 블록을 탈출한다.** 이 외의 블록에서 사용할 경우 SyntaxError가 발생한다.

* 레이블 문은 식별자가 붙은 문이다.
```
sayHello : console.log('안녕');
```
레이블문은 일반적으로 중첩for문을 탈출할 때 외에는 권장하지 않는다.

## 8.5 continue문
> 반복문의 코드 블록 실행을 여기서 멈추고, 증감식으로 실행 흐름을 이동시킨다.

```
let test = 0;

for (let i = 0 ; i < 5 ; i++) {
	if(i < 2) continue;
	test++;
}
console.log(test); // 3
```
i < 2일 경우 `test++`은 실행되지 않고 증감식(`i++`)으로 이동한다. 그 후 i가 2일때부터 `test++`가 실행된다. 이는 밑의 코드와 같다.

```
for (let i = 0 ; i < 5 ; i++) {
	if(i >= 2) test++;
}
```
실행해야 할 코드가 한줄이면 continue보다 가독성이 좋다. 그러나 코드가 길어진다면 continue문을 사용하는 편이 가독성이 좋다.

```
for (let i = 0 ; i < 5 ; i++) {
	if(i < 2) continue;
	test++;
	console.log('가독성이 좋아연');
}

for (let i = 0 ; i < 5 ; i++) {
	if(i >= 2) {
		test++;
		console.log('가독성이 별루에연');
	}
}
```

# 9장 타입 변환과 단축 평가
## 9.1 타입 변환이란 무엇인가
자바스크립트의 모든 값은 타입이 있고, 개발자의 의도에 따라 다른 타입으로 변환할 수 있다. 
* 명시적 타입 변환(= 타입 캐스팅): 개발자가 의도적으로 타입을 변환하는 것
* 암묵적 타입 변환(= 타입 강제 변환): 개발자 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환

```
let num = 10;
// 명시적 타입 변환. toString을 이용해 의도적으로 타입을 변환함
let str = num.toString();
console.log(typeof str, str); // string, 10;

// 암묵적 타입 변환. 문자열 연결 연산자가 새로운 문자열을 생성
str = num + '';
console.log(typeof str, str); // string, 10;

```

* 이때, 기존의 원시 값 `num`은 직접 변경되지 않는다. 타입 변환은 기존 원시값을 이용해 다르 타입의 새 원시값을 생성하는 것이다. 
> 명시적 타입 변환은 변환의 의지가 코드에 명백히 드러난다. 하지만 암묵적 타입 변환의 경우 자동 변환이기 때문에 개발자의 의지가 명백히 나타나는 것은 아니다.
<br>
따라서 암묵적 타입 변환이 일어나지 않도록 코드를 작성하는 것이 좋다고 생각할 수 있다. 그러나 이는 옳지 않다. 개발자의 입장에서 `(10).toString()`보다는 `10 +''`가 더 간결하고 이해하기 쉽다.
<br>
코드를 작성할 때 가장 중요한 것은 협업을 해야함을 잊지 않는 것이다. 따라서 동료가 쓴 코드를 이해할 수 있어야 하고, 내가 쓴 코드를 동료가 이해하기 쉽도록 해야 한다.

## 9.2 암묵적 타입 변환
자바스크립트에서는 가능한 에러를 줄이기 위해 암묵적 타입 변환을 통해 표현식을 평가한다.
```
'10' + 3 // '103'
```
암묵적 타입 변환이 발생하면 원시 타입 중 하나로 값을 자동 변환한다.

### 9.2.1 문자열 타입으로 변환
> `+` 연산자는 피연산자 중 하나라도 문자열이라면 문자열 연결 연산자로 동작한다.

그 뿐 아니라, 표현식을 평가할때 또한 암묵적으로 타입 변환한다.
```
1 + '2' // -> "12"

//표현식을 암묵적으로 변환한다.
`1 + 1 = ${1 + 1}` // -> "1 + 1 = 2"

```

### 9.2.2 숫자 타입으로 변환
> 산술 연산자 표현식을 평가하기 위해 피연산자 중 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다.

만약 피연산자가 숫자 타입으로 변환이 불가능한 경우, 표현식의 평가 결과는 NaN이 된다.

```
1 - '1' // 0
1 / 'one' // NaN
```

> 비교 연산자 또한 피연산잘르 숫자 타입으로 암묵적 타입 변환한다.

```
1 > '0' // true
```

> `+`단항 연산자는 피연산자가 숫자 타입이 아니면 숫자 타입으로 암묵적 타입 변환한다.
```
// 문자열 타입
+''       // -> 0
+'0'      // -> 0
+'1'      // -> 1
+'string' // -> NaN. string은 숫자 타입으로 평가될 수 없으므로 NaN.

// 불리언 타입
+true     // -> 1
+false    // -> 0

// null 타입
+null     // -> 0

// undefined 타입. 단, 이 경우 NaN을 반환한다. 
+undefined // -> NaN
```
### 9.2.3 불리언 타입으로 변환
> 조건식에서 자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값, 또는 Falsy 값으로 평가한다.

Falsy로 평가되는 값은 다음과 같다.

* false
* undefined
* null
* 0, -0
* NaN
* ''

이 외에는 모두 Truthy로 평가된다.

## 9.3 명시적 타입 변환
표준 빌트인 생성자 함수에서 new 연산자 없이 호출, 빌트인 메서드 사용, 암묵적 타입 변환 이용

### 9.3.1 문자열 타입으로 변환
* String 생성자를 new 없이 호출 
* Object.prototype.toString 메서드 사용
* 문자열 연결 연산자 이용

```
// 1. String 생성자 함수를 new 연산자 없이 호출
// 숫자 타입 => 문자열 타입
String(1); // -> "1"
String(NaN); // -> "NaN"
String(Infinity); // -> "Infinity"
// 불리언 타입 => 문자열 타입
String(true); // -> "true"

// 2. Object.prototype.toString 메서드를 사용
// 숫자 타입 => 문자열 타입
(1).toString(); // -> "1"
(NaN).toString(); // -> "NaN"
(Infinity).toString(); // -> "Infinity"
// 불리언 타입 => 문자열 타입
(true).toString(); // -> "true"

// 3. 문자열 연결 연산자를 이용
// 숫자 타입 => 문자열 타입
1 + ''; // -> "1"
NaN + ''; // -> "NaN"
Infinity + ''; // -> "Infinity"
// 불리언 타입 => 문자열 타입
true + '';     // -> "true"
```
### 9.3.2 숫자 타입으로 변환
* Number 생성자 합수 new 연산자 없이 호출
* parseInt, parseFloat함수 사용
* `+` 단항 산술연산자 사용
* `*`산술 연산자 사용

```
// 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법
// 문자열 타입 => 숫자 타입
Number('0'); // -> 0
// 불리언 타입 => 숫자 타입
Number(true); // -> 1

// 2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)
// 문자열 타입 => 숫자 타입
parseInt('0');       // -> 0

// 3. + 단항 산술 연산자를 이용하는 방법
// 문자열 타입 => 숫자 타입
+'0';     // -> 0
+'-1';    // -> -1
// 불리언 타입 => 숫자 타입
+true;    // -> 1

// 4. * 산술 연산자를 이용하는 방법
// 문자열 타입 => 숫자 타입
'0' * 1;     // -> 0
// 불리언 타입 => 숫자 타입
true * 1;    // -> 1
```

### 9.3.3 불리언 타입으로 변환
* Boolean 생성자 함수를 new 연산자 없이 호출
* ! 부정 논리 연산자를 두번 사용

```
Boolean('x') // true
Boolean('') // false
Boolean('false') // true

!!'' ; false
!!'false' ; true
```

## 9.4 단축 평가
### 9.4.1 논리 연산자를 사용한 단축 평가
> 논리합, 논리곱 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.

둘다 좌항에서 우항으로 진행된다.

```
'left' && 'right'; // 'right'
'' || 'right' // ''
```

> **논리곱, 논리합 연산자는 피연산자를 타입 변환하지 않고 그대로 반환하는데, 이를 단축 평가라고 한다.**

단축 평가는 if문을 대체할 수 있다.
```
let age = 19;
let messange;

message = (age >= 19) && '어서오세여 손님!';
console.log(message);

// 이는 다음 식과 같다.
if(age >= 19) message = '어서오세여 손님!'

// 또한 다음과 같이 사용할수도 있다.
message = age < 19 || '야 나가';
console.log(message) // '야 나가'
```

단축 평가의 유용한 패턴은 다음과 같다.
* **객체가 가리키키를 기대한 변수가 null, undefined인지를 확인하고 프로퍼티를 참조할 때**
만약 변수의 값이 객체가 아니라 null, undefined인 경우 타입 에러를 발생시키고, 강제적으로 프로그램이 종료된다. 
이때 단축평가를 사용하면 이를 방지할 수 있다.
```
let obj = null;
let value = obj.value // TypeError

// 이를 아래와 같이 쓰면 에러를 방지한다.
let value = obj && elem.value // null
```

* **함수 매개변수에 기본값을 설정할 때**
함수 호출 시 인수를 전달하지 않는다면 undefined가 할당된다. 단축 평가를 사용해 매개변수의 기본값을 설정하면, undefined일때 생성되는 오류들을 방지할 수 있다.

```
function checkAge(age) {
  age = age || '민자';
  return age >= 19 ? '어서오세연 손님!' : '야 나가'
}

checkAge(); // '야 나가'
```
물론 ES6의 매개변수 기본값 설정을 사용하면 더 쉽게 가능하다.
```
function checkAge(age='민자') {
  return age >= 19 ? '어서오세연 손님!' : '야 나가'
}
checkAge(); // '야 나가'
```

### 9.4.2 옵셔널 체이닝 연산자 `?.`
> 좌항의 피연산자가 null, undefined인 경우 undefined를 반환하고, 아니면 우항의 프로퍼티 참조를 이어간다. 

논리곱의 경우 Falsy값이면 좌항의 피연산자를 그대로 반환했다. 하지만 0과 ''의 경우 객체로 평가되는 경우가 있다.

```
let name = '';
let length = name && name.length; // 이름의 길이를 참조하고 싶음
console.log(length) // ''. 즉 이름의 길이를 참조를 못함
```

하지만 옵셔널 체이닝 연산자의 경우 Falsy값 이라도 null, undefined가 아니면 프로퍼티 참조를 이어간다.
```
let name = '';
let length = name?.length;
console.log(length) // 0
```

### 9.4.2 null병합 연산자 `??`
> 좌항의 피연산자가 null, undefined인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다.

변수에 기본값을 설정할 때 유용하다.
```
// Falsy 값인 0이나 ''도 기본값으로서 유효하다면 예기치 않은 동작이 발생할 수 있다.
var foo = '' || 'default string';
console.log(foo); // "default string"

// 좌항의 피연산자가 Falsy값이라도 null, undefined가 아니면 좌항의 피연산자를 반환한다.
let foo = null ?? 'default string';
console.log(foo); // "default string"
var foo = '' ?? 'default string';
console.log(foo); // ""
```

# 10장 객체 리터럴
## 10.1 객체란 무엇인가
> 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조

* 원시값을 제외한 나머지는 모두 객체다.
* 객체는 0개 이상의 프로퍼티로 구성되어 있으며 프로퍼티는 키와 값으로 구성된다.
* 자바스크립트의 모든 값은 프로퍼티 값이 될 수 있다. 자바스크립트는 함수를 일급 객체 취급하므로, 함수도 값이 될 수 있다. 이를 **메서드** 라고 부른다.

이를 다시 정리하자면
* 프로퍼티: 객체의 상태를 나타내는 값
* 메서드: 프로퍼티를 참조하고 조작할 수 있는 동작

## 10.2 객체 리터럴에 의한 객체 생성
자바스크립트는 다양한 객체 생성 방법을 지원한다.
* 객체 리터럴
* Object 생성자 합수
* 생성자 함수
* object.create 메서드
* 클래스

이 중 가장 일반적인 방법은 객체 리터럴을 이용하는 방식이다. 중괄호 내에 0개 이상의 프로퍼티를 정의한다. 변수에 할당되는 시점에 자바스크립트 엔진이 이를 해석해 객체를 생성한다. 만약 프로퍼티를 정의하지 않으면 빈 객체가 생성된다.
```
let product = {
	price: 6000,
	sale: function() {
		this.price = this.price * 0.5
	}
};

product.sale();
product.price;

let obj = {};
```
여기서 객체 리터럴의 중괄호는 코드 블럭이 아님을 주의하자. 때문에 세미콜론을 붙여야한다.

## 10.3 프로퍼티
> 객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.

* 프로퍼티 키: 빈 문자열 포함 모든 문자열 또는 심벌 값
* 프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값

프로퍼티 키는 식별자 역할을 하지만 식별자 네이밍 규칙을 반드시 지켜야 하는 것은 아니다. 그러나 식별자 규칙을 따르지 않을 경우 반드시 따옴표를 사용해야 한다.
```
let product = {
	price: 6000,
	'made-in': korea
}
```
* 프로퍼티의 동적 생성 또한 가능하다.
```
let product = {
	price: 6000,
	sale: function() {
		this.price = this.price * 0.5
	}
};

product['name'] = '스파클링';
console.log(product); //{ price: 6000, sale: ƒ sale(), name: '스파클링' }
product[''] = '뭐여';
console.log(product);
// {
  price: 6000,
  sale: ƒ sale(),
  name: '스파클링',
  '': '뭐여'
}
```
여기서 주목할 점은 빈 문자열 또한 키로 사용이 가능하다는 점이다. 그러나 이는 키로서 의미가 없으므로 권장되지 않는다.

* 문자열, 심벌 이외의 값을 키로 사용하면 암묵적 타입 변환을 통해 문자열로 변환된다.

* 예약어를 사용해도 오류가 발생하지는 않는다. 다만 어떤 오류가 생길지 모르니 추천하지는 않는다.

* 같은 키를 사용할 경우 나중에 작성한 키의 값이 먼저 선언한 키의 값을 덮어쓴다.

```
let test1 = {
	0: 0
}

let test2 = {
	function = "function"
}

let test3 = {
	test = "test",
	test = "테스트"
}
```

## 10.4 메서드
> 프로퍼티의 값이 함수일 경우, 일반 함수와 구분하기 위해 메서드라고 부른다. 

## 10.5 프로퍼티 접근 방법
다음의 두가지 방식이 있다.
* 마침표 표기법(. 사용)
* 대괄호 표기법([] 사용) 

프로퍼티 키가 자바스크립트에서 유효한 이름이면 둘 다 사용이 가능하다. 

또한 **대괄호 표기법을 사용하는 경우, 대괄호 내부에는 반드시 따옴표로 감싼 문자열이 들어가야 한다**단, 숫자로 이루어진 문자열이라면 따옴표를 생략할 수 있다.

```
let product = {
	price: 6000,
	sale: function() {
		this.price = this.price * 0.5
	}
};
console.log(product['price']); // 6000
```
객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환한다.(ReferenceError가 발생하지 않음에 주의하자.)

* 프로퍼티 키가 자바스크립트에서 유효한 이름이 아니면 반드시 대괄호 표기법을 준수해야한다.

```
let iPhone = {
	'phone-name' : 'iPhone 13',
	13: 'pro'
}
iPhone.'phone-name'; // SyntaxError
iPhone.phone-name; // 브라우저와 Node.js에서의 결과가 다르다.
iPhone['phone-name'] // 'iPhone 13'

iPhone.1; // SyntaxError
iPhone[1]; // 'pro'
```
위에서 브라우저와 Node.js의 실행 결과가 드르다 자바스크립트 엔진에서는 iPhone.phone를 평가한다. 이는 undefined로 평가되며(phone라는 키가 없으니까) 결국 undefined - name과 같아진다.
<br>Node.js에서는 name이라는 식별자가 없으므로 ReferenceError가 발생한다. 하지만 브라우저에는 전역객체에 name이 암묵적으로 존재하는데 이는 빈 문자열이다. 따라서 undefined - ''와 같아져 NaN이 된다.

## 10.6 프로퍼티 값 갱신 및 삭제
> 이미 존재하는 프로퍼티에 값을 할당하면 값이 갱신된다.
```
let person = {
	name: 'do'
}
person.name = 'hs';
console.log(person.name); // 'hs'
```
> delete연산자는 객체의 프로퍼티를 삭제한다. 이때, 존재하지 않는 프로퍼티에 접근하면 에러 없이 무시된다.
```
delete person.name;
delete person.age;
console.log(person); // {}
```

## 10.9 ES6에서 추가된 객체 리터럴 확장 기능
### 10.9.1 프로퍼티 축약 표현
> 변수 이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티 키를 생략할 수 있다.
```
let x = 1;
let y = 2;

let obj = {x, y};
console.log(obj); // {x: 1, y: 2}
```

### 10.9.2 계산된 프로퍼티 이름
> 객체 리터럴 내부에서 프로퍼티 키를 동적 생성할 수 있다. 
```
const prefix = 'test';
let i = 0;

// 객체 리터럴 내부에서 계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성
const obj = {
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i
};

console.log(obj); // {test-1: 1, test-2: 2, test-3: 3}
```

### 10.9.3 메서드 축약 표현
> function 키워드를 생략한 축약 표현을 사용할 수 있다.
```
const person = {
	name: 'do',
	sayHi() {
		console.log('안냐세연~~');
	}
}
```

# 11장 원시 값과 객체의 비교
 
|원시타입|객체타입|
|---|---|
|변경 불가능한 값|변경 가능한 값|
|변수에 실제 값 저장|변수에 참조값 저장|
|변수를 다른 변수에 할당하면 원시값 복사 전달|변수를 다른 변수에 할당하면 참조 값이 복사되어 전달|

## 11.1 원시 값
### 11.1.1 변경 불가능한 값
> 원시 값 = 변경이 불가능한 값. 읽기 전용의 값이라 변경이 불가능하다.

* 주의할 점은, 변경이 불가능하다는 것은 변수가 아닌 값에 대한 진술임. 즉, 변수값이 재할당이 불가능 하다는 점이 아니다. 
* 이러한 원시값의 특성은 데이터의 신뢰성을 보장한다.

* 만약 원시값의 변경이 가능했다면, 재할당이 일어났을 때 메모리 공간의 주소를 변경하는 것이 아닌, 기존 메모리 주소에 있는 원시 값 자체를 변경한다.

* 이러한 값의 특성을 불변성이라고 한다. **불변성을 가지는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 방법이 없다.**

### 11.1.2 문자열과 불변성
* 원시값을 저장하기 위해서는 확보해야하는 메모리 공간의 크기를 정해야 하고, 원시 타입별로 메모리 공간의 크기가 미리 정해져 있다.

* 문자열은 유사 배열 객체이자 이터러블 이므로 각 문자 하나하나에 접근이 가능하다. 하지만, 그 문자 하나하나를 변경할 수는 없다.

```
let test = 'test;

console.log(test[0]); // 't'
test[0] = 'T'; 
console.log(test); // 'test'
```

* 이러한 특징은 예기치 못한 변경으로부터 문자열을 보호한다. 이는 데이터의 신뢰성을 보장한다.

### 11.1.3 값에 의한 전달
```
let test1 = 'test1';
let test2 = test1;

console.log(test1, test2); // 'test1', 'test1'

test1 = 'test3';
console.log(test1, test2); // 뭐가 출력될까요?
```

결론부터 말하자면 `'test3', 'test1'` 이 출력된다. 
`test2 = test1`이 실행되면 `test2`에는 `test1`의 원시 값 `'test1'`이 복사되어 전달된다. 그러나 `test1`과 `test2`의 `'test1'`은 다른 메모리 공간에 저장된 값이다.
<br>따라서 `test1`의 변수 값을 `'test3'`로 전달해도 `test2`에는 어떤 영향도 끼치지 못한다.

> "값에 의한 전달" 또한 정확히 말하면 값이 아니라 메모리 주소를 전달한다. 이 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있는 것이다.
<br><br> 결론: **두 변수의 원시 값은 메모리 주소가 다르기 때문에, 재할당을 통해 한쪽의 값을 변경해도 서로 간섭할 수가 없다**

## 11.2 객체
* 객체는 내부의 프로퍼티 갯수가 정해져 있지 않기 때문에, 필요한 메모리 공간의 크기도 미리 설정할 수 없다.

### 11.2.1 변경 가능한 값
> 객체는 변경 가능한 값이다.

* 객체를 할당받은 변수가 기억하는 메모리 주소로 메모리에 접근하면 참조 값, 즉, 객체가 저장된 메모리 공간의 주소 그 자체에 접근하게된다.
=> 메모리에 저장된 참조값을 통해 실제 객체에 접근한다.

* **객체는 변경 가능한 값이기 때문에, 재할당 없이 직접 변경할 수 있다. 즉, 동적인 프로퍼티의 추가, 갱신, 삭제가 가능하다.**

* 객체의 구조적 단점은 **하나의 객체를 여러 변수가 참조한다는, 그러니까 진정한 의미의 공유가 가능하다는 것이다.**

```
let obj = {
	test: 1
};
obj.test = 3;

console.log(obj); // { test: 3 }
```
* 얕은복사와 깊은복사
객체를 프로퍼티의 값ㅇ로 가지는 객체의 경우, 얕은 복사는 한 단계 까지만 복사하는 것이고, 깊은 복사는 객체에 중첩된 객체까지 복사하는 것이다. 
```
	let obj = {
	test: {test1: 2}
};

let obj2 = {...obj};
```
위 경우 `obj === obj2`는 `false`지만, `obj.test === obj2.test` 는 true가 나온다. 즉, 가장 바깥을 감싸는 객체는 복사가 되어 다른 메모리 공간을 차지하는 것이고, 내부에 프로퍼티의 값으로 중첩된 객체는 서로 같은 주소를 참조하고 있는 것이다. 

### 11.2.2 참조에 의한 전달 
```
let test1 = {
	test: 1
};

let test2 = test1;
```
위의 경우에서 `test1`과 `test2`는 모두 하나의 객체를 가리키고 있다. 따라서 어느 한쪽에서 객체의 프로퍼티를 추가, 변경, 삭제한다면 다른 한쪽도 그 영향을 받는다. 

> 결국 "값에 의한 전달"과 "참조에 의한 전달" 모두 메모리 공간에 저장된 값을 복사해서 전달한다. 그러나 원시값의 경우 저장된 값이 원시값 그 자체가 되고, 객체값은 저장된 값이 객체가 저장된 공간의 메모리 주소, 즉, 참조값이 전달된다. 

따라서 엄밀히 말하면 둘 다 값에 의한 전달이라 할 수 있으나, 그 내용물에서 차이를 보이는 것이다.

# 12장 함수
## 12.1 함수란 무엇인가?
> 함수: 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것

* 함수를 정의하는 4가지 방식
1. 함수 선언문
```
function add(a,b) {
	return a + b
}
```
2. 함수 표현식
```
const add = function(a,b){
	return a + b
}
```
3. 생성자 함수
```
const add = new Function('x', 'y', 'return x + y')
```
4. 화살표 함수
```
const add = (a,b) => {
	return a + b
}
```

## 12.2 함수의 사용 이유
> 코드의 재사용성 이라는 측면에서 매우 유리하다.
```
// 함수를 사용하지 않는다면?
// 아래같은 단순한 구구단을 사용하고 싶어도 재할당을 반복해야함
let a;
let b;
let result;

a = 1;
b = 1;
result = a * b;

a = 1;
b = 2;
result = a * b;

// 함수를 사용한다면
function multiply(a,b) {
	return a * b;
}

result = multiply(1,1);
result = multiply(1,2);
```
위의 코드처럼 함수를 사용한다면 중복 코드를 억제하고 함수를 재사용할 수 있다. 이를 통해 **유지보수의 편의성**을 높이고, 때문에 **코드의 신뢰성**은 높아진다. 또한 함수의 이름을 신중하게 지어 이름으로 그 내용을 유추할 수 있게 하면 **가독성** 또한 좋아진다.

## 12.3 함수 리터럴
> **함수 또한 객체다**

```
let f = function add(a,b) {
	return a + b;
};

```
함수 리터럴은 function 키워드, 이름, 매개변수 목록, 함수 몸체로 구성된다.

하지만 일반 객체와는 달리 호출할 수 있다는 점에서 차이를 보인다. 

## 12.4 함수 선언 방식
### 12.4.1 함수 선언문
```
function add(a,b) {
	return a + b;
}
```
함수 리터럴과 형태가 동일하나, 함수 선언문에서는 이름을 생략할 수 없다.
함수 선언문은 표현식이 아닌 문이다. 
그렇다면 값으로 평가되지 않는데, 다음의 코드를 보자.
```
let add = funcion add (a,b) {
	return a + b;
}; // 이를 함수 표현식이라고도 한다.
```
함수 선언문이 값으로 평가되지 않는다면 변수에도 할당할 수 없어야 하는데, 마치 그러고 있는 것처럼 보인다. 이는 자바스크립트 엔진이 문맥에 따라 함수 선언문과 함수 리터럴을 선택해 해석하고 있기 때문이다. `{}`의 경우도 마찬가지고 객체와 코드 블록 사이에서 문맥에 따라 선택한다.

* 자바스크립트 엔진은 함수를 호출하기 위해 함수 이름과 동일하게 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다. 

### 12.4.2 함수 표현식
> 함수 표현식: 함수 객체를 변수에 할당하는 것.

```
let add = funcion add (a,b) {
	return a + b;
};
```

* 함수 이름을 생각하는 것이 일만적이다.

### 12.4.3 함수 생성 시점과 함수 호이스팅
```
console.log(test1); // f test1()
console.log(test2); // undefined

function test1 () {
	return 3;
}

var test2 = function() {
	return 1
};
```

왜 첫째 코드는 함수를 잘 출력하지만 두번째 코드는 undefined를 발생시킬까. 이는 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 지식이 다르기 때문이다.  

함수 선언문으로 만든 함수의 경우 변수와 비슷하게 **함수 호이스팅**이 발생한다. 단, 함수의 경우 곧바로 함수 객체로 초기화가 된다. 따라서 `test1`을 위에서 참조해도 undefined 를 발생시키 않는 것이다.
하지만 함수 표현식은 undefined로 먼저 초기화되므로, 런타임에 평가되기 때문에 그 시점에 함수 객체가 되고 그 전에 참조하면 undefined를 참조하는  것이다. 따라서 함수 표현식을 정의하면 함수 호이스팅이 아니라 변수 호이스팅이 발생한다.

### 12.4.4 Function 생성자 함수
> 생성자 함수는 객체를 생성하는 함수이다. 
```
const add =new Function('x', 'y', 'return x + y')
```
위에서 new를 제외하도 상관은 없다. 다만 생성자 함수를 이용하는 방법을 바람직하지도 않고, 일반적이지도 않다.

### 12.4.5 화살표 함수

```
const add = (a,b) => a + b;
```
화살표 함수는 생성자 함수로 사용할 수 없고, this바인딩 또한 다르며, prototype 프로퍼티가 없고 arguments 객체를 생성하지도 않는다. 


## 12.5 함수 호출
### 12.5.1 매개변수와 인수
함수 외부의 값이 필요한 경우 매개변수를 이용해 인수로 전달한다. 
**매개 변수보다 인수가 적으면 그 변수는 undefined이다.** 만약 **매개 변수보다 인수가 더 많다면 나머지는 무시된다.**

### 12.5.2 인수 확인
자바스크립트는 동적 타입 언어이므로, 개발자의 의도대로 코드를 작동시키기 위해서는 인수를 사전에 확인하는 작업이 필요하다.

* typeof를 통한 type검사
* 인수가 없을 경우 단축평가 사용
* 매개변수 기본값 사용

### 12.5.3 매개변수의 최대 개수
* 매개변수는 사실 함수를 이해하는데 방해되는 요소이다.
* 또한 매개변수의 갯수가 많으면 함수가 그만큼 많은 일을 한다는 것을 의미한다.
* 따라서 매개변수는 0개가 가장 바람직하며, 최대 3개를 넘지 않는 것을 권장한다. 만약 그 이상일 경우 객체로 만들어 인수로 전달할 것을 권장한다.

### 12.5.4 반환문
> 함수는 return 키워드와 표현식으로 이뤄진 반환문을 사용해 실행 결과를 함수 외부로 반환할 수 있다.

* 반환문의 역할 2가지
1. 함수 실행을 중단하고 함수 몸체를 빠져나간다.
2. return 키워드 뒤에 오는 표현식을 반환해 평가한다.

* 반환문은 생략 가능하다. 이때 함수는 함수 몸체 마지막까지 실행 후, 암묵적으로 undefined를 반환한다.

## 12.6 참조에 의한 전달과 외부 상태의 변경
```
// 매개변수 primitive는 원시 값을 전달받고, 매개변수 obj는 객체를 전달받는다.
function changeVal(primitive, obj) {
  primitive += 100;
  obj.name = 'Kim';
}

// 외부 상태
var num = 100;
var person = { name: 'Lee' };

console.log(num); // 100
console.log(person); // {name: "Lee"}

// 원시 값은 값 자체가 복사되어 전달되고 객체는 참조 값이 복사되어 전달된다.
changeVal(num, person);

// 원시 값은 원본이 훼손되지 않는다.
console.log(num); // 100

// 객체는 원본이 훼손된다.
console.log(person); // {name: "Kim"}
```

이처럼 함수가 외부 상태를 변경하면 상태 변화를 추적하기가 어렵다. 이는 코드의 복잡성을 증가시키고 가독성을 해치는 원인이 된다. 상태 변화를 감지하기 위해서는 함수 내부를 유심히 봐야하기 때문이다.

## 12.7 다양한 함수의 형태
### 12.7.1 즉시 실행 함수
> 단 한번만 실행되며, 다시 호출할 수 없다.
```
let test = 12;
(function foo() {
  test = 15;
  var a = 3;
  var b = 5;
  return a * b;
}());

console.log(test); // 15
```
* 대체로 익명 함수를 사용한다.

* 반드시 그룹 연산자()로 감싸야 한다. 함수 리터럴을 평가해서 **함수 객체를 생성해야 하기 때문이다**

* 만약 함수 리터럴을 평가해 함수 객체를 생성할 수 있다면 다른 방법을 사용해도 된다.

```
(function () {
  // ...
})();

!function () {
  // ...
}();

+function () {
  // ...
}();
```
* 즉시 실행 함수도 일반 함수처럼 값을 반환하거나 인수를 전달할 수 있다.
```
let test = (function foo() {
  test = 15;
  var a = 3;
  var b = 5;
  return a * b;
}());

console.log(test); // 15

test = (function foo(a, b) {
  return a * b;
}(5, 3));

```

### 12.7.2 재귀 함수

> 스스로를 호출하는 함수를 재귀 함수라고 한다.

```
function countdown(n) {
  if (n < 0) return; // 탈출 조건
  console.log(n);
  countdown(n - 1); // 재귀 호출
}

countdown(10);

```
* 반복문 없이 반복 처리를 할 수 있다.
* 그러나 무한 반복에 빠져 스택 오버 플로우 에러를 발생시킬 수 있다. => 탈출 조건을 반드시 올바르게 명시해야 한다.
* 재귀함수는 반복문보다 재귀함수가 더 직관적으로 이해할 수 있을 때에만 한정적으로 사용하는 것이 바람직하다. 

### 12.7.3 중첩 함수
> 중첩 함수: 함수 내부에 정의된 함수 

* 보통 외부함수를 돕는 헬퍼 함수의 역할을 한다.

### 12.7.4 콜백 함수
> 콜백 함수: 다른 함수의 매개변수로 전달되는 함수
<br> 고차 함수: 콜백함수를 인자로 받은 함수

* 고차함수는 콜백 함수의 호출 타이밍을 결정할 수 있으며, 필요시 콜백 함수에 인자를 전달해 줄 수 있다. 

* 콜백 함수가 고차 함수 내부에서만 필요하다면 인자로 전달하면서 정의하는게 일반적이다. 하지만 고차 함수가 자주 호출되거나 아니면 콜백 함수를 외부에서도 사용해야 하는 경우 그냥 콜백함수를 외부에 정의해서 사용하는 편이 좋다. 고차 함수가 호출될때마다 콜백 함수 객체가 생성되기 때문이다.
```
function repeat(n, f) {
  for (var i = 0; i < n; i++) {
    f(i); // i를 전달하면서 f를 호출
  }
}

repeat(5, function (i) {
  if (i % 2) console.log(i);
}); // 1 3
```

### 12.7.5 순수함수와 비순수함수
> 순수함수: 외부 상태에 의존하지도 않고 변경하지도 않는, 부수 효과가 없는 함수 (<=> 비순수 함수)

```
function add(a,b) {
	return a + b;
}
```
* 동일 인수가 전달되면 언제나 동일한 값을 반환한다.
* 함수의 외부 상태를 변화시키지 않는다.

위의 `add`함수는 간단한 순수함수이다. 같은 인자가 전달되면 언제나 같은 값을 반환하고, 외부의 상태에 영향을 끼치지 않는다. 

함수가 외부 상태를 변경하면 상태 변화 추적이 매우 어려워진다. 따라서 이를 지양하는 편이 좋다. 

이렇게 순수 함수를 사용해 불변성을 지향하는 프로그래밍 패러다임이 바로 **함수형 프로그래밍**이다. 이는 반복문을 제거해서 복잡성을 해결하고, 변수 사용을 억제하거나 생명주기를 최소화해서 변경 위험성을 피한다.
<br> 즉, **부수효과를 최대한 억제해 오류를 피하고, 프로그램의 안정성을 높이려는 노력의 일환이라 할 수 있다!** 

# 13장 스코프

## 13.1 스코프란 무엇인가?
> 스코프: 식별자가 유효한 범위
* 모든 식별자는 선언된 위치에 따라 다른 코드가 식별자를 참조할 수 있는 위치가 결정된다.

```
let test = 1;

function funcTest() {
	let test = 2;
	console.log(test);
}

funcTest();

console.log(test);
```
위 코드에서 funcTest의 실행 결과로 2가 출력된다. 그러나 맨 마지막 줄의 `console.log` 의 결과로는 1이 출력된다. 자바스크립트 엔진은 `console.log`가 참조하는 `test`가 둘 중 어느 변수를 참조해야할 지 결정해야하는데, 이를 **식별자 결정** 이라고 한다. 이 두 `test`는 식별자 이름은 같지만 스코프가 다른 완전히 별개의 변수이다.

또한 스코프가 같을 때 같은 이름의 식별자는 2개 이상 존재할 수 없다. 즉, 스코프별로 식별자 이름은 하나여야만 한다.(여기서 var의 문제점을 살펴볼 수 있다.)
```
// 이런거 안됨(같은 식별자)
let test = 1;
let test = 2; 
```
## 13.2 스코프의 종류
코드는 크게 **전역**과 **지역**으로 나뉜다.

* 전역: 코드의 가장 바깥 영역
* 지역: 함수 몸체 내부(코드 블록 내부)

전역에서 선언한 변수는 전역 스코프를 가지고, 지역에서 선언한 변수는 지역 스코프를 가진다.
* 전역 변수는 코드 어디서든 참조할 수 있고, 지역 변수는 해당 스코프와 하위 스코프에서 참조할 수 있다.

```
let test = 1;
function funcTest() {
	console.log(test);
	let test2 = 2;
	let test = 3;
	function funcTest2() {
		console.log(test2)
		console.log(test)
	}
	funcTest2();
}
console.log(test2);
```

`funcTest`에서 전역변수 `test`를 참조해 `1`을 출력한다. 이후 `funcTest2`는 `funcTest`의 `test2`와 `test`를 참조해 `2`와 `3`을 출력한다. 코드 맨 마지막에서는 `test2`를 참조해 출력하려 하지만, 전역 스코프에서는 그 하위 스코프에 있는 test2를 참조하지 못한다.

## 13.3 스코프 체인
위의 스코프를 살펴보면 다음과 같다.
* 전역 스코프 : test funcTest
* funcTest 스코프 : test2 test funcTest2

함수는 전역, 함수 몸체 내부에서 정의될 수 있다. 함수가 다른 함수의 몸체에서 정의된 경우 함수의 중첩이라고 하며, 내부에서 정의된 함수를 중첩 함수, 중첩 함수를 포함하는 함수를 외부 함수 라고 한다.

함수가 중첩될 수 있다는 것은 함수가 가진 스코프 또한 중첩될 수 있다는 것이다. 즉, **스코프는 함수에 의해 계층적인 구조를 가진다.**

모든 스코프는 하나의 계층적인 구조로 연결되며, 전역 스코프가 최상위 스코프로 위치한다. 이렇게 스코프가 하나로 연결된 것을 **스코프 체인** 이라고 하며, 변수를 참조할 때 본인의 스코프로 시작해서 상위의 스코프로 이동하며 변수를 검색한다. 

### 13.4 함수 레벨 스코프 
> 함수에 의해서만 지역 스코프가 생성되는 것을 말한다.

```
var test = 1;

if (true) {
	var test = 10;
}

console.log(test); // 10
```
 var 키워드로 선언된 변수는 오직 함수 코드 블록을 스코프로 인정한다. 따라서 if문에서 선언한 변수가 중복선언 되어 재할당 되었다.
 이러한 방식은 의도치 않은 재할당, 가독성 저하 등의 문제점이 많다. 이러한 문제들을 보완하기 위해  ES6에서 새롭게 let, const의 키워드가 도입되었다.

### 13.5 렉시컬 스코프
* 자바스크립트는 **함수를 어디서 호출했는지가 아닌, 어디서 정의했느냐를 기억한다.** 이를 따라서 상위 스코프를 결정하는데, 이를 **렉시컬 스코프**라고 한다.

```
let test = 1;
function func() {
	let test = 2;
	func2()
}

function func2() {
	console.log(test);
}

func();
func2();

```

# 14장 전역변수의 문제점

## 14.1 변수의 생명 주기
### 14.1.1 지역 변수의 생명 주기
* 변수도 생성과 소멸되는 주기가 있다. 주기가 없다면 영원히 메모리 공간을 차지할 것.
* 지역 변수는 함수가 호출되면 생성되고 종료하면 소멸한다.
* 즉, 변수의 생명 주기 = 함수의 생명 주기 이며, 메모리 공간이 확보부터 해제되어 가용 메모리 풀에 반환되는 시점까지 이다. 

### 14.1.2 전역 변수의 생명 주기
* var로 선언한 변수는 전역 객체의 프로퍼티가 된다. 즉, var로 선언한 전역 변수 수명 = 전역 객체의 수명 => 브라우저 환경에서 웹 페이지를 닫기 전까지 유효하다. 

## 14.2 전역 변수의 문제점
### 암묵적 결합
> 모든 코드가 전역 변수를 참조하고 변경할 수 있는 것 => 가독성은 낮아지고, 의도치 않은 상태변경 위험성 높아짐

### 긴 생명주기
> 메모리 리소스를 오랜기간 소비 => 변수 상태 변경 가능성 높아짐

### 스코프 체인의 맨 마지막
> 전역 변수의 검색 속도가 느림

### 네임 스페이스 오염
> 같은 스코프에서 동일한 이름을 가지고 있을 경우 문제가 발생

## 14.3 전역 변수의 사용을 억제하는 방법
> 가장 좋은 방법은 지역변수를 사용하는 것
### 즉시 실행 함수
모든 코드를 즉시 실행 함수로 감싸 모든 변수를 지역 변수로 만드는 방법

### 네임스페이스 객체
> 네임스페이스 역할의 객체를 만들고, 변수를 프로퍼티로 추가하는 방법
```
const nameObj = {} // 네임 스페이스 객체
nameObj.name = 'do'
```

### 모듈 패턴
> 관련있는 변수와 함수를 즉시 실행 함수로 감싸 모듈을 만드는 것.

* 전역 변수 억제 및 캡슐화까지 구현
```
var Counter = (function () {
  // private 변수
  var num = 0;

  // 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환한다.
  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    }
  };
}());

// private 변수는 외부로 노출되지 않는다.
console.log(Counter.num); // undefined

console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
console.log(Counter.decrease()); // 0
```
### ES6 모듈
> ES6모듈을 사용하면 전역 변수를 사용할 수 없다. 
script태그에 `type=module`을 추가하면 로드된 자바스크립트 파일은 모듈로 작동한다. 확장자는 `mjs`를 추천한다.

# 15장 let, const 키워드와 블록 레벨 스코프

## 15.1 var 키워드로 선언한 변수의 문제점
### 변수의 중복 선언 허용
> var로 선언한 변수는 같은 스코프에서 중복 선언이 가능하다. 
### 함수 레벨 스코프
> var로 선언한 변수는 함수레벨 스코프를 가진다. 즉, 코드 블록 내에서 선언했어도 전역 변수가 된다.

### 변수 호이스팅
> var로 선언한 변수는 변수 선언문 이전에 참조할 수 있다.(단, 언제나 undefined이다.)

## 15.2 let 키워드
var의 단점을 보완하기 위해 ES6에서 let과 const 키워드가 도입되었다. 

### 변수 중복 선언 금지
> let 키워드로 선언한 변수의 경우 같은 스코프에서 변수의 중복 선언이 금지된다. 만약 중복해서 선언하면 문법 에러가 발생한다.

### 블록 레벨 스코프
> let 키워드로 선언한 변수는 블록 레벨 스코프를 가진다. 따라서 모든 코드 블록을 지역 스코프로 인정한다.

### 변수 호이스팅
> let 키워드로 선연한 변수는 선언과 초기화가 분리되어 진행된다. 변수 선언문에 도달하면 초기화가 진행된다. 이때, 스코프 최상단에서 선언문에 이르기까지의 구역을 TDZ라고 부른다.

### 전역 객체와 let
> let 키워드로 선언한 변수는 전역 객체의 프로퍼티가 아니다. 렉시컬 환경의 선언적 환경 레코드 내에 존재하게 된다.

## 15.3 const 키워드
const 키워드는 상수를 선언하기 위해 사용한다. 

### 선언과 초기화
> const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.
let 과 마찬가지로 블록레벨 스코프를 가지며, 호이스팅이 발생하지 않는 것처럼 작동한다.

### 재할당 금지
> const 키워드로 선언한 변수는 재할당이 금지된다.

### 상수
> const 키워드로 선언한 변수에 원시값을 할당하면 할당된 값을 변경할 수 없다.

일반적으로 상수 이름은 대문자로 선언한다.

### 객체
> const 키워드로 선언된 변수에 객체가 할당되면 값을 변경할 수 있다. 
객체는 재할당 없이도 직접 변경이 가능하기 떄문이다. 

## 15.4 var vs let vs const
변수 선언엔 기본적으로 const를 선언하고, let은 재할당이 필요한 경우에 한정해서 사용한다.

* ES6의 경우 var는 사용하지 말자
* 재할당이 필요하면 let을 사용하고, 스코프를 최대한 좁게 만든다.
* 읽기 전용의 원시 값과 객체에는 const를 선언한다. 

단, 변수 선언 시점에는 재할당이 필요한가를 잘 모르는 경우가 많다. 따라서 일단 const를 사용한 후, 후에 재할당이 필요하다면 let으로 변경한다.

# 16장 프로퍼티 어트리뷰트

## 16.1 내부 슬롯과 내부 메서드

> 내부 슬롯과 내부 메서드는 JS엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사 메서드다. 

=> ECMAScript 사양에서 이중 대괄호로 감싼 이름들이 이에 해당한다.

* 실제로 엔진에서 동작 하지만 개발자가 직접 접근할 수 있는 프로퍼티는 아님

* 그러나 몇몇 내부 슬롯과 메서드는 간접적 접근이 가능함([[prototype]]에 접근하는 `__proto __` 등)

## 16.2 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

> JS엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.

* 프로퍼티 상태: 프로퍼티 값, 값 갱신 가능 여부, 열거 가능 여부, 재정의 가능 여부

* 프로퍼티 어트리뷰트는 내부 슬롯[[value]], [[Writable]], [[Enumerable]], [[Configurable]] 이다.

* 여기에 직접 접근은 불가능하지만, `Object.getOwnProppertyDescriptor` 메서드로 간접 확인은 가능하다.
=> 첫번째 매개변수에는 객체의 참조, 두번째 매개변수에는 프로퍼티 키를 문자열로 전달한다. 리턴값은 **프로퍼티 디스크립터 객체** 이다. (없는 키 혹은 상속받은 프로퍼티에 대한 프로퍼티 디스크립터를 요구하면 undefined를 반환한다.)
```
const obj = {
    test: 1
}

Object.getOwnPropertyDescriptor(obj, "test");
/*
{
  value: 1,
  writable: true,
  enumerable: true,
  configurable: true
}
 */
```

## 16.3 데이터 프로퍼티와 접근자 프로퍼티

* 프로퍼티의 구분
1. 데이터 프로퍼티: 키와 값으로 구성된 일반적인 프로퍼티
2. 접근자 프로퍼티: 자체적인 값이 없고, 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티

### 16.3.1 데이터 프로퍼티

* JS엔진이 프로퍼티를 생성할 때 기본값으로 자동 정의되는 어트리뷰트

| 프로퍼티 어트리뷰트 | 프로퍼티 디스크립터 객체의 프로퍼티 | 설명 |
| -- | -- | -- |
|[[value]]|value| 키를 통해 값에 접근하면 반환됨. 값을 변경하면 [[Value]]에 값을 재할당. 프로퍼티가 없으면 동적 생성하고 생성된 프로퍼티의 [[Value]]에 값을 저장|
|[[Writable]]|writable|값의 변경 여부를 나타냄(불리언 값). false인 경우 [[Value]]의 값을 변경 불가능한 읽기 전용 프로퍼티가 됨 |
|[[Enumerable]]|enumerable|열겨 가능 여부(불리언 값). false인 경우 `for...in`이나`Object.key`등으로 열거가 불가능해짐|
|[[Configurable]]|configurable|재정의 가능 여부(불리언 값) false인 경우 삭제, 변경이 금지된다. 단, [[Writable]]이 true면 [[Value]]의 변경과 [[Writable]]을 false로 바꾸는것은 허용됨 |

### 16.3.2 접근자 프로퍼티
* 자체적으로 값을 가지는 것이 아니라, 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 이루어진 프로퍼티

| 프로퍼티 어트리뷰트 | 프로퍼티 디스크립터 객체의 프로퍼티 | 설명 |
| -- | -- | -- |
|[[Get]]|value| 접근자 프로퍼티를 통해 값을 읽을 때 호출되는 접근자 함수. 프로퍼티 키로 값에 접근 하면 [[Get]]의 값 getter함수가 호출되고, 결과가 프로퍼티 값으로 반환된다.|
|[[Set]]|writable|접근자 프로퍼티를 통해 값을 저장할 때 호출되는 접근자 함수. 프로퍼티 키로 값을 저장 하면 [[Set]]의 값 Setter함수가 호출되고, 결과가 프로퍼티 값으로 반환된다.|
|[[Enumerable]]|enumerable|데이터 프로퍼티하고 똑같아욥|
|[[Configurable]]|configurable|데이터 프로퍼티하고 똑같아욥 |

### 16.3.3 Get 메서드 동작 방식
1. 프로퍼티 키가 유효한지 확인(심볼 or 문자열). 
2. 프로토타입 체인에서 프로퍼티 검색
3. 검색된 프로퍼티가 데이터 프로퍼티인지 접근자 프로퍼티인지 확인한다.
4. 접근자 프로퍼티라면 getter or setter 함수를 호출 해 결과를 반환한다.

## 16.4 프로퍼티 정의
> 새로운 프로퍼티를 정의하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거ㅏㄴ, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것

Object.defineProperty를 통해 프로퍼티의 어트리뷰트를 정의할 수 있다.

```
const person = {};

Object.defineProperty(person, 'firstName', {
	value: '성',
	writable: true,
	enumerable: true,
	configurable: true
})

```

| 프로퍼티 어트리뷰트 | 프로퍼티 디스크립터 객체의 프로퍼티 | 생략 시 기본값 |
| -- | -- | -- |
|[[Value]]|value| undefined|
|[[Get]]|writable|undefined|
|[[Set]]|enumerable|undefined|
|[[Writable]]|configurable|false |
|[[Enumerable]]|enumerable|false|
|[[Configurable]]|configurable|false |

Object.defineProperties를 이용하면 여러개의 프로퍼티를 한번에 정의할 수 있다.

```
const person = {};

Object.defineProperties(person, {
  // 데이터 프로퍼티 정의
  firstName: {
    value: 'Ungmo',
    writable: true,
    enumerable: true,
    configurable: true
  },
  lastName: {
    value: 'Lee',
    writable: true,
    enumerable: true,
    configurable: true
  },
  // 접근자 프로퍼티 정의
  fullName: {
    // getter 함수
    get() {
      return `${this.firstName} ${this.lastName}`;
    },
    // setter 함수
    set(name) {
      [this.firstName, this.lastName] = name.split(' ');
    },
    enumerable: true,
    configurable: true
  }
});
```

## 16.5 객체 변경 방지
객체는 재할당 없이 직접 변경할 수 있다. 자바스크립트는 이러한 변경을 방지하는 다양한 메서드를 제공한다.
[프로퍼티 추가, 프로퍼티 삭제, 프로퍼티 값 읽기, 프로퍼티 값 쓰기, 프로퍼티 어트리뷰트 재정의]
* Object.preventExtensions - 객체 확장 금지: 프로퍼티 추가 x
* Object.seal - 객체 밀봉: 프로퍼티 추가, 삭제, 재정의 x
* Object.freeze - 객체 동결: 프로퍼티 값 읽기만 가능

### 16.5.1 Object.preventExtensions
> 확장 금지 = 프로퍼티 추가 금지

확장 가능 여부는 Object.isExtensible 메서드로 확인 가능

### 16.5.2 Object.seal
> 밀봉 = 읽기와 쓰기만 가능

밀봉 여부는 Object.isSealed 메서드로 확인 가능

### 16.5.3 Object.freeze
> 동결 = 읽기만 가능

동결 여부는 Object.isFrozen 메서드로 확인 가능

### 16.5.4 불변 객체
위의 방식들은 얕은 변경 방지이기 때문에 중첩 객체에 대해서는 적용이 되지 않는다. 중첩 객체도 변경이 불가능하도록 만드려면 재귀적으로 Object.freeze 메서드를 호출해야 한다.

```
function deepFreeze(target) {
  // 객체가 아니거나 동결된 객체는 무시하고 객체이고 동결되지 않은 객체만 동결한다.
  if (target && typeof target === 'object' && !Object.isFrozen(target)) {
    Object.freeze(target);
    /*
      모든 프로퍼티를 순회하며 재귀적으로 동결한다.
      Object.keys 메서드는 객체 자신의 열거 가능한 프로퍼티 키를 배열로 반환한다.
      ("19.15.2. Object.keys/values/entries 메서드" 참고)
      forEach 메서드는 배열을 순회하며 배열의 각 요소에 대하여 콜백 함수를 실행한다.
      ("27.9.2. Array.prototype.forEach" 참고)
    */
    Object.keys(target).forEach(key => deepFreeze(target[key]));
  }
  return target;
}

const person = {
  name: 'Lee',
  address: { city: 'Seoul' }
};

// 깊은 객체 동결
deepFreeze(person);

console.log(Object.isFrozen(person)); // true
// 중첩 객체까지 동결한다.
console.log(Object.isFrozen(person.address)); // true

person.address.city = 'Busan';
console.log(person); // {name: "Lee", address: {city: "Seoul"}}
```

# 17장 생성자 함수에 의한 객체 생성
## 17.1 Object 생성자 함수
> new 키워드와 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다. 이후 프로퍼티, 메서드를 추가하여 객체를 완성할 수 있다.

```
// 빈 객체의 생성
const person = new Object();

// 프로퍼티 추가
person.name = 'Lee';
person.sayHello = function () {
  console.log('Hi! My name is ' + this.name);
};

console.log(person); // {name: "Lee", sayHello: ƒ}
person.sayHello(); // Hi! My name is Lee
```

* **생성자 함수**란 new 연산자와 함께 호출해 객체를 생성하는 함수를 말한다. 이 방법으로 만들어진 객체를 인스턴스라고 한다.

객체 리터럴을 사용하는 방식이 더 간단하기는 한데...?

## 17.2 생성자 함수
### 17.2.1 객체 리터럴에 의한 객체 생성 방식의 문제점
동일한 프로퍼티를 갖는 객체를 여러개 생성해야 할 경우 매번 같은 프로퍼티를 기술해야 하기 떄문에 비효율적이다.
```
const circle1 = {
  radius: 5,
  getDiameter() {
    return 2 * this.radius;
  }
};

console.log(circle1.getDiameter()); // 10

const circle2 = {
  radius: 10,
  getDiameter() {
    return 2 * this.radius;
  }
};

console.log(circle2.getDiameter()); // 20
```

### 17.2.2 생성자 함수 방식에 의한 객체 생성의 장점
프로퍼티 구조가 비슷한 여러개의 객체를 간편하게 생성할 수 있다.
```
function Circle(radius) {
  // 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}

// 인스턴스의 생성
const circle1 = new Circle(5);  // 반지름이 5인 Circle 객체를 생성
const circle2 = new Circle(10); // 반지름이 10인 Circle 객체를 생성

console.log(circle1.getDiameter()); // 10
console.log(circle2.getDiameter()); // 20
```

만약 new 연산자를 동반하지 않으면 일반 함수로 작동한다. 
```
const circle3 = Circle(15);
console.log(circle3); // undefined
```

## 17.2.3 생성자 함수의 인스턴스 생성 과정

* 생성자 함수의 역할: 템플릿으로 작동해서 인스터스를 생성(필수). 생성된 인스턴스를 초기화(옵션)

#### 1. 인스턴스 생성과 this 바인딩
암묵적으로 빈 객체가 생성된다. 인스턴스는 this에 바인딩된다. 이 처리는 런타임 이전에 실행된다.

#### 2. 인스턴스 초기화
코드가 한줄씩 실행되어 this에 바인딩 된 인스턴스를 초기화한다. 즉, tihs에 바인딩 된 인스턴스에 프로퍼티, 메서드를 추가하고, 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값을 할당한다.

#### 3. 인스턴스 반환
내부의 처리가 모두 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다. 만약 다른 객체를 명시적으로 리턴한다면 그 객체가 반환된다.

### 17.2.4 내부 메서드 [[Call]]과 [[Construct]]

함수는 객체이므로 일반 객체와 동일하게 동작할 수 있다. 허나 일반 객체와는 다르다. 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다. 따라서 일반 객체가 가진 내부 슬롯, 내부 메서드에 더불어 함수 객체만을 위한 내부 슬롯과 메서드를 추가로 가지고 있다. 함수가 호출되면 내부 메서드 [[Call]]이 호출되고, new 연산자와 함께 생성자 함수로 호출되면 [[Construct]]가 호출된다.

[[Call]]을 가지는 함수 객체를 callable, [[Construct]]를 가지는 함수 객체를 constructor, 그렇지 않은 함수 객체를 non-constructor 라고 부른다. 함수 객체는 반드시 callable이어야 한다. 하지만 반드시 constructor일 필요는 없다.

### 17.2.5 constructor 와 non-constructor의 구분
* constructor: 함수 선언문, 함수 표현식, 클래스
* non-constructor: 메서드, 화살표 함수

그러나 ECMAScript에서는 메서드는 ES6의 메서드 축약 표현만을 의미한다. 즉, 함수 선언문과 함수 표현식으로 정의된 함수만 constructor이고, ES6의 화살표 함수와 축약 표현으로 정의된 함수는 non-constructor이다.

### 17.2.6 new 연산자
사실 생성자 함수와 일반 함수에 특별한 형식적 차이는 없다. 단, new 연산자와 함께 사용하면 [[Call]]이 아니라 [[Constructor]]가 호출된다. 말했듯 형식적 차이가 없으므로 파스칼 케이스를 사용해서 일반 함수와 표기를 구분하는 것이 좋다.

### 17.2.7 new.target
new 없이 생성자 함수를 사용하는 것을 막기 위해 ES6에서 new.target을 도입했다. 메타 프로퍼티라고 불리며 함수 내부에서 사용 시 생성자 함수로 사용되었는지 호출할 수 있다. 
* new와 함께 호출 시: new.target은 함수 자신
* new 없이 호출: new.target은 undefined

Object와 Function 생성자 함수는 new 없이 호출해도 동일하게 작동한다. 하지만 String, Number, Boolean은 타입을 변환한다.

# 18장 함수와 일급 객체
## 18.1 일급 객체
다음의 조건을 만족하면 일급 객체라고 한다.
> * 무명의 리터럴로 생성 가능
* 변수나 자료구조에 저장 가능
* 함수의 매개변수에 전달가능
* 함수의 반환값으로 사용 가능

함수가 일급객체라는 뜻은 객체와 동일하게 사용할 수 있다는 의미이다. 따라서 함수는 값을 사용하는 곳이라면 어디서든지 리터럴로 정의할 수 있으며, 런타임에 함수 객체로 평가된다. **함수가 일급 객체로 가지는 가장 큰 특징은 매개변수에 전달할 수 있으며 함수의 반환값으로 사용이 가능하다는 것이다.** 
그러나 일반 객체는 호출이 불가능하지만 함수 객체는 호출이 가능하다는 점, 함수 객체는 고유의 프로퍼티를 소유한다는 점(프로퍼티 어트리뷰트 참고)의 차이점이 있다.

## 18.2 함수 객체의 프로퍼티
### 18.2.1 arguments 프로퍼티
> 함수 객체의 arguments프로퍼티의 값은 arguments 객체이다. 

* arguments 객체는 전달받은 인수를 담고 있는 순회 가능한 유사 배열 객체이며, 함수 내부에서 지역 변수에서 사용된다.
* ES3에서 arguments 프로퍼티는 폐지되었다. 
* 자바스크립트는 함수의 매개변수와 인수의 개수가 일치하는지 확인하지 않는다. 따라서 함수 호출 시 개수만큼 인수를 전달하지 않아도 오류가 나지 않는다.
* 초과된 인수는 무시되는데, 그냥 버려지는 것은 아니다. 암묵적으로 arguments 객체의 프로퍼티로 보관된다.
* arguments 객체는 인수를 프로퍼티 값으로 소유하며, 프로퍼티 키는 인수의 순서이다. calle 프로퍼티는 함수 자신이고, length프로퍼티는 인수의 개수이다.
* 함수 호출 시 인수 개수를 확인하고 동작을 달리할 수 있는데, 이때 유용하게 사용하는 것이 arguments 객체이다. 가변 인자 함수를 구현할 때 유용하다.
```
function sum() {
  let res = 0;

  // arguments 객체는 length 프로퍼티가 있는 유사 배열 객체이므로 for 문으로 순회할 수 있다.
  for (let i = 0; i < arguments.length; i++) {
    res += arguments[i];
  }

  return res;
}

console.log(sum());        // 0
console.log(sum(1, 2));    // 3
console.log(sum(1, 2, 3)); // 6
```
* arguments 객체는 유사배열객체이다. 따라서 배열로 변환하고 배열메서드를 사용해야하는 번거로움이 있는데, 이를 해결하기 위해 ES6에서 Rest 파라미터를 도입했다.

```
function sum(...args) {
  return args.reduce((pre, cur) => pre + cur, 0);
}

console.log(sum(1, 2));          // 3
console.log(sum(1, 2, 3, 4, 5)); // 15
```
### 18.2.2 caller 프로퍼티
> ECMAScript에 포함되지 않은 비표준 프로퍼티이다. caller 프로퍼티는 함수 자신을 호출한 함수를 가리킨다.

### 18.2.3 length 프로퍼티
> 함수를 정의할 때 선언한 매개변수의 개수를 가리킨다.

단, arguments 객체의 length 프로퍼티(인자의 개수)와 함수 객체의 length 프로퍼티의 값이 다를 수 있으므로 주의한다.

### 18.2.4 name 프로퍼티
> 함수의 이름을 나타낸다.

단, ES5에서는 익명 함수 표현식의 경우 빈 문자열을, ES6에서는 함수 객체를 가리키는 식별자를 값으로 가진다.
```
// 기명 함수 표현식
var namedFunc = function foo() {};
console.log(namedFunc.name); // foo

// 익명 함수 표현식
var anonymousFunc = function() {};
// ES5: name 프로퍼티는 빈 문자열을 값으로 갖는다.
// ES6: name 프로퍼티는 함수 객체를 가리키는 변수 이름을 값으로 갖는다.
console.log(anonymousFunc.name); // anonymousFunc

// 함수 선언문(Function declaration)
function bar() {}
console.log(bar.name); // bar
```

### 18.2.5 `__proto__` 접근자 프로퍼티
> 모든 객체는 [[Prototype]]이라는 내부 슬롯을 가진다. 이는 프로토 타입 객체를 가리킨다. `__proto__` 프로퍼티는 [[Prototype]]내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위한 접근자 프로퍼티이다.

```
const obj = { a: 1 };

// 객체 리터럴 방식으로 생성한 객체의 프로토타입 객체는 Object.prototype이다.
console.log(obj.__proto__ === Object.prototype); // true

// 객체 리터럴 방식으로 생성한 객체는 프로토타입 객체인 Object.prototype의 프로퍼티를 상속받는다.
// hasOwnProperty 메서드는 Object.prototype의 메서드다.
console.log(obj.hasOwnProperty('a'));         // true
console.log(obj.hasOwnProperty('__proto__')); // false
```
### 18.2.6 prototype 프로퍼티
> 생성자 함수로 호출할 수 있는 함수 객체, 즉, constructor만이 소유하는 프로퍼티이다. 

```
// 함수 객체는 prototype 프로퍼티를 소유한다.
(function () {}).hasOwnProperty('prototype'); // -> true

// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.
({}).hasOwnProperty('prototype'); // -> false
```

함수가 객체를 생성하는 생성자 함수로 호출될 때 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다. 

# 19장 프로토타입
> **자바스크립트는 멀티 패러다임(명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍) 프로그래밍 언어이다.**

자바스크립트는 객체 기반 프로그래밍 언어이며 **자바스크립트를 이루고 있는 거의 "모든 것'이 객체이다.** 원시 값을 제외한 나머지 값들은 모두 객체이다.

## 19.1 객체지향 프로그래밍
> 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임

* 객체지향 프로그래밍에서 실체는 특성이나 성질을 나타내는 속성을 지니고 있고, 이를 통해 실체를 인식하거나 구분할 수 있다. (사람 - 나이, 이름, 주소, 성별 등)
```
const person = {
  name: 'Lee',
  address: 'Seoul'
};

console.log(person); // {name: "Lee", address: "Seoul"}
```
* 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복잡한 자료구조를 객체라고 하며, 객체지향 프로그래밍은 독립적인 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임이다. 

* 객체지향 프로그래밍에서는 객체의 상태를 나타내는 데이터와 상태 데이터를 조작할 수 있는 동작을 하나의 논리적인 단위로 묶어 생각한다. 이때 이 상태를 프로퍼티, 동작을 메서드라고 부른다.

```
const circle = {
  radius: 5, // 반지름

  // 원의 지름: 2r
  getDiameter() {
    return 2 * this.radius;
  },

  // 원의 둘레: 2πr
  getPerimeter() {
    return 2 * Math.PI * this.radius;
  },

  // 원의 넓이: πrr
  getArea() {
    return Math.PI * this.radius ** 2;
  }
};

console.log(circle);
// {radius: 5, getDiameter: ƒ, getPerimeter: ƒ, getArea: ƒ}

console.log(circle.getDiameter());  // 10
console.log(circle.getPerimeter()); // 31.41592653589793
console.log(circle.getArea());      // 78.53981633974483
```
## 19.2 상속과 프로토타입

> 상속: 어떤 객체의 프로퍼티, 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것

자바스크립트는 프로토타입을 기반으로 상속을 구현해 불필요한 중복을 제거한다(코드의 재사용).

```
// 생성자 함수
function Circle(radius) {
  this.radius = radius;
}

// Circle 생성자 함수가 생성한 모든 인스턴스가 getArea 메서드를
// 공유해서 사용할 수 있도록 프로토타입에 추가한다.
// 프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩되어 있다.
Circle.prototype.getArea = function () {
  return Math.PI * this.radius ** 2;
};

// 인스턴스 생성
const circle1 = new Circle(1);
const circle2 = new Circle(2);

// Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체의 역할을 하는
// 프로토타입 Circle.prototype으로부터 getArea 메서드를 상속받는다.
// 즉, Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메서드를 공유한다.
console.log(circle1.getArea === circle2.getArea); // true

console.log(circle1.getArea()); // 3.141592653589793
console.log(circle2.getArea()); // 12.566370614359172

```

아래의 생성자함수는 인스턴스가 생성될때마다 getArea 메서드가 중복 생성된다는 문제가 있다
```
function Circle(radius) {
  this.radius = radius;
  this.getArea = function () {
    // Math.PI는 원주율을 나타내는 상수다.
    return Math.PI * this.radius ** 2;
  };
}
```

## 19.3 프로토타입 객체
프로토타입 객체(이하 프로토타입)은 객체 간 상속을 구현하기 위해 사용된다. 프로토타입은 어떤 객체의 부모역할을 하는 개체로써 다른 객체에 공유 프로퍼티를 제공한다.

모든 객체는 [[Prototype]]이라는 내부 슬롯을 가지며, 이 내부 슬롯의 값은 프로토타입의 참조이다. 여기에 저장되는 값은 객체 생성 방식에 의해 결정된다. 즉, 객체 생성 방식에 따라 프로토타입이 결정되고 [[Prototype]]에 저장되는 것이다. **모든 객체는 하나의 프로토타입을 가진다.** 그리고 모든 프로토타입은 생성자 함수와 연결되어 있다. 

* [[Prototype]]내부 슬롯은 직접 접근이 불가능하고, `__proto__` 접근자 프로퍼티를 통해 [[Prototype]]내부 슬롯이 참조하는 프로토타입에 간접 접근할 수 있다. 그리고 프로토타입은 constructor 프로퍼티를 통해 생성자 함수에 접근할 수 있고, 생성자 함수는 자신의 prototype 프로퍼티를 통해 프로토타입에 접근할 수 있다.

### 19.3.1 `__proto__`접근자 프로퍼티

> 모든 객체는 `__proto__`접근자 프로퍼티를 통해 자신의 프로토타입, [[Prototype]] 내부 슬롯에 간접 접근할 수 있다.

> `__proto__`는 접근자 프로퍼티다.

내부 슬롯은 프로퍼티가 아니기 때문에, 직접적으로 접근할 방법이 제공되지 않는다. 다만, 일부에 한하여 간접 접근할 방법을 제공한다. [[Prototype]]에 간접 접근할 방법이 `__proto__`인 것이다. 

`__proto__`는 getter/setter 함수라고 부르는 접근자 함수를 통해 프로토타입을 취득하거나 할당한다. 

> `__proto__` 접근자 프로퍼티는 상속을 통해 사용된다.

`__proto__` 접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 Object.prototype의 프로퍼티이다. 모든 객체는 상속을 통해 `Object.prototype.__proto__` 접근자 프로퍼티를 사용할 수 있다.

```
const person = { name: 'Lee' };

// person 객체는 __proto__ 프로퍼티를 소유하지 않는다.
console.log(person.hasOwnProperty('__proto__')); // false

// __proto__ 프로퍼티는 모든 객체의 프로토타입 객체인 Object.prototype의 접근자 프로퍼티다.
console.log(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__'));
// {get: ƒ, set: ƒ, enumerable: false, configurable: true}

// 모든 객체는 Object.prototype의 접근자 프로퍼티 __proto__를 상속받아 사용할 수 있다.
console.log({}.__proto__ === Object.prototype); // true
```

>`__proto__`접근자 프로퍼티를 통해 프로토타입에 접근하는 이유

**상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해서다.** 
```
const parent = {};
const child = {};

// child의 프로토타입을 parent로 설정
child.__proto__ = parent;
// parent의 프로토타입을 child로 설정
parent.__proto__ = child; // TypeError: Cyclic __proto__ value
```

위의 경우 parent가 child의 프로토타입이 되고, child가 parent의 프로토타입이 되는, 서로가 서로의 프로토타입이 되는 비정상적인 상황이 되기 때문에 에러를 발생시킨다.<br/>
프로토타입 체인은 단방향 링크드 리스트로 구현되어야 한다. 즉, 프로퍼티 검생이 한쪽 방향으로만 흘러가야 하는 것이다. 따라서 아무런 체크 없이 무조건적으로 프로토타입을 교체할 수 없도록 접근자 프로퍼티를 통해 프로토타입에 접근하고 교체하도록 구현되어있다.

>`__proto__` 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 권장하지 않는다.

모든 객체가 `__proto__`접근자 프로퍼티를 사용할 수 있는 것은 아니기 때문이다.
```
// obj는 프로토타입 체인의 종점이다. 따라서 Object.__proto__를 상속받을 수 없다.
const obj = Object.create(null);

// obj는 Object.__proto__를 상속받을 수 없다.
console.log(obj.__proto__); // undefined

// 따라서 __proto__보다 Object.getPrototypeOf 메서드를 사용하는 편이 좋다.
console.log(Object.getPrototypeOf(obj)); // null
```
`__proto__`접근자 프로퍼티 대신 프로토타입의 참조를 취득하고 싶은 경우, Object.getPrototypeof 메서드를 사용하고, 프로토타입을 교차하고 싶으면 Object.setPrototypeof 메서드를 사용하는 것을 권장한다.

### 19.3.2 함수 객체의 prototype 프로퍼티
> 함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다. 

```
// 함수 객체는 prototype 프로퍼티를 소유한다.
(function () {}).hasOwnProperty('prototype'); // -> true

// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.
({}).hasOwnProperty('prototype'); // -> false
```

따라서 생성자 함수로 호출할 수 없는 함수(화살표 함수, ES6의 메서드 축약 표현으로 정의한 메서드)는 prototype 프로퍼티를 쇼유하지 않으며 프로토타입도 생성하지 않는다.

모든 객체가 가지고 있는 `__proto__` 접근자 프로퍼티와 햄수 객체만 가지는 prototype프로퍼티는 결국 동일한 프로토타입을 가리킨다.

|구분|소유|값|사용 주체|사용 목적|
|--|--|--|--|--|
|`__proto__`|모든 객체|프로토타입의 참조|모든 객체|객체가 자신의 프로토타입에 접근, 혹은 교체|
|prototype|constructor|프로토타입의 참조|생성자 함수|생성자 함수가 자신이 생성할 객체의 프로토타입을 할당하기 위해 사용|

```
function Person(name) {
  this.name = name;
}

const me = new Person('Lee');

// 결국 Person.prototype과 me.__proto__는 결국 동일한 프로토타입을 가리킨다.
console.log(Person.prototype === me.__proto__);  // true
```

### 19.3.3 프로토타입의 constructor 프로퍼티와 생성자 함수
> 모든 프로토타입은 constructor 프로퍼티를 가지고, constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다. 

```
// 생성자 함수
function Person(name) {
  this.name = name;
}

const me = new Person('Lee');

// me 객체의 생성자 함수는 Person이다.
console.log(me.constructor === Person);  // true
```

Person 생성자 함수는 me 객체를 생성했다. 이때 me 객체는 constructor 프로퍼티를 통해 생성자 함수와 연결된다. me 객체에는 constructor 프로퍼티가 없지만 me 객체의 프로토타입인 Person.prototype에는 constructor 프로퍼티가 있다. 따라서 me 객체는 Person.prototype의 constructor 프로퍼티를 상속받아 사용할 수 있다.

## 19.4 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

리터럴 표기법으로 생성한 객체도 프로토타입이 존재한다. 하지만 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수라고 단정할 수 없다.

```
// obj 객체는 Object 생성자 함수로 생성한 객체가 아니라 객체 리터럴로 생성했다.
const obj = {};

// 하지만 obj 객체의 생성자 함수는 Object 생성자 함수다.
console.log(obj.constructor === Object); // true
```
Object 생성자 함수에 인수가 없거나 udnefined, null을 인수로 전달하면 추상 연산 OrdinaryObjectCreate를 호출하여 Object.prototype을 프로토타입으로 가지는 빈 객체를 생성한다. 
객체 리터럴의 평가 시에는 OrdinaryObjectCreate를 호출하여 빈 객체를 생성하고 프로퍼티를 추가되도록 정의되어 있다. 

이처럼 Object 생성자 함수 호출과 객체 리터럴의 ㅍ평가는 추상 연산 OrdinaryObjectCreate를 호출하여 빈 객체를 생성한다는 점에서는 동일하나, 세부 내용은 다르다. 따라서 객체 리터럴에 의해 생성된 객체는 Object 생성자 함수가 생성한 객체가 아니다. 

> 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 쌍으로 존재한다. 

리터럴 표기법에 의해 생성된 객체는 큰 틀에서 보았을 때 생성자 함수로 생성한 객체와 본질적으로 큰 차이가 없다. 따라서 프로토타입의 constructor 프로퍼티를 통해 연결되어 있는 생성자 함수를 리터럴 표기법으로 생성한 객체를 생성한 생성자 함수로 생각해도 큰 무리는 없다.

## 19.5 프로토타입의 생성 시점

> 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.

생성자 함수는 사용자 정의 생성자 함수와 빌트인 생성자 함수로 구분할 수 있다.

### 19.5.1 사용자 정의 생성자 함수와 프로토타입 생성 시점

> 생성자 함수로서 호출할 수 있는 함수, 즉 constructor는 ㅎ마수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.

```
// 함수 정의(constructor)가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.
console.log(Person.prototype); // {constructor: ƒ}

// 생성자 함수
function Person(name) {
  this.name = name;
}
```

함수 선언문은 런타임 이전 JS엔진에 의해 먼저 실행된다. 따라서 함수 선언문으로 정의돈 Person 생성자 함수는 어떤 코드보다 먼저 평가되어 함수 객체가 된다. 이때 프로토타입도 더불어 생성된다. 이 프로토타입은 Person 생성자 함수의 prototype 프로퍼티에 바인딩된다. 이 프로토타입은 오직 constructor 프로퍼티만을 가지는 객체다. 프로토타입도 객체고 모든 객체는 프로터타입을 가지므로 프로토타입도 자신의 프로토타입을 가진다. 생성된 프로토타입의 프로토타입은 Object.prototype이다. 

> 사용자 정의 함수는 평가 시점에 프로토타입도 생성되며, 이 프로토타입의 프로토타입은 언제나 Object.prototype이다.

### 19.5.2 빌트인 생성자 함수와 프로토타입 생성 시점
> 빌트인 생성자 함수도 생성자 함수가 생성되는 시점에 프로토타입도 생성된다. 모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성된다. 생성된 프로토타입은 빌트인 생성자 함수의 prototype 생성자 함수에 바인딩된다.

### 결론
> 객체 생성 이전에 생성자 함수와 프로토타입은 이미 객체화되어 존재한다. 이후 생성자 함수 또는 리터럴 표기법으로 객체를 생성하면 프로토타입은 생성된 객체의 [[Prototype]]내부 슬롯에 할당된다. 이로써 생성된 객체는 프로토타입을 상속받는다.

## 19.6 객체 생성 방식과 프로토타입의 결정
모든 객체는 생성 방식에 차이가 있어도 OrdinaryObjectCreate에 의해 생성되는 공통점이 있다.OrdinaryObjectCreate는 생성할 객체의 프로토타입을 인수로 전달받는다. 이후 빈 객체를 생성하고, 프로퍼티 목록이 인수로 전달되면 이를 객체에 추가한다. 그리고 인수로 전달받은 프로토타입을 자신이 생성할 객체의 [[Prototype]] 내부 슬롯에 할당하고, 생성한 객체를 반환한다. 즉, 프로토타입은 OrdinaryObjectCreate에 전달되는 인수에 의해 결정된다. 이 인수는 객체가 생성되는 시점에 객체 생성 방식에 의해 결정된다.

### 19.6.1 객체 리터럴에 의해 생성된 객체의 프로토타입

JS엔진은 객체 리터럴을 평가해 객체를 만들 때 OrdinaryObjectCreate를 호출한다. 이때 인수는 Object.prototype을 받는다. 즉, 객체 리터럴에 의해 생성되는 객체의 프로토타입은 Object.prototype이다.
따라서 객체 리터럴에 의해 생성된 객체는 Object.prototype을 상속받는다.

```
const obj = { x: 1 };

// 객체 리터럴에 의해 생성된 obj 객체는 Object.prototype을 상속받는다.
console.log(obj.constructor === Object); // true
console.log(obj.hasOwnProperty('x'));    // true
```

### 19.6.2 생성자 함수에 의해 생성된 객체의 프로토타입

Object 생성자 함수를 호출하면 추상 연산 OrdinaryObjectCreate를 호출한다. 이때 인수는 Object.prototype을 받는다.
```
const obj = new Object();
obj.x = 1;
```
위의 코드가 실행되면 Object 생성자 함수와 Object.prototype과 생성된 객체 사이에 연결이 만들어진다. 이는 객체 리터럴에 의해 생성된 객체와 동일한 구조이다.
즉, 생성자 함수에 의해 생성된 객체 또한 Object.prototype을 프로토타입으로 가지게 되며, 이로써 Object.prototype을 상속받는다.

### 19.6.3 생성자 함수에 의해 생성된 객체의 프로토타입
마찬가지로 OrdinaryObjectCreate를 호출한다.ㅏ 단, 인수는 생성자 함수의 prototype프로퍼티에 바인딩 되어있는 객체이다. 
```
function Person(name) {
  this.name = name;
}

const me = new Person('Lee');
```
Person과 더불어 생성된 Person.prototype의 프로퍼티는 constructor뿐이다. 따라서 다음과 같이 프로토타입에 프로퍼티를 추가/삭제하는 것이 가능하다.

```
function Person(name) {
  this.name = name;
}

// 프로토타입 메서드
Person.prototype.sayHello = function () {
  console.log(`Hi! My name is ${this.name}`);
};

const me = new Person('Lee');
const you = new Person('Kim');

me.sayHello();  // Hi! My name is Lee
you.sayHello(); // Hi! My name is Kim
```

## 19.7 프로토타입 체인
```
function Person(name) {
  this.name = name;
}

// 프로토타입 메서드
Person.prototype.sayHello = function () {
  console.log(`Hi! My name is ${this.name}`);
};

const me = new Person('Lee');

// hasOwnProperty는 Object.prototype의 메서드다.
console.log(me.hasOwnProperty('name')); // true
```

여기서 me객체의 프로토타입은 Person.prototype이다. 또한 프로토타입의 프로토타입은 언제나 Object.prototype이다.

```
Object.getPrototypeOf(Person.prototype) === Object.prototype; // -> true
```

> **자바스크립트는 객체의 프로퍼티에 접근하려고 할때, 찾는 프로퍼티가 해당 객체에 없으면 [[Prototype]]슬롯의 참조를 따라서 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색하며, 이를 프로토타입 체인이라고 한다.**

자바스크립트 엔진이 프로퍼티(와 메서드)를 검색하는 방법은 다음과 같다.

1. 먼저 프로퍼티(이하 메서드 포함)를 호출한 객체에서 해당 프로퍼티를 검색한다. 존재하지 않을 경우, 해당 객체의 [[Prototype]] 슬롯이 참조하는 프로토타입(A)으로 이동해 해당 프로퍼티를 검색한다.

2. A에도 해당 프로퍼티가 없을 경우 다시 A의 내부 슬롯 [[Prototype]]으로 이동하여 검색한다.

3. 해당 프로퍼티를 찾으면 자바스크립트 엔진은 이 프로퍼티를 호출한다. 만약 this 가 있다면 맨 처음의 객체가 바인딩된다.

+ 프로토타입 체인의 제일 최상위 객체는 언제나 Object.prototype이다. 이는 곧 모든 객체는 Object.prototype을 상속받는다고 할 수 있다. 따라서 Object.prototype을 프로토타입 체인의 종점 이라고 한다.(Object.prototype의 [[Prototype]]의 값은 `null`이다.). ** 만약 Object.prototype에서도 프로퍼티를 찾을 수 없는 경우 에러없이 `unedefined`를 반환한다는 점에 주의하자**

* 프로토타입 체인이 **상속과 프로퍼티 검색을 위한 메커니즘**인 반면, 스코프 체인은 **식별자 검색**을 위한 메커니즘 이다. 이 둘은 서로 협력하여, 식별자와 프로퍼티를 검색하는데에 사용된다.

## 19.8 오버라이딩과 프로퍼티 섀도잉
```
const Person = (function () {
  // 생성자 함수
  function Person(name) {
    this.name = name;
  }

  // 프로토타입 메서드
  Person.prototype.sayHello = function () {
    console.log(`Hi! My name is ${this.name}`);
  };

  // 생성자 함수를 반환
  return Person;
}());

const me = new Person('Lee');

// 인스턴스 메서드
me.sayHello = function () {
  console.log(`Hey! My name is ${this.name}`);
};

// 인스턴스 메서드가 호출된다. 프로토타입 메서드는 인스턴스 메서드에 의해 가려진다.
me.sayHello(); // Hey! My name is Lee
```
프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가하면 인스턴스 프로퍼티로 추가한다. 이떄, 인스턴트 메서드는 프로토타입 메서드를 오버라이딩하고, 프로토타입 메서드는 가려진다. 이처럼 상속관계에 의해 프로퍼티가 가려지는 것을 **프로퍼티 섀도잉**이라고 한다.

* 오버라이딩: 상위 클래스의 메서드를 하위 클래스가 재정의하여 사용하는 방식
* 오버로딩: 함수의 이름은 같지만 매개변수의 타입 또는 개수가 다른 메서드를 구현하고 매개변수에 의해 메서드를 구별하여 호출하는 방식이다. 자바스크립트는 이를 지원하지 않지만, arguments 객체를 사용해 구현할 수 있다.

프로퍼티를 삭제하는 경우에는 프로토타입 프로퍼티를 덮은 인스턴스 프로퍼티가 삭제된다.

```
// 인스턴스 메서드를 삭제한다.
delete me.sayHello;
// 인스턴스에는 sayHello 메서드가 없으므로 프로토타입 메서드가 호출된다.
me.sayHello(); // Hi! My name is Lee
```
하지만 프로토타입 메서드의 삭제는 하위 객체를 통해 삭제하는 것이 불가능하다. 다시말해 하위 객체를 통한 get 액세스는 허용되나 set액세스는 허용되지 않는다. **프로토타입 프로퍼티를 변경/삭제 하려면 프로토타입에 직접 접근해야한다.**

## 19.9 프로토타입 교체
프로토 타입은 다른 객체로 교체할 수 있고, 이는 곧 객체 간의 상속 관계를 동적으로 변경할 수 있다는 말이다. 프로토타입은 생성자 함수 또는 인스턴스에 의해 교체할 수 있다.

### 19.9.1 생성자 함수에 의한 프로토타입 교체
```
const Person = (function () {
  function Person(name) {
    this.name = name;
  }

  // ① 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체
  Person.prototype = {
    sayHello() {
      console.log(`Hi! My name is ${this.name}`);
    }
  };

  return Person;
}());

const me = new Person('Lee');
```

이 방법을 사용하면, constructor 프로퍼티와 생성자 함수 간 연결이 파괴된다. 교체된 객체 리터럴에 constructor 프로퍼티를 추가해 프로토타입의 constructor 프로퍼티를 추가할 수 있다.
```
const Person = (function () {
  function Person(name) {
    this.name = name;
  }

  // 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체
  Person.prototype = {
    // constructor 프로퍼티와 생성자 함수 간의 연결을 설정
    constructor: Person,
    sayHello() {
      console.log(`Hi! My name is ${this.name}`);
    }
  };

  return Person;
}());

const me = new Person('Lee');

// constructor 프로퍼티가 생성자 함수를 가리킨다.
console.log(me.constructor === Person); // true
console.log(me.constructor === Object); // false
```

### 19.9.3 인스턴스에 의한 프로토타입 교체
인스턴스의 `__proto__` 접근자 프로퍼티를 통해 프로토타입을 교체할 수 있다. 이 방법을 사용한 인스턴스의 프로토타입은 교체되나, 생성자 함수의 prototype 프로퍼티가 교체되는 것은 아니다. 즉, 생성자 함수와의 연결이 파괴되는 것은 오직 `__proto__` 접근자 프로퍼티를 통해 프로토타입을 교체한 인스턴스만이다. 

```
function Person(name) {
  this.name = name;
}

const me = new Person('Lee');

// 프로토타입으로 교체할 객체
const parent = {
  sayHello() {
    console.log(`Hi! My name is ${this.name}`);
  }
};

// ① me 객체의 프로토타입을 parent 객체로 교체한다.
Object.setPrototypeOf(me, parent);
// 위 코드는 아래의 코드와 동일하게 동작한다.
// me.__proto__ = parent;

me.sayHello(); // Hi! My name is Lee
```
프로토타입 교체를 통해 상속 관계를 동적으로 변경하는 것은 꽤나 번거롭다. 따라서 프로토타입은 직접 교체하지 않는 것이 좋다. 

## 19.10 instanceof 연산자
> `객체 instanceof 생성자함수`

우변의 생성자 함수의 prototype 프로퍼티에 바인딩된 객체가 좌변의 객체의 프로토타입 체인에 존재하면 true로 평가된다. 아니면 당연히 false고.

```
function Person(name) {
  this.name = name;
}

const me = new Person('Lee');

// Person.prototype이 me 객체의 프로토타입 체인 상에 존재하므로 true로 평가된다.
console.log(me instanceof Person); // true

// Object.prototype이 me 객체의 프로토타입 체인 상에 존재하므로 true로 평가된다.
console.log(me instanceof Object); // true
```

instanceof 연산자는 프로토타입의 constructor프로퍼티가 가리키는 생성자 함수를 찾는 것이 아니라, ** 생성자 함수의 prototype에 바인딩된 객체가 프로토타입 체인 상에 존재하는지를 확인한다.** 즉, 프로토타입이 교체되더라도 instanceof는 아무런 영향을 받지 않는다. 

## 19.11 직접 상속
### 19.11.1 Obejct.create에 의한 직접 상속
> Object.create 는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다. Object.create 메서드도 다른 객체 생성 방식과 마찬가지로 추상 연산 OrdinaryObectCreate를 호출한다.

첫번쨰 매개변수로는 프로토타입이 될 객체를 전달하고, 두번째 매개변수로는 프로퍼티 키와 프로퍼티 디스크럽터 객체로 이뤄진 객체를 전달한다(두번쨰는 옵션이라 생략이 가능하다.).

```
// 프로토타입이 null인 객체를 생성한다. 생성된 객체는 프로토타입 체인의 종점에 위치한다.
// obj → null
let obj = Object.create(null);
console.log(Object.getPrototypeOf(obj) === null); // true
// Object.prototype을 상속받지 못한다.
console.log(obj.toString()); // TypeError: obj.toString is not a function

// obj → Object.prototype → null
// obj = {};와 동일하다.
obj = Object.create(Object.prototype);
console.log(Object.getPrototypeOf(obj) === Object.prototype); // true

// obj → Object.prototype → null
// obj = { x: 1 };와 동일하다.
obj = Object.create(Object.prototype, {
  x: { value: 1, writable: true, enumerable: true, configurable: true }
});
// 위 코드는 다음과 동일하다.
// obj = Object.create(Object.prototype);
// obj.x = 1;
console.log(obj.x); // 1
console.log(Object.getPrototypeOf(obj) === Object.prototype); // true

const myProto = { x: 10 };
// 임의의 객체를 직접 상속받는다.
// obj → myProto → Object.prototype → null
obj = Object.create(myProto);
console.log(obj.x); // 10
console.log(Object.getPrototypeOf(obj) === myProto); // true

// 생성자 함수
function Person(name) {
  this.name = name;
}

// obj → Person.prototype → Object.prototype → null
// obj = new Person('Lee')와 동일하다.
obj = Object.create(Person.prototype);
obj.name = 'Lee';
console.log(obj.name); // Lee
console.log(Object.getPrototypeOf(obj) === Person.prototype); // true
```
Object.create 메서드는 첫 번째 매개변수로 전달한 객체의 프로토타입 체인에 속하는 객체를 생성한다. 직접적으로 상속을 구현하는 것이다. 이 메서드의 장점은 다음과 같다.
* new연산자 없이도 객체를 생성할 수 있다.
* 프로토타입을 지정하면서 객체를 생성할 수 있다.
* 객체 리터럴에 의해 생성된 객체도 상속받을 수 있다..

ESLint에서는 Object.prototype의 빌트인 메서드를 객체가 직접 호출하는것을 권장하지 않는데, 프로토타입 체인 종점에 위치하는 객체는 빌트인 메서드를 사용할 수 없기 때문이다.

```
// 프로토타입이 null인 객체, 즉 프로토타입 체인의 종점에 위치하는 객체를 생성한다.
const obj = Object.create(null);
obj.a = 1;

console.log(Object.getPrototypeOf(obj) === null); // true

// obj는 Object.prototype의 빌트인 메서드를 사용할 수 없다.
console.log(obj.hasOwnProperty('a')); // TypeError: obj.hasOwnProperty is not a function
```
따라서 간접적인 호출이 더 좋은 방법이다.

```
// 프로토타입이 null인 객체를 생성한다.
const obj = Object.create(null);
obj.a = 1;

// console.log(obj.hasOwnProperty('a')); // TypeError: obj.hasOwnProperty is not a function

// Object.prototype의 빌트인 메서드는 객체로 직접 호출하지 않는다.
console.log(Object.prototype.hasOwnProperty.call(obj, 'a')); // true
```

### 19.11.2 객체 리터럴 내부에서 `__proto__`에 의한 직접 상속
Object.create 메서드는 장점이 많지만, 두번째 인자로 프로퍼티를 정의하는 것이 번거롭다. ES6에서는 객체 리터럴 내부에서`__proto__`접근자 프로퍼티를 사용해 직접 상속을 구현할 수 있다.

```
const myProto = { x: 10 };

// 객체 리터럴에 의해 객체를 생성하면서 프로토타입을 지정하여 직접 상속받을 수 있다.
const obj = {
  y: 20,
  // 객체를 직접 상속받는다.
  // obj → myProto → Object.prototype → null
  __proto__: myProto
};
/* 위 코드는 아래와 동일하다.
const obj = Object.create(myProto, {
  y: { value: 20, writable: true, enumerable: true, configurable: true }
});
*/

console.log(obj.x, obj.y); // 10 20
console.log(Object.getPrototypeOf(obj) === myProto); // true
```
## 19.12 정적 프로퍼티/ 메서드
> 정적 프로퍼티/메서드는 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티와 메서드이다.

```
// 생성자 함수
function Person(name) {
  this.name = name;
}

// 프로토타입 메서드
Person.prototype.sayHello = function () {
  console.log(`Hi! My name is ${this.name}`);
};

// 정적 프로퍼티
Person.staticProp = 'static prop';

// 정적 메서드
Person.staticMethod = function () {
  console.log('staticMethod');
};

const me = new Person('Lee');

// 생성자 함수에 추가한 정적 프로퍼티/메서드는 생성자 함수로 참조/호출한다.
Person.staticMethod(); // staticMethod

// 정적 프로퍼티/메서드는 생성자 함수가 생성한 인스턴스로 참조/호출할 수 없다.
// 인스턴스로 참조/호출할 수 있는 프로퍼티/메서드는 프로토타입 체인 상에 존재해야 한다.
me.staticMethod(); // TypeError: me.staticMethod is not a function
```
생성자 함수 또한 객체이므로 자신의 프로퍼티와 메서드를 가질 수 있다. 생성자 함수 객체가 소유하는 프로퍼티/메서드를 정적 프로퍼티/메서드라고 한다. 단, 생성자 함수로 만든 인스턴스는 정적 프로퍼티/메서드를 호출할 수 없다.
Obejct.create 메서드는 Object 생성자 함수의 정적 메서드이기 때문에 Object 생성자 함수로 생성한 객체로 호출할 수 없다.

만약 인스턴스/프로토타입 메서드 내에서 this를 사용하지 않았다면 그 메서드는 정적메서드로 변경할 수 있다.
```
function Foo() {}

// 프로토타입 메서드
// this를 참조하지 않는 프로토타입 메소드는 정적 메서드로 변경해도 동일한 효과를 얻을 수 있다.
Foo.prototype.x = function () {
  console.log('x');
};

const foo = new Foo();
// 프로토타입 메서드를 호출하려면 인스턴스를 생성해야 한다.
foo.x(); // x

// 정적 메서드
Foo.x = function () {
  console.log('x');
};

// 정적 메서드는 인스턴스를 생성하지 않아도 호출할 수 있다.
Foo.x(); // x
```

프로토타입 프로퍼티/메서드를 표기할 때 prototype을 #으로 표기하는 경우도 있다.(Object#isPrototypeOf 이렇게)

## 19.13 프로퍼티 존재 확인
### 19.13.1 in연산자
> in연산자는 객체에 특정 프로퍼티가 있는지를 확인한다.
key in object

```
const person = {
  name: 'Lee',
  address: 'Seoul'
};

// person 객체에 name 프로퍼티가 존재한다.
console.log('name' in person);    // true
// person 객체에 address 프로퍼티가 존재한다.
console.log('address' in person); // true
// person 객체에 age 프로퍼티가 존재하지 않는다.
console.log('age' in person);     // false
```
단 이 방법은 상속받은 모든 프로토타입의 프로퍼티를 확인하므로 주의가 필요하다. 즉, 객체에 없는 프로퍼티가 있다고 출력할수도 있다.

Reflect.has 메서드를 사용할수도 있다. 이는 in연산자와 동일하게 동작한다.

### 19.13.2 Object.prototype.hasOwnProperty 메서드
Object.prototype.hasOwnProperty를 사용해도 객체에 특정 프로퍼티가 있는지 확인할 수 있다.
```
const person = {name: 'lee'};

console.log(person.hasOwnProperty('name')); // true
console.log(person.hasOwnProperty('age'));  // false
```
이 경우 객체 고유의 프로퍼티 키인 경우에만 true, 상속받은 프로퍼티의 경우 false를 리턴한다.

## 19.14 프로퍼티 열거
### 19.14.1 `for...in`문
>  `for...in` 문을 사용하면 객체의 모든 프로퍼티를 순회하면서 열거한다.

```
const person = {
  name: 'Lee',
  address: 'Seoul'
};

// for...in 문의 변수 key에 person 객체의 프로퍼티 키가 할당된다.
for (const key in person) {
  console.log(key + ': ' + person[key]);
}
// name: Lee
// address: Seoul
```
이는 상속받은 프로퍼티까지 순회한다. 다만, Object.toString과 같은 Object.prototype의 프로퍼티는 열거되지 않는데, 그 이유는 순회되지 않도록 정의된 프로퍼티이기 떄문이다. Object.prototype.toString의 [[Enumerable]]의 값은 flase 이다.

따라서, ** `for...in`문은 프로토타입 체인 상의 모든 프로토타입 프로퍼티 중에서 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 true인 값을 순회하며 열거한다.**

또한 키가 심벌인 프로퍼티 또한 열거하지 않는다. 

객체 자신의 프로퍼티만 열거하려면 Object.prototype.hasOwnProperty 메서드를 사용해 객체 자신의 프로퍼티인지 확인한다.

```
const person = {
  name: 'Lee',
  address: 'Seoul',
  __proto__: { age: 20 }
};

for (const key in person) {
  // 객체 자신의 프로퍼티인지 확인한다.
  if (!person.hasOwnProperty(key)) continue;
  console.log(key + ': ' + person[key]);
}
// name: Lee
// address: Seoul
```

`for...in`문이 프로퍼티 열거에 순서를 보장하지 않지만, 대부분의 모던 브라우저는 순서를 보장하고 숫자(사실은 문자열)인 프로퍼티 키에서는 정렬을 한다.

```
const obj = {
  2: 2,
  3: 3,
  1: 1,
  b: 'b',
  a: 'a'
};

for (const key in obj) {
  if (!obj.hasOwnProperty(key)) continue;
  console.log(key + ': ' + obj[key]);
}

/*
1: 1
2: 2
3: 3
b: b
a: a
*/
```

### 19.14.2 Object.keys/values/entries 메서드

객체 고유의 프로퍼티만 열거하는 것은 Object.keys/values/entries 메서드를 사용하는 것이 더 권장된다.

Object.keys는 객체 자신의 열거 가능한 프로퍼티 키를 배열로 반환한다.
```
const person = {
  name: 'Lee',
  address: 'Seoul',
  __proto__: { age: 20 }
};

console.log(Object.keys(person)); // ["name", "address"]
```
Object.values는 객체 자신의 열거 가능한 프로퍼티 값은 배열로 반환한다.

```
console.log(Object.values(person)); // ["Lee", "Seoul"]
```
Object.entries 메서드는 객체 자신의 열거 가능한 프로퍼티 키와 값의 쌍의 배열을 배열에 담아 반환한다.
```
console.log(Object.entries(person)); // [["name", "Lee"], ["address", "Seoul"]]

Object.entries(person).forEach(([key, value]) => console.log(key, value));
/*
name Lee
address Seoul
*/
```