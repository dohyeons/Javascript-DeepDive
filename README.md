# Javascript-DeepDive

다이소 스터디 딥다이브 정리 저장소📖

# 01장 프로그래밍

## 1.1 프로그래밍이란?

> **💡프로그래밍**: 컴퓨터에게 실행을 요구하는 커뮤니케이션. 즉, **_문제를 명확히 이해하고 그 해결방안을 정의해야함_**

사용자에게는

- **문제를 명확히 이해**하고
- **복잡함을 단순하게 분해**하고
- **자료를 정리하고 구분**하며
- **순서에 맞게 행위를 배열**

하는 능력이 요구됨

그러나 가장 중요한 능력은, 컴퓨터의 관점에서 문제를 생각하는 컴퓨팅 사고(Computational Thinking)이다.

> **💡컴퓨팅 사고(Computational Thinking)**: 해결 과제를 작은 단위로 분해하고, 패턴화해서 추출하며, 프로그래밍에서 사용될 모든 개념을 평가가능하도록 정의함

## 1.2 프로그래밍 언어

문제 해결 방법을 수행하는 주체는 컴퓨터 → 기계어로 명령을 전달해야함

따라서, 사람이 이해할 수 있는 문법으로 구성된 프로그래밍 언어로 프로그램을 작성하고, 컴파일러 혹은 인터프리터를 통해 기계어로 번환해줌

> 프로그래밍 언어는 **구문 + 의미**의 조합이다.

## 1.3 구문과 의미

```
const number = '숫자';
console.log(number * number); // NaN
```

프로그래밍 언어에서도 문법과 의미 둘 다 중요하다. 위의 코드는 문법적으로는 문제가 없지만, 의미적으로는 올바르지 않다. number라는 변수에는 숫자가 할당되는 것이 의미적으로 옳다.

문제 해결 방안 역시 프로그래밍 문법을 통해 표현한다. 따라서 프로그래밍 언어 문법도 어긋나지 않고, 요구하는 바를 정확히 수행해야지만이 의미가 있다.

# 02장 자바스크립트의 특징

> 자바스크립트는 개발자가 별도의 컴파일을 하지 않는 **인터프리터 언어** 이다.

| 컴파일러 언어                                                          | 인터프리터 언어                                                        |
| ---------------------------------------------------------------------- | ---------------------------------------------------------------------- |
| 코드 실행 전 컴파일 타임에 코드 전체를 한번에 머신 코드로 변환 후 실행 | 런타임에 문 단위로 한줄씩 바이트 코드로 변환한 후 실행                 |
| 실행파일 생성                                                          | 실행파일 X                                                             |
| 컴파일과 실행 단계가 명시적으로 분리. 컴파일 - 실행                    | 인터프리트와 실행단계가 분리 X. 한 줄씩 바이트코드로 변환 후 바로 실행 |
| 컴파일은 단 한번 실행됨                                                | 코드가 실행될 때마다 인터프리트 과정이 반복 실행됨                     |
| 단계가 분리되어 실행속도가 빠름                                        | 단계가 분리되어있지 않고 반복되어 실행속도가 비교적 느림               |

# 04장 변수

## 변수란 무엇이고 왜 필요한가

- 컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 저장한다.
  > 메모리: 메모리 셀(1 바이트 = 8비트)의 집합체. 각 셀은 고유의 주소를 가지며, 주소는 0부터 시작해 메모리 크기만큼 정수로 표현됨.

컴퓨터는 모든 메모리를 2진수로 처리 → 데이터 종류에 상관 없이 2진수로 저장됨.

예를 들어,

```
10+20
```

에서 10과 20은 메모리 임의의 위치에 저장되고, CPU는 이 값을 읽어와서 연산한다. 결과인 30역시 메모리의 어딘가에 저장된다.

그러나 결과인 30은 재사용 할 수가 없는 문제가 발생한다. 결과를 재사용하고 싶다면 메모리 공간에 직접 접근해야 하지만, 자바스크립트에서는 개발자의 직접적인 메모리 제어를 허용하지 않는다.

이를 위해서 프로그래밍 언어는 값을 메모리에 저장하고, 다시 불러들여 재사용하기위해

**_변수_**

라는 메커니즘을 제공한다.

변수의 정의란

> 💡**변수**: 하나의 값을 저장하기 위해 확보한 **메모리 공간 자체 또는 그 공간을 식별하기 위해 붙인 이름**을 말한다.

다시말해, 변수 = 값의 위치를 가리키는 상징적인 이름이다.

10 + 20의 값을 저장하고 재사용하고 싶다면 다음과 같이 작성할 수 있다.

```
const sum = 10 + 20;
```

10 + 20은 연산으로 30을 만들고, 30은 메모리 공간의 임의의 주소에 저장되는데, 이 주소를 'sum' 이라는 이름으로 식별하는 것이다.

## 4.2 변수의 선언

변수의 사용 전에는 반드시 선언이 선행되어야 한다.

- 변수의 선언 = 변수의 생성이다.

var, let, const 키워드가 변수 선언에 사용된다. (단, var키워드가 가진 후술할 문제점들 때문에 ES6에서 let, const가 도입되었다.)

변수의 선언은 두 단계로 나뉜다.

1. 선언 단계: 변수 이름을 등록하고 자바스크립트에 존재를 알림
2. 초기화 단계: 메모리공간을 확보하고 암묵적으로 undefined를 할당해 초기화.

- 메모리 공간에는 이전에 사용한 값이 남아있을 수 있어서, 초기화를 하지 않으면 해당 쓰레기 값을 불러올 위험이 있다.

## 4.3 호이스팅

```
console.log(test);

var test;
```

자바스크립트는 위에서 설명했다시피 인터프리터 언어이고, 때문에 한줄씩 실행되어 Reference Error가 발생할 것처럼 보인다.
그러나 출력된 값은 undefined이다.

> 💡**_변수 선언이 런타임이 아니라 그 이전 단계에서 먼저 발생했기 때문이다._**

**자바스크립트는 런타임 전 소스코드 평가과정에서 모든 선언문을 찾아 먼저 실행한다. 따라서 변수 선언의 위치와 상관없이 변수를 참조할 수 있다.**

즉,

1. 런타임 전 평가과정에서 `var test` 가 먼저 실행되어 자바스크립트에 등록된다(= 선언된다).
2. 선언과 동시에, `test`는 undefined로 초기화 된다.

의 과정을 거치는 것이다.

이와 같이, 변수의 선언이 마치 스코프의 최상단에서 이루어진 것처럼 작동하는데, 이를 **_호이스팅_** 이라고 한다.

# 05장 표현식과 문

## 5.1 값

> **값** = 식이 평가되어 생성된 결과

평가 = 식을 해석해서 값을 생성하거나 참조하는 것

```
10 + 20
```

위 식은 평가되고 값 30을 생성한다.

모든 값은 데이터 타입을 가지고, 메모리에 2진수로 저장된다. 값은 데이터 타입에 따라 다르게 해석될 수 있다.

## 5.2 리터럴

리터럴은 값을 생성하는 방법 중 하나이다.

> **리터럴** = 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법

```
1 // 숫자 리터럴
'hello' // 문자열 리터럴
function () {} // 함수 리터럴
```

## 5.3 표현식

> **표현식** = 값으로 평가될 수 있는 문

값으로 평가될 수 있는 문은 모두 표현식임에 주목하자.

```
100;
```

리터럴은 값을 생성하므로 그 자체가 표현식이다.

```
let score = 100 + 100;
```

100 + 100 역시 평가되어 값을 생성하므로 표현식이다.

```
score;
```

score역시 참조되고, 200으로 평가되므로 표현식이다.

이를 다시 생각해보면, 표현식과 표현식이 평가된 값은 동등한 관계를 가진다.

> 따라서 문법적으로 값이 위치할 수 있는 자리에는 표현식이 위치할 수 있다.

또한, 표현식은 다른 표현식의 일부로 값을 생성할 수 있다.

```
let score2 = score + 100;
```

## 5.4 문

> **문** = 프로그램을 구성하는 기본 단위이자 **최소 실행 단위**

> **토큰** = 문법적 의미가 있고, 더 이상 나눌 수 없는 코드의 기본적인 요소

```
let score = 100 + 100
//let, score, =, 100, +, 100. ; 모두 토큰이다.
```

자바스크립트에서 볼 수 있는 오류 Unexpected Token 오류. 예상치 못한 언어 구조를 맞이했을 때 발생하는 오류이다.

문은 선언문, 할당문, 조건문, 반복문 등으로 구분할 수 있다.

## 5.5 세미콜론 & 세미콜론의 자동 삽입 기능

세미콜론은 문의 종료를 의미하며, 자바스크립트는 세미콜론의 위치를 파악하고 순차적으로 문을 실행한다. 즉, 문의 종료 = 세미콜론의 등장이다.

그러나 코드블록은 자체 종결성을 가지기 때문에 세미콜론을 붙이지 않는다.

> 그러나, 문의 끝에 붙이는 세미콜론은 옵션이다. 자바스크립트 엔진이 세미콜론 자동 삽입 기능이 있기 때문이다.

다만 세미콜론 사용이 권장되는 분위기이다. 개발자의 의도와, 기능의 의도가 어긋날 수 있기 때문이다.

## 5.6 표현식인 문 & 표현식이 아닌 문

- 표현식인 문 = 값으로 평가될 수 있는 문
- 표현식이 아닌 문 = 값으로 평가될 수 없는 문

둘을 구분하는 가장 간단한 방법은 변수에 할당해보는 것이다.

```
let x ;
x = 100;
// 표현식인 문

let x = let y;
// 표현식이 아닌 문
```

++ 완료 값
개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined를 출력하는데, 이를 **완료 값**이라고 한다. 완료값은 평가 결과가 아니라 할당할 수 없고, 참조할 수 없다.

# 06장 데이터 타입

자바스크립트의 모든 값은 데이터 타입을 가진다.
총 7개의 데이터 타입을 제공한다. 6개의 원시타입 + 객체타입으로 이루어진다.

| 원시타입  | 설명                               |
| --------- | ---------------------------------- |
| 숫자      | 숫자.(정수, 실수 구분이 없다.)     |
| 문자열    | '문자열'                           |
| 불리언    | true, false                        |
| undefined | var키워드의 초기화에 사용되는 값   |
| null      | 값이 없음을 의도적으로 표현하는 값 |
| 심벌      | ES6에서 추가된 타입                |

객체 타입 - 객체, 함수, 배열

- 타입이 궁금하다면 typeof를 통해 알아볼 수 있다.

## 6.1 숫자 타입

자바스크립트에서는 10진수를 위한 데이터타입만을 지원하기에 2진수 8진수 16진수 모두 참조시에 10진수로 해석된다.

```
0o101 === 0x41 // true
```

또한 다음의 값들 또한 표현할 수 있다.

- Infinity: 양의 무한대
- -Infinity: 음의 무한대
- NaN: 산술 연산 불가. Not a Number를 의미한다.

```
(10 / 0) // Infinity
(10 / -0) // -Infinity
```

## 6.2 문자열 타입

텍스트 데이터를 나타내는 데 사용한다.
'', "", ``으로 텍스트를 감싼다.

```
'이렇게';
"이렇게";
`이렇게`;
```

## 6.3 템플릿 리터럴

멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 문자열 처리 기능을 가진 문자열 표기법이다.

오로지 백틱만을 사용한다.

- 멀티라인 문자열

```
console.log(`안녕
하세요`);

// 결과물
안녕
하세요
```

- 표현식 삽입
  : ${}으로 표현식을 감싸면 평가결과를 문자열로 바꿔 삽입한다.

```
console.log(`1 + 1 은 ${1 + 1} 입니다.`)
// 1 + 1 은 2 입니다.
```

## 6.4 undefined

undefined 타입의 값은 undefined가 유일하다.
undefined는 변수를 초기화하는데 사용된다. 즉, 개발자가 임의로 사용한다면 본래 취지에 어긋나며 혼란을 줄 수 있으므로 권장하지 않는다.
변수에 값이 없음을 명시하고 싶을떄는 **null**을 사용한다.

## 6.5 null

null 타입의 값 또한 null이 유일하다.

> 값이 없음을 의도적으로 명시한다.
> 즉, null이 할당된 변수는 더이상 이전의 값을 참조하지 않겠다는 의미이다. 따라서 전에 있던 값의 메모리 공간에 대한 가비지 콜렉션이 수행된다.

## 6.6 심벌

> 변경이 불가능한 원시 타입의 값

중복이 되지 않는 유일무이한 값이다. 객체의 프로퍼티 값이 중복없이 유일하기 위해 사용한다.

Symbol 함수를 호출해 생성한다. 외부에 노출되지 않으며, 다른 값과 중복되지 않는다.

```
let key = Symbol('key');
let obj = {};
obj[key] = '값임';
```

## 6.7 데이터 타입의 필요성

### 6.7.1 데이터 타입에 의한 메모리 공간 확보와 참조

메모리 값을 저장하기 위해서는 메모리 공간의 크기를 결정해야 한다.
만약

```
let num = 100;
```

에서 num을 참조하고 싶으면 어떻게 할까? num에 할당된 값은 숫자 타입으므로 8바이트 단위로 읽지 않으면 값이 훼손된다. 이럴 때 자바스크립트 엔진은 num 변수를 숫자 타입으로 인식해 8바이트 단위로 값을 읽어 들인다.

### 6.7.2 데이터 타입에 의한 값의 해석

그런데 이 100을 어떻게 해석하느냐의 문제가 남아있다.
모든 값은 메모리에 2진수의 나열로 저장된다. 하지만 데이터 타입에 따라 2진수는 다르게 해석될 수 있기 때문에, 데이터 타입에 따라 다르게 해석될 수 있다.
그러나 num에 숫자 타입의 값이 할당되어 있기 때문에, 자바스크립트 엔진은 이 2진수를 숫자로 해석한다.

## 6.8 동적 타이핑

> 정적 타입 언어(c, 자바): 변수 선언 시 데이터 타입을 사전에 선언해야한다.(명시적 타입 선언).

정적 타입 언어는 컴파일 시 타입 체크를 실시하는데, 이를 통과하지 못하면 프로그램의 실행 자체를 막는다.

자바스크립트는 변수 선언 시 타입을 선언하지 않고, 키워드만을 사용한다. 따라서 타입에 상관없이 자유로운 할당이 가능하다. 다시말해, 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정된다. 그리고 재할당에 의해 언제든 타입을 바꿀 수 있는데 이를 **동적 타이핑**이라고 하며, 이러한 언어를 **동적 타입 언어**라고 한다. 동적 타입 언어에서는 값에 의해 변수의 타입이 동적으로 결정된다.

- 동적 타입 언어의 단점

1. 변화하는 변수 값을 추적하기 어려울 수 있다.
2. 값의 확인 전에는 타입을 확신할 수 없다. 즉, 유연성은 높지만 신뢰성은 떨어진다.

- 변수 사용 시 주의사항

1. 꼭 필요한 경우에만 사용
2. 스코프를 최대한 좁게 만들 것
3. 전역 변수는 최대한 사용을 자제할 것
4. 상수를 사용해 변경을 억제
5. 변수 이름은 목적과 의미를 파악할 수 있도록 네이밍 할 것

# 7장 연산자

> 연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산을 수행해 하나의 값을 만든다.

## 7.1 산술 연산자

> 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다.
> 불가능할 경우, NaN을 반환한다.

### 7.1.1 이항 산술 연산자

> 2개 이상의 피연산자를 산술 연산해 숫자 값을 만든다.

### 7.1.2 단항 산술 연산자

> 1개의 피연산자를 산술 연산해 숫자 값을 만든다.
> ++, -- 등

이 연산자들은 위치에 의미가 있다.

- 피연산자 앞에 위치할 경우 값을 먼저 증가시킨 뒤, 다른 연산을 수행한다.

숫자 타입이 아닌 값에 +, -를 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다.

```
let test = '1';
console.log(typeof +test)// 'number'
test = true;
console.log(+test) // 1
```

### 7.1.3 문자열 연결 연산자

> +의 피연산자 중 하나라도 문자열인 경우 문자열 연결 연산자로 동작한다.

```
(1 + '1'); // '11'
1 + true; // 2
```

개발자의 의도와 상관없이 암묵적으로 타입이 변환됨에 주의해야한다. 이를 **암묵적 타입 변환** 혹은 **타입 강제 변환** 이라고 한다.

## 7.2 할당 연산자

> 우항의 피연산자를 좌항의 변수에 할당한다.

## 7.3 비교 연산자

> Object.is는 예측 가능한 정확한 비교 결과를 리턴한다.

```
Object.is(NaN, NaN) // true
```

## 7.4 삼항 조건 연산자

삼항 조건 연산자는 값으로 평가할 수 있는 표현식인 문이다. 따라서 값처럼 다른 표현식의 일부가 될 수 있다.

```
let test = 10;
let result = test % 2 ? '홀수' : '짝수';
```

수행해야 할 문이 여러개라면 if else 문의 가독성이 더 좋다.

## 7.5 그룹 연산자

> 우선순위를 정하기 위한 연산자. ()를 사용해 감싸면 우선순위가 가장 높다.

```
10 * 2 + 10; // 30
10 * (2 + 10); // 24
```

## 7.6 지수 연산자

> 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭제곱한다

```
2 ** 2; // 4
```

## 7.7 연산자의 부수 효과

> 할당 연산자, 증가/감소 연산자, delete연산자는 다른 코드에 영향을 준다.

```
let test = 1;

test++;

console.log(test); // 2

test --;

console.log(test); // 1

let obj = { a: 1};

delete obj.a;

console.log(obj);// {}
```

## 7.8 연산자 우선순위

연산자 우선순위는 모두 기억하기 어렵다. 따라서 ()를 사용하여 명시적으로 조절하는 것이 권장된다.

# 8장 제어문

> 제어문은 조건에 따라 코드블록을 실행하거나 반복 실행할 때 사용한다.

## 8.1 블록문

> 블록문: 0개 이상의 문을 중괄호로 묶은 것(= 코드 블록, 블록)

- 블록문은 하나의 실행 단위이다.

- 단독 사용이 가능하나 일반적으로는 제어문, 함수 정의에 사용한다.

- 블록문은 자체 종결성을 가지기 때문에 세미콜론을 붙이지 않는다.

```
{
	let five = 5;
	// 이런식으로 사용하는 경우는 거의 없다.
}

function sum(a, b) {
	return a + b;
}
// 이런식으로 함수 정의에 사용되기도 한다.
```

## 8.2 조건문

> 조건문: 주어신 조건식의 평가 결과에 딸 코드 블록의 실행을 결정한다.

자바크립트의 조건문

1. if ...else 문
2. switch문

### 8.2.1 if...else 문

```
if(조건식) {
	// 조건식이 참일때 실행될 코드
} else {
	// 조건식이 거짓일때 실행될 코드
}
```

- 조건식을 Boolean으로 평가되어야한다.

- 만약 조건에 따라 실행될 블록을 늘리고 싶으면 else if 문을 사용한다.

- if와 else 는 2번 이상 사용이 불가능하다.

- 블록 내부의 문이 하나뿐이라면 중괄호를 생략할 수 있다.

```
if(true) return true;
```

- if...else 문은 삼항연산자로 바꿀 수 있다.
  <br>삼항 연산자를 사용하는것이 가독성은 좋으나, 조건이 여러개일 경우 if...else의 가독성이 좋다.

### 8.2.2. switch문

> 표현식을 평가하여 그 값과 일치하는 표현식을 가지는 case문으로 실행흐름을 옮긴다.

- switch문의 표현식과 인치하는 case문이 없으면 순서가 default로 이동한다.

- 참/거짓을 따지기보다는 다양한 상황에 따라 실행할 코드 블록을 결정할 때 쓰인다.

```
let age = 19;
let notion;
switch(age) {
	case 19 : notion = '야 나가';
}

console.log(notion); // '야 나가'
```

그러나 switch문에는 되도록이면 break를 써주는 것이 좋다. 다음의 경우를 보면

```
let age = 19;
let notion;
switch(age) {
	case 19 : notion = '야 나가';
	case 20 : notion = '어서오세연!';
  default : notion = '신분증좀 주세연' ;
}

console.log(notion); // '신분증좀 주세연'
```

`'야 나가'` 이 출력될거라는 예상과 다르게 default의 문이 실행된 것을 볼 수 있다. 이는 코드의 실행은 정상적으로 `case 19`으로 옮겨졌지만, break문이 없어 밑의 case문과 default문을 거치며 실행했기 때문이다. 이처럼 switch문을 탈출하지 못하고 밑의 case와 default를 실행하는 것을 **폴스루**라고 부른다.

break는 코드 블록에서 탈출하는 역할을 한다. 따라서 위는 다음과 같이 쓰여야 한다.

```
let age = 19;
let notion;
switch(age) {
	case 19 : notion = '야 나가';
	break;
	case 20 : notion = '어서오세연!';
	break;
  default : notion = '신분증좀 주세연' ;
}

console.log(notion); // '야 나가'
```

- if...else문으로 해결할 수 있으면 그러는게 좋은, 조건이 너무 많아 가독성에 문제가 있다면 switch문을 사용하는 것이 더 좋을 수 있다.

## 8.3 반복문

> 조건식의 결과가 거짓이 나오기 전까지 코드를 반복해서 실행한다.

- 자바스크립트에서 제공하는 반복문

1. for 문
2. while 문
3. do...while 문

### 8.3.1 for문

> 조건식이 거짓으로 평가될 때까지 코드를 반복 실행한다.

- for문의 변수 선언문, 조건식, 증감식은 옵션이다. 다만, 어떤 식도 선언하지 않으면 코드가 무한 실행된다.

```
for(;;) {
	console.log('무한실행');
}
```

- for문 안의 코드블록에 for문을 또다시 사용할 수 있다. (중첩 for문)

  8.3.2 while문

  > 조건식이 거짓으로 평가될 때까지 코드를 반복 실행한다. 다만, **반복 횟수가 불명확 할 때 주로 사용한다.**

### 8.3.3 do...while문

> 코드 블록을 먼저 실행한 다음 조건식을 평가한다.

```
let count = 3;
do {
	console.log(count);
	count--;
} while (count > 0);
```

## 8.4 break 문

> 코드 블록을 탈출한다. 다만, **레이블 문, 반복문, switch문 등의 코드 블록을 탈출한다.** 이 외의 블록에서 사용할 경우 SyntaxError가 발생한다.

- 레이블 문은 식별자가 붙은 문이다.

```
sayHello : console.log('안녕');
```

레이블문은 일반적으로 중첩for문을 탈출할 때 외에는 권장하지 않는다.

## 8.5 continue문

> 반복문의 코드 블록 실행을 여기서 멈추고, 증감식으로 실행 흐름을 이동시킨다.

```
let test = 0;

for (let i = 0 ; i < 5 ; i++) {
	if(i < 2) continue;
	test++;
}
console.log(test); // 3
```

i < 2일 경우 `test++`은 실행되지 않고 증감식(`i++`)으로 이동한다. 그 후 i가 2일때부터 `test++`가 실행된다. 이는 밑의 코드와 같다.

```
for (let i = 0 ; i < 5 ; i++) {
	if(i >= 2) test++;
}
```

실행해야 할 코드가 한줄이면 continue보다 가독성이 좋다. 그러나 코드가 길어진다면 continue문을 사용하는 편이 가독성이 좋다.

```
for (let i = 0 ; i < 5 ; i++) {
	if(i < 2) continue;
	test++;
	console.log('가독성이 좋아연');
}

for (let i = 0 ; i < 5 ; i++) {
	if(i >= 2) {
		test++;
		console.log('가독성이 별루에연');
	}
}
```

# 9장 타입 변환과 단축 평가

## 9.1 타입 변환이란 무엇인가

자바스크립트의 모든 값은 타입이 있고, 개발자의 의도에 따라 다른 타입으로 변환할 수 있다.

- 명시적 타입 변환(= 타입 캐스팅): 개발자가 의도적으로 타입을 변환하는 것
- 암묵적 타입 변환(= 타입 강제 변환): 개발자 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환

```
let num = 10;
// 명시적 타입 변환. toString을 이용해 의도적으로 타입을 변환함
let str = num.toString();
console.log(typeof str, str); // string, 10;

// 암묵적 타입 변환. 문자열 연결 연산자가 새로운 문자열을 생성
str = num + '';
console.log(typeof str, str); // string, 10;

```

- 이때, 기존의 원시 값 `num`은 직접 변경되지 않는다. 타입 변환은 기존 원시값을 이용해 다르 타입의 새 원시값을 생성하는 것이다.
  > 명시적 타입 변환은 변환의 의지가 코드에 명백히 드러난다. 하지만 암묵적 타입 변환의 경우 자동 변환이기 때문에 개발자의 의지가 명백히 나타나는 것은 아니다.
  > <br>
  > 따라서 암묵적 타입 변환이 일어나지 않도록 코드를 작성하는 것이 좋다고 생각할 수 있다. 그러나 이는 옳지 않다. 개발자의 입장에서 `(10).toString()`보다는 `10 +''`가 더 간결하고 이해하기 쉽다.
  > <br>
  > 코드를 작성할 때 가장 중요한 것은 협업을 해야함을 잊지 않는 것이다. 따라서 동료가 쓴 코드를 이해할 수 있어야 하고, 내가 쓴 코드를 동료가 이해하기 쉽도록 해야 한다.

## 9.2 암묵적 타입 변환

자바스크립트에서는 가능한 에러를 줄이기 위해 암묵적 타입 변환을 통해 표현식을 평가한다.

```
'10' + 3 // '103'
```

암묵적 타입 변환이 발생하면 원시 타입 중 하나로 값을 자동 변환한다.

### 9.2.1 문자열 타입으로 변환

> `+` 연산자는 피연산자 중 하나라도 문자열이라면 문자열 연결 연산자로 동작한다.

그 뿐 아니라, 표현식을 평가할때 또한 암묵적으로 타입 변환한다.

```
1 + '2' // -> "12"

//표현식을 암묵적으로 변환한다.
`1 + 1 = ${1 + 1}` // -> "1 + 1 = 2"

```

### 9.2.2 숫자 타입으로 변환

> 산술 연산자 표현식을 평가하기 위해 피연산자 중 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다.

만약 피연산자가 숫자 타입으로 변환이 불가능한 경우, 표현식의 평가 결과는 NaN이 된다.

```
1 - '1' // 0
1 / 'one' // NaN
```

> 비교 연산자 또한 피연산잘르 숫자 타입으로 암묵적 타입 변환한다.

```
1 > '0' // true
```

> `+`단항 연산자는 피연산자가 숫자 타입이 아니면 숫자 타입으로 암묵적 타입 변환한다.

```
// 문자열 타입
+''       // -> 0
+'0'      // -> 0
+'1'      // -> 1
+'string' // -> NaN. string은 숫자 타입으로 평가될 수 없으므로 NaN.

// 불리언 타입
+true     // -> 1
+false    // -> 0

// null 타입
+null     // -> 0

// undefined 타입. 단, 이 경우 NaN을 반환한다.
+undefined // -> NaN
```

### 9.2.3 불리언 타입으로 변환

> 조건식에서 자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값, 또는 Falsy 값으로 평가한다.

Falsy로 평가되는 값은 다음과 같다.

- false
- undefined
- null
- 0, -0
- NaN
- ''

이 외에는 모두 Truthy로 평가된다.

## 9.3 명시적 타입 변환

표준 빌트인 생성자 함수에서 new 연산자 없이 호출, 빌트인 메서드 사용, 암묵적 타입 변환 이용

### 9.3.1 문자열 타입으로 변환

- String 생성자를 new 없이 호출
- Object.prototype.toString 메서드 사용
- 문자열 연결 연산자 이용

```
// 1. String 생성자 함수를 new 연산자 없이 호출
// 숫자 타입 => 문자열 타입
String(1); // -> "1"
String(NaN); // -> "NaN"
String(Infinity); // -> "Infinity"
// 불리언 타입 => 문자열 타입
String(true); // -> "true"

// 2. Object.prototype.toString 메서드를 사용
// 숫자 타입 => 문자열 타입
(1).toString(); // -> "1"
(NaN).toString(); // -> "NaN"
(Infinity).toString(); // -> "Infinity"
// 불리언 타입 => 문자열 타입
(true).toString(); // -> "true"

// 3. 문자열 연결 연산자를 이용
// 숫자 타입 => 문자열 타입
1 + ''; // -> "1"
NaN + ''; // -> "NaN"
Infinity + ''; // -> "Infinity"
// 불리언 타입 => 문자열 타입
true + '';     // -> "true"
```

### 9.3.2 숫자 타입으로 변환

- Number 생성자 합수 new 연산자 없이 호출
- parseInt, parseFloat함수 사용
- `+` 단항 산술연산자 사용
- `*`산술 연산자 사용

```
// 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법
// 문자열 타입 => 숫자 타입
Number('0'); // -> 0
// 불리언 타입 => 숫자 타입
Number(true); // -> 1

// 2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)
// 문자열 타입 => 숫자 타입
parseInt('0');       // -> 0

// 3. + 단항 산술 연산자를 이용하는 방법
// 문자열 타입 => 숫자 타입
+'0';     // -> 0
+'-1';    // -> -1
// 불리언 타입 => 숫자 타입
+true;    // -> 1

// 4. * 산술 연산자를 이용하는 방법
// 문자열 타입 => 숫자 타입
'0' * 1;     // -> 0
// 불리언 타입 => 숫자 타입
true * 1;    // -> 1
```

### 9.3.3 불리언 타입으로 변환

- Boolean 생성자 함수를 new 연산자 없이 호출
- ! 부정 논리 연산자를 두번 사용

```
Boolean('x') // true
Boolean('') // false
Boolean('false') // true

!!'' ; false
!!'false' ; true
```

## 9.4 단축 평가

### 9.4.1 논리 연산자를 사용한 단축 평가

> 논리합, 논리곱 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.

둘다 좌항에서 우항으로 진행된다.

```
'left' && 'right'; // 'right'
'' || 'right' // ''
```

> **논리곱, 논리합 연산자는 피연산자를 타입 변환하지 않고 그대로 반환하는데, 이를 단축 평가라고 한다.**

단축 평가는 if문을 대체할 수 있다.

```
let age = 19;
let messange;

message = (age >= 19) && '어서오세여 손님!';
console.log(message);

// 이는 다음 식과 같다.
if(age >= 19) message = '어서오세여 손님!'

// 또한 다음과 같이 사용할수도 있다.
message = age < 19 || '야 나가';
console.log(message) // '야 나가'
```

단축 평가의 유용한 패턴은 다음과 같다.

- **객체가 가리키키를 기대한 변수가 null, undefined인지를 확인하고 프로퍼티를 참조할 때**
  만약 변수의 값이 객체가 아니라 null, undefined인 경우 타입 에러를 발생시키고, 강제적으로 프로그램이 종료된다.
  이때 단축평가를 사용하면 이를 방지할 수 있다.

```
let obj = null;
let value = obj.value // TypeError

// 이를 아래와 같이 쓰면 에러를 방지한다.
let value = obj && elem.value // null
```

- **함수 매개변수에 기본값을 설정할 때**
  함수 호출 시 인수를 전달하지 않는다면 undefined가 할당된다. 단축 평가를 사용해 매개변수의 기본값을 설정하면, undefined일때 생성되는 오류들을 방지할 수 있다.

```
function checkAge(age) {
  age = age || '민자';
  return age >= 19 ? '어서오세연 손님!' : '야 나가'
}

checkAge(); // '야 나가'
```

물론 ES6의 매개변수 기본값 설정을 사용하면 더 쉽게 가능하다.

```
function checkAge(age='민자') {
  return age >= 19 ? '어서오세연 손님!' : '야 나가'
}
checkAge(); // '야 나가'
```

### 9.4.2 옵셔널 체이닝 연산자 `?.`

> 좌항의 피연산자가 null, undefined인 경우 undefined를 반환하고, 아니면 우항의 프로퍼티 참조를 이어간다.

논리곱의 경우 Falsy값이면 좌항의 피연산자를 그대로 반환했다. 하지만 0과 ''의 경우 객체로 평가되는 경우가 있다.

```
let name = '';
let length = name && name.length; // 이름의 길이를 참조하고 싶음
console.log(length) // ''. 즉 이름의 길이를 참조를 못함
```

하지만 옵셔널 체이닝 연산자의 경우 Falsy값 이라도 null, undefined가 아니면 프로퍼티 참조를 이어간다.

```
let name = '';
let length = name?.length;
console.log(length) // 0
```

### 9.4.2 null병합 연산자 `??`

> 좌항의 피연산자가 null, undefined인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다.

변수에 기본값을 설정할 때 유용하다.

```
// Falsy 값인 0이나 ''도 기본값으로서 유효하다면 예기치 않은 동작이 발생할 수 있다.
var foo = '' || 'default string';
console.log(foo); // "default string"

// 좌항의 피연산자가 Falsy값이라도 null, undefined가 아니면 좌항의 피연산자를 반환한다.
let foo = null ?? 'default string';
console.log(foo); // "default string"
var foo = '' ?? 'default string';
console.log(foo); // ""
```

# 10장 객체 리터럴

## 10.1 객체란 무엇인가

> 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조

- 원시값을 제외한 나머지는 모두 객체다.
- 객체는 0개 이상의 프로퍼티로 구성되어 있으며 프로퍼티는 키와 값으로 구성된다.
- 자바스크립트의 모든 값은 프로퍼티 값이 될 수 있다. 자바스크립트는 함수를 일급 객체 취급하므로, 함수도 값이 될 수 있다. 이를 **메서드** 라고 부른다.

이를 다시 정리하자면

- 프로퍼티: 객체의 상태를 나타내는 값
- 메서드: 프로퍼티를 참조하고 조작할 수 있는 동작

## 10.2 객체 리터럴에 의한 객체 생성

자바스크립트는 다양한 객체 생성 방법을 지원한다.

- 객체 리터럴
- Object 생성자 합수
- 생성자 함수
- object.create 메서드
- 클래스

이 중 가장 일반적인 방법은 객체 리터럴을 이용하는 방식이다. 중괄호 내에 0개 이상의 프로퍼티를 정의한다. 변수에 할당되는 시점에 자바스크립트 엔진이 이를 해석해 객체를 생성한다. 만약 프로퍼티를 정의하지 않으면 빈 객체가 생성된다.

```
let product = {
	price: 6000,
	sale: function() {
		this.price = this.price * 0.5
	}
};

product.sale();
product.price;

let obj = {};
```

여기서 객체 리터럴의 중괄호는 코드 블럭이 아님을 주의하자. 때문에 세미콜론을 붙여야한다.

## 10.3 프로퍼티

> 객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.

- 프로퍼티 키: 빈 문자열 포함 모든 문자열 또는 심벌 값
- 프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값

프로퍼티 키는 식별자 역할을 하지만 식별자 네이밍 규칙을 반드시 지켜야 하는 것은 아니다. 그러나 식별자 규칙을 따르지 않을 경우 반드시 따옴표를 사용해야 한다.

```
let product = {
	price: 6000,
	'made-in': korea
}
```

- 프로퍼티의 동적 생성 또한 가능하다.

```
let product = {
	price: 6000,
	sale: function() {
		this.price = this.price * 0.5
	}
};

product['name'] = '스파클링';
console.log(product); //{ price: 6000, sale: ƒ sale(), name: '스파클링' }
product[''] = '뭐여';
console.log(product);
// {
  price: 6000,
  sale: ƒ sale(),
  name: '스파클링',
  '': '뭐여'
}
```

여기서 주목할 점은 빈 문자열 또한 키로 사용이 가능하다는 점이다. 그러나 이는 키로서 의미가 없으므로 권장되지 않는다.

- 문자열, 심벌 이외의 값을 키로 사용하면 암묵적 타입 변환을 통해 문자열로 변환된다.

- 예약어를 사용해도 오류가 발생하지는 않는다. 다만 어떤 오류가 생길지 모르니 추천하지는 않는다.

- 같은 키를 사용할 경우 나중에 작성한 키의 값이 먼저 선언한 키의 값을 덮어쓴다.

```
let test1 = {
	0: 0
}

let test2 = {
	function = "function"
}

let test3 = {
	test = "test",
	test = "테스트"
}
```

## 10.4 메서드

> 프로퍼티의 값이 함수일 경우, 일반 함수와 구분하기 위해 메서드라고 부른다.

## 10.5 프로퍼티 접근 방법

다음의 두가지 방식이 있다.

- 마침표 표기법(. 사용)
- 대괄호 표기법([] 사용)

프로퍼티 키가 자바스크립트에서 유효한 이름이면 둘 다 사용이 가능하다.

또한 **대괄호 표기법을 사용하는 경우, 대괄호 내부에는 반드시 따옴표로 감싼 문자열이 들어가야 한다**단, 숫자로 이루어진 문자열이라면 따옴표를 생략할 수 있다.

```
let product = {
	price: 6000,
	sale: function() {
		this.price = this.price * 0.5
	}
};
console.log(product['price']); // 6000
```

객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환한다.(ReferenceError가 발생하지 않음에 주의하자.)

- 프로퍼티 키가 자바스크립트에서 유효한 이름이 아니면 반드시 대괄호 표기법을 준수해야한다.

```
let iPhone = {
	'phone-name' : 'iPhone 13',
	13: 'pro'
}
iPhone.'phone-name'; // SyntaxError
iPhone.phone-name; // 브라우저와 Node.js에서의 결과가 다르다.
iPhone['phone-name'] // 'iPhone 13'

iPhone.1; // SyntaxError
iPhone[1]; // 'pro'
```

위에서 브라우저와 Node.js의 실행 결과가 드르다 자바스크립트 엔진에서는 iPhone.phone를 평가한다. 이는 undefined로 평가되며(phone라는 키가 없으니까) 결국 undefined - name과 같아진다.
<br>Node.js에서는 name이라는 식별자가 없으므로 ReferenceError가 발생한다. 하지만 브라우저에는 전역객체에 name이 암묵적으로 존재하는데 이는 빈 문자열이다. 따라서 undefined - ''와 같아져 NaN이 된다.

## 10.6 프로퍼티 값 갱신 및 삭제

> 이미 존재하는 프로퍼티에 값을 할당하면 값이 갱신된다.

```
let person = {
	name: 'do'
}
person.name = 'hs';
console.log(person.name); // 'hs'
```

> delete연산자는 객체의 프로퍼티를 삭제한다. 이때, 존재하지 않는 프로퍼티에 접근하면 에러 없이 무시된다.

```
delete person.name;
delete person.age;
console.log(person); // {}
```

## 10.9 ES6에서 추가된 객체 리터럴 확장 기능

### 10.9.1 프로퍼티 축약 표현

> 변수 이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티 키를 생략할 수 있다.

```
let x = 1;
let y = 2;

let obj = {x, y};
console.log(obj); // {x: 1, y: 2}
```

### 10.9.2 계산된 프로퍼티 이름

> 객체 리터럴 내부에서 프로퍼티 키를 동적 생성할 수 있다.

```
const prefix = 'test';
let i = 0;

// 객체 리터럴 내부에서 계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성
const obj = {
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i
};

console.log(obj); // {test-1: 1, test-2: 2, test-3: 3}
```

### 10.9.3 메서드 축약 표현

> function 키워드를 생략한 축약 표현을 사용할 수 있다.

```
const person = {
	name: 'do',
	sayHi() {
		console.log('안냐세연~~');
	}
}
```

# 11장 원시 값과 객체의 비교

| 원시타입                                     | 객체타입                                            |
| -------------------------------------------- | --------------------------------------------------- |
| 변경 불가능한 값                             | 변경 가능한 값                                      |
| 변수에 실제 값 저장                          | 변수에 참조값 저장                                  |
| 변수를 다른 변수에 할당하면 원시값 복사 전달 | 변수를 다른 변수에 할당하면 참조 값이 복사되어 전달 |

## 11.1 원시 값

### 11.1.1 변경 불가능한 값

> 원시 값 = 변경이 불가능한 값. 읽기 전용의 값이라 변경이 불가능하다.

- 주의할 점은, 변경이 불가능하다는 것은 변수가 아닌 값에 대한 진술임. 즉, 변수값이 재할당이 불가능 하다는 점이 아니다.
- 이러한 원시값의 특성은 데이터의 신뢰성을 보장한다.

- 만약 원시값의 변경이 가능했다면, 재할당이 일어났을 때 메모리 공간의 주소를 변경하는 것이 아닌, 기존 메모리 주소에 있는 원시 값 자체를 변경한다.

- 이러한 값의 특성을 불변성이라고 한다. **불변성을 가지는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 방법이 없다.**

### 11.1.2 문자열과 불변성

- 원시값을 저장하기 위해서는 확보해야하는 메모리 공간의 크기를 정해야 하고, 원시 타입별로 메모리 공간의 크기가 미리 정해져 있다.

- 문자열은 유사 배열 객체이자 이터러블 이므로 각 문자 하나하나에 접근이 가능하다. 하지만, 그 문자 하나하나를 변경할 수는 없다.

```
let test = 'test;

console.log(test[0]); // 't'
test[0] = 'T';
console.log(test); // 'test'
```

- 이러한 특징은 예기치 못한 변경으로부터 문자열을 보호한다. 이는 데이터의 신뢰성을 보장한다.

### 11.1.3 값에 의한 전달

```
let test1 = 'test1';
let test2 = test1;

console.log(test1, test2); // 'test1', 'test1'

test1 = 'test3';
console.log(test1, test2); // 뭐가 출력될까요?
```

결론부터 말하자면 `'test3', 'test1'` 이 출력된다.
`test2 = test1`이 실행되면 `test2`에는 `test1`의 원시 값 `'test1'`이 복사되어 전달된다. 그러나 `test1`과 `test2`의 `'test1'`은 다른 메모리 공간에 저장된 값이다.
<br>따라서 `test1`의 변수 값을 `'test3'`로 전달해도 `test2`에는 어떤 영향도 끼치지 못한다.

> "값에 의한 전달" 또한 정확히 말하면 값이 아니라 메모리 주소를 전달한다. 이 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있는 것이다.
> <br><br> 결론: **두 변수의 원시 값은 메모리 주소가 다르기 때문에, 재할당을 통해 한쪽의 값을 변경해도 서로 간섭할 수가 없다**

## 11.2 객체

- 객체는 내부의 프로퍼티 갯수가 정해져 있지 않기 때문에, 필요한 메모리 공간의 크기도 미리 설정할 수 없다.

### 11.2.1 변경 가능한 값

> 객체는 변경 가능한 값이다.

- 객체를 할당받은 변수가 기억하는 메모리 주소로 메모리에 접근하면 참조 값, 즉, 객체가 저장된 메모리 공간의 주소 그 자체에 접근하게된다.
  => 메모리에 저장된 참조값을 통해 실제 객체에 접근한다.

- **객체는 변경 가능한 값이기 때문에, 재할당 없이 직접 변경할 수 있다. 즉, 동적인 프로퍼티의 추가, 갱신, 삭제가 가능하다.**

- 객체의 구조적 단점은 **하나의 객체를 여러 변수가 참조한다는, 그러니까 진정한 의미의 공유가 가능하다는 것이다.**

```
let obj = {
	test: 1
};
obj.test = 3;

console.log(obj); // { test: 3 }
```

- 얕은복사와 깊은복사
  객체를 프로퍼티의 값ㅇ로 가지는 객체의 경우, 얕은 복사는 한 단계 까지만 복사하는 것이고, 깊은 복사는 객체에 중첩된 객체까지 복사하는 것이다.

```
	let obj = {
	test: {test1: 2}
};

let obj2 = {...obj};
```

위 경우 `obj === obj2`는 `false`지만, `obj.test === obj2.test` 는 true가 나온다. 즉, 가장 바깥을 감싸는 객체는 복사가 되어 다른 메모리 공간을 차지하는 것이고, 내부에 프로퍼티의 값으로 중첩된 객체는 서로 같은 주소를 참조하고 있는 것이다.

### 11.2.2 참조에 의한 전달

```
let test1 = {
	test: 1
};

let test2 = test1;
```

위의 경우에서 `test1`과 `test2`는 모두 하나의 객체를 가리키고 있다. 따라서 어느 한쪽에서 객체의 프로퍼티를 추가, 변경, 삭제한다면 다른 한쪽도 그 영향을 받는다.

> 결국 "값에 의한 전달"과 "참조에 의한 전달" 모두 메모리 공간에 저장된 값을 복사해서 전달한다. 그러나 원시값의 경우 저장된 값이 원시값 그 자체가 되고, 객체값은 저장된 값이 객체가 저장된 공간의 메모리 주소, 즉, 참조값이 전달된다.

따라서 엄밀히 말하면 둘 다 값에 의한 전달이라 할 수 있으나, 그 내용물에서 차이를 보이는 것이다.

# 12장 함수

## 12.1 함수란 무엇인가?

> 함수: 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것

- 함수를 정의하는 4가지 방식

1. 함수 선언문

```
function add(a,b) {
	return a + b
}
```

2. 함수 표현식

```
const add = function(a,b){
	return a + b
}
```

3. 생성자 함수

```
const add = new Function('x', 'y', 'return x + y')
```

4. 화살표 함수

```
const add = (a,b) => {
	return a + b
}
```

## 12.2 함수의 사용 이유

> 코드의 재사용성 이라는 측면에서 매우 유리하다.

```
// 함수를 사용하지 않는다면?
// 아래같은 단순한 구구단을 사용하고 싶어도 재할당을 반복해야함
let a;
let b;
let result;

a = 1;
b = 1;
result = a * b;

a = 1;
b = 2;
result = a * b;

// 함수를 사용한다면
function multiply(a,b) {
	return a * b;
}

result = multiply(1,1);
result = multiply(1,2);
```

위의 코드처럼 함수를 사용한다면 중복 코드를 억제하고 함수를 재사용할 수 있다. 이를 통해 **유지보수의 편의성**을 높이고, 때문에 **코드의 신뢰성**은 높아진다. 또한 함수의 이름을 신중하게 지어 이름으로 그 내용을 유추할 수 있게 하면 **가독성** 또한 좋아진다.

## 12.3 함수 리터럴

> **함수 또한 객체다**

```
let f = function add(a,b) {
	return a + b;
};

```

함수 리터럴은 function 키워드, 이름, 매개변수 목록, 함수 몸체로 구성된다.

하지만 일반 객체와는 달리 호출할 수 있다는 점에서 차이를 보인다.

## 12.4 함수 선언 방식

### 12.4.1 함수 선언문

```
function add(a,b) {
	return a + b;
}
```

함수 리터럴과 형태가 동일하나, 함수 선언문에서는 이름을 생략할 수 없다.
함수 선언문은 표현식이 아닌 문이다.
그렇다면 값으로 평가되지 않는데, 다음의 코드를 보자.

```
let add = funcion add (a,b) {
	return a + b;
}; // 이를 함수 표현식이라고도 한다.
```

함수 선언문이 값으로 평가되지 않는다면 변수에도 할당할 수 없어야 하는데, 마치 그러고 있는 것처럼 보인다. 이는 자바스크립트 엔진이 문맥에 따라 함수 선언문과 함수 리터럴을 선택해 해석하고 있기 때문이다. `{}`의 경우도 마찬가지고 객체와 코드 블록 사이에서 문맥에 따라 선택한다.

- 자바스크립트 엔진은 함수를 호출하기 위해 함수 이름과 동일하게 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.

### 12.4.2 함수 표현식

> 함수 표현식: 함수 객체를 변수에 할당하는 것.

```
let add = funcion add (a,b) {
	return a + b;
};
```

- 함수 이름을 생각하는 것이 일만적이다.

### 12.4.3 함수 생성 시점과 함수 호이스팅

```
console.log(test1); // f test1()
console.log(test2); // undefined

function test1 () {
	return 3;
}

var test2 = function() {
	return 1
};
```

왜 첫째 코드는 함수를 잘 출력하지만 두번째 코드는 undefined를 발생시킬까. 이는 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 지식이 다르기 때문이다.

함수 선언문으로 만든 함수의 경우 변수와 비슷하게 **함수 호이스팅**이 발생한다. 단, 함수의 경우 곧바로 함수 객체로 초기화가 된다. 따라서 `test1`을 위에서 참조해도 undefined 를 발생시키 않는 것이다.
하지만 함수 표현식은 undefined로 먼저 초기화되므로, 런타임에 평가되기 때문에 그 시점에 함수 객체가 되고 그 전에 참조하면 undefined를 참조하는 것이다. 따라서 함수 표현식을 정의하면 함수 호이스팅이 아니라 변수 호이스팅이 발생한다.

### 12.4.4 Function 생성자 함수

> 생성자 함수는 객체를 생성하는 함수이다.

```
const add =new Function('x', 'y', 'return x + y')
```

위에서 new를 제외하도 상관은 없다. 다만 생성자 함수를 이용하는 방법을 바람직하지도 않고, 일반적이지도 않다.

### 12.4.5 화살표 함수

```
const add = (a,b) => a + b;
```

화살표 함수는 생성자 함수로 사용할 수 없고, this바인딩 또한 다르며, prototype 프로퍼티가 없고 arguments 객체를 생성하지도 않는다.

## 12.5 함수 호출

### 12.5.1 매개변수와 인수

함수 외부의 값이 필요한 경우 매개변수를 이용해 인수로 전달한다.
**매개 변수보다 인수가 적으면 그 변수는 undefined이다.** 만약 **매개 변수보다 인수가 더 많다면 나머지는 무시된다.**

### 12.5.2 인수 확인

자바스크립트는 동적 타입 언어이므로, 개발자의 의도대로 코드를 작동시키기 위해서는 인수를 사전에 확인하는 작업이 필요하다.

- typeof를 통한 type검사
- 인수가 없을 경우 단축평가 사용
- 매개변수 기본값 사용

### 12.5.3 매개변수의 최대 개수

- 매개변수는 사실 함수를 이해하는데 방해되는 요소이다.
- 또한 매개변수의 갯수가 많으면 함수가 그만큼 많은 일을 한다는 것을 의미한다.
- 따라서 매개변수는 0개가 가장 바람직하며, 최대 3개를 넘지 않는 것을 권장한다. 만약 그 이상일 경우 객체로 만들어 인수로 전달할 것을 권장한다.

### 12.5.4 반환문

> 함수는 return 키워드와 표현식으로 이뤄진 반환문을 사용해 실행 결과를 함수 외부로 반환할 수 있다.

- 반환문의 역할 2가지

1. 함수 실행을 중단하고 함수 몸체를 빠져나간다.
2. return 키워드 뒤에 오는 표현식을 반환해 평가한다.

- 반환문은 생략 가능하다. 이때 함수는 함수 몸체 마지막까지 실행 후, 암묵적으로 undefined를 반환한다.

## 12.6 참조에 의한 전달과 외부 상태의 변경

```
// 매개변수 primitive는 원시 값을 전달받고, 매개변수 obj는 객체를 전달받는다.
function changeVal(primitive, obj) {
  primitive += 100;
  obj.name = 'Kim';
}

// 외부 상태
var num = 100;
var person = { name: 'Lee' };

console.log(num); // 100
console.log(person); // {name: "Lee"}

// 원시 값은 값 자체가 복사되어 전달되고 객체는 참조 값이 복사되어 전달된다.
changeVal(num, person);

// 원시 값은 원본이 훼손되지 않는다.
console.log(num); // 100

// 객체는 원본이 훼손된다.
console.log(person); // {name: "Kim"}
```

이처럼 함수가 외부 상태를 변경하면 상태 변화를 추적하기가 어렵다. 이는 코드의 복잡성을 증가시키고 가독성을 해치는 원인이 된다. 상태 변화를 감지하기 위해서는 함수 내부를 유심히 봐야하기 때문이다.

## 12.7 다양한 함수의 형태

### 12.7.1 즉시 실행 함수

> 단 한번만 실행되며, 다시 호출할 수 없다.

```
let test = 12;
(function foo() {
  test = 15;
  var a = 3;
  var b = 5;
  return a * b;
}());

console.log(test); // 15
```

- 대체로 익명 함수를 사용한다.

- 반드시 그룹 연산자()로 감싸야 한다. 함수 리터럴을 평가해서 **함수 객체를 생성해야 하기 때문이다**

- 만약 함수 리터럴을 평가해 함수 객체를 생성할 수 있다면 다른 방법을 사용해도 된다.

```
(function () {
  // ...
})();

!function () {
  // ...
}();

+function () {
  // ...
}();
```

- 즉시 실행 함수도 일반 함수처럼 값을 반환하거나 인수를 전달할 수 있다.

```
let test = (function foo() {
  test = 15;
  var a = 3;
  var b = 5;
  return a * b;
}());

console.log(test); // 15

test = (function foo(a, b) {
  return a * b;
}(5, 3));

```

### 12.7.2 재귀 함수

> 스스로를 호출하는 함수를 재귀 함수라고 한다.

```
function countdown(n) {
  if (n < 0) return; // 탈출 조건
  console.log(n);
  countdown(n - 1); // 재귀 호출
}

countdown(10);

```

- 반복문 없이 반복 처리를 할 수 있다.
- 그러나 무한 반복에 빠져 스택 오버 플로우 에러를 발생시킬 수 있다. => 탈출 조건을 반드시 올바르게 명시해야 한다.
- 재귀함수는 반복문보다 재귀함수가 더 직관적으로 이해할 수 있을 때에만 한정적으로 사용하는 것이 바람직하다.

### 12.7.3 중첩 함수

> 중첩 함수: 함수 내부에 정의된 함수

- 보통 외부함수를 돕는 헬퍼 함수의 역할을 한다.

### 12.7.4 콜백 함수

> 콜백 함수: 다른 함수의 매개변수로 전달되는 함수
> <br> 고차 함수: 콜백함수를 인자로 받은 함수

- 고차함수는 콜백 함수의 호출 타이밍을 결정할 수 있으며, 필요시 콜백 함수에 인자를 전달해 줄 수 있다.

- 콜백 함수가 고차 함수 내부에서만 필요하다면 인자로 전달하면서 정의하는게 일반적이다. 하지만 고차 함수가 자주 호출되거나 아니면 콜백 함수를 외부에서도 사용해야 하는 경우 그냥 콜백함수를 외부에 정의해서 사용하는 편이 좋다. 고차 함수가 호출될때마다 콜백 함수 객체가 생성되기 때문이다.

```
function repeat(n, f) {
  for (var i = 0; i < n; i++) {
    f(i); // i를 전달하면서 f를 호출
  }
}

repeat(5, function (i) {
  if (i % 2) console.log(i);
}); // 1 3
```

### 12.7.5 순수함수와 비순수함수

> 순수함수: 외부 상태에 의존하지도 않고 변경하지도 않는, 부수 효과가 없는 함수 (<=> 비순수 함수)

```
function add(a,b) {
	return a + b;
}
```

- 동일 인수가 전달되면 언제나 동일한 값을 반환한다.
- 함수의 외부 상태를 변화시키지 않는다.

위의 `add`함수는 간단한 순수함수이다. 같은 인자가 전달되면 언제나 같은 값을 반환하고, 외부의 상태에 영향을 끼치지 않는다.

함수가 외부 상태를 변경하면 상태 변화 추적이 매우 어려워진다. 따라서 이를 지양하는 편이 좋다.

이렇게 순수 함수를 사용해 불변성을 지향하는 프로그래밍 패러다임이 바로 **함수형 프로그래밍**이다. 이는 반복문을 제거해서 복잡성을 해결하고, 변수 사용을 억제하거나 생명주기를 최소화해서 변경 위험성을 피한다.
<br> 즉, **부수효과를 최대한 억제해 오류를 피하고, 프로그램의 안정성을 높이려는 노력의 일환이라 할 수 있다!**

# 13장 스코프

## 13.1 스코프란 무엇인가?

> 스코프: 식별자가 유효한 범위

- 모든 식별자는 선언된 위치에 따라 다른 코드가 식별자를 참조할 수 있는 위치가 결정된다.

```
let test = 1;

function funcTest() {
	let test = 2;
	console.log(test);
}

funcTest();

console.log(test);
```

위 코드에서 funcTest의 실행 결과로 2가 출력된다. 그러나 맨 마지막 줄의 `console.log` 의 결과로는 1이 출력된다. 자바스크립트 엔진은 `console.log`가 참조하는 `test`가 둘 중 어느 변수를 참조해야할 지 결정해야하는데, 이를 **식별자 결정** 이라고 한다. 이 두 `test`는 식별자 이름은 같지만 스코프가 다른 완전히 별개의 변수이다.

또한 스코프가 같을 때 같은 이름의 식별자는 2개 이상 존재할 수 없다. 즉, 스코프별로 식별자 이름은 하나여야만 한다.(여기서 var의 문제점을 살펴볼 수 있다.)

```
// 이런거 안됨(같은 식별자)
let test = 1;
let test = 2;
```

## 13.2 스코프의 종류

코드는 크게 **전역**과 **지역**으로 나뉜다.

- 전역: 코드의 가장 바깥 영역
- 지역: 함수 몸체 내부(코드 블록 내부)

전역에서 선언한 변수는 전역 스코프를 가지고, 지역에서 선언한 변수는 지역 스코프를 가진다.

- 전역 변수는 코드 어디서든 참조할 수 있고, 지역 변수는 해당 스코프와 하위 스코프에서 참조할 수 있다.

```
let test = 1;
function funcTest() {
	console.log(test);
	let test2 = 2;
	let test = 3;
	function funcTest2() {
		console.log(test2)
		console.log(test)
	}
	funcTest2();
}
console.log(test2);
```

`funcTest`에서 전역변수 `test`를 참조해 `1`을 출력한다. 이후 `funcTest2`는 `funcTest`의 `test2`와 `test`를 참조해 `2`와 `3`을 출력한다. 코드 맨 마지막에서는 `test2`를 참조해 출력하려 하지만, 전역 스코프에서는 그 하위 스코프에 있는 test2를 참조하지 못한다.

## 13.3 스코프 체인

위의 스코프를 살펴보면 다음과 같다.

- 전역 스코프 : test funcTest
- funcTest 스코프 : test2 test funcTest2

함수는 전역, 함수 몸체 내부에서 정의될 수 있다. 함수가 다른 함수의 몸체에서 정의된 경우 함수의 중첩이라고 하며, 내부에서 정의된 함수를 중첩 함수, 중첩 함수를 포함하는 함수를 외부 함수 라고 한다.

함수가 중첩될 수 있다는 것은 함수가 가진 스코프 또한 중첩될 수 있다는 것이다. 즉, **스코프는 함수에 의해 계층적인 구조를 가진다.**

모든 스코프는 하나의 계층적인 구조로 연결되며, 전역 스코프가 최상위 스코프로 위치한다. 이렇게 스코프가 하나로 연결된 것을 **스코프 체인** 이라고 하며, 변수를 참조할 때 본인의 스코프로 시작해서 상위의 스코프로 이동하며 변수를 검색한다.

### 13.4 함수 레벨 스코프

> 함수에 의해서만 지역 스코프가 생성되는 것을 말한다.

```
var test = 1;

if (true) {
	var test = 10;
}

console.log(test); // 10
```

var 키워드로 선언된 변수는 오직 함수 코드 블록을 스코프로 인정한다. 따라서 if문에서 선언한 변수가 중복선언 되어 재할당 되었다.
이러한 방식은 의도치 않은 재할당, 가독성 저하 등의 문제점이 많다. 이러한 문제들을 보완하기 위해 ES6에서 새롭게 let, const의 키워드가 도입되었다.

### 13.5 렉시컬 스코프

- 자바스크립트는 **함수를 어디서 호출했는지가 아닌, 어디서 정의했느냐를 기억한다.** 이를 따라서 상위 스코프를 결정하는데, 이를 **렉시컬 스코프**라고 한다.

```
let test = 1;
function func() {
	let test = 2;
	func2()
}

function func2() {
	console.log(test);
}

func();
func2();

```

# 14장 전역변수의 문제점

## 14.1 변수의 생명 주기

### 14.1.1 지역 변수의 생명 주기

- 변수도 생성과 소멸되는 주기가 있다. 주기가 없다면 영원히 메모리 공간을 차지할 것.
- 지역 변수는 함수가 호출되면 생성되고 종료하면 소멸한다.
- 즉, 변수의 생명 주기 = 함수의 생명 주기 이며, 메모리 공간이 확보부터 해제되어 가용 메모리 풀에 반환되는 시점까지 이다.

### 14.1.2 전역 변수의 생명 주기

- var로 선언한 변수는 전역 객체의 프로퍼티가 된다. 즉, var로 선언한 전역 변수 수명 = 전역 객체의 수명 => 브라우저 환경에서 웹 페이지를 닫기 전까지 유효하다.

## 14.2 전역 변수의 문제점

### 암묵적 결합

> 모든 코드가 전역 변수를 참조하고 변경할 수 있는 것 => 가독성은 낮아지고, 의도치 않은 상태변경 위험성 높아짐

### 긴 생명주기

> 메모리 리소스를 오랜기간 소비 => 변수 상태 변경 가능성 높아짐

### 스코프 체인의 맨 마지막

> 전역 변수의 검색 속도가 느림

### 네임 스페이스 오염

> 같은 스코프에서 동일한 이름을 가지고 있을 경우 문제가 발생

## 14.3 전역 변수의 사용을 억제하는 방법

> 가장 좋은 방법은 지역변수를 사용하는 것

### 즉시 실행 함수

모든 코드를 즉시 실행 함수로 감싸 모든 변수를 지역 변수로 만드는 방법

### 네임스페이스 객체

> 네임스페이스 역할의 객체를 만들고, 변수를 프로퍼티로 추가하는 방법

```
const nameObj = {} // 네임 스페이스 객체
nameObj.name = 'do'
```

### 모듈 패턴

> 관련있는 변수와 함수를 즉시 실행 함수로 감싸 모듈을 만드는 것.

- 전역 변수 억제 및 캡슐화까지 구현

```
var Counter = (function () {
  // private 변수
  var num = 0;

  // 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환한다.
  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    }
  };
}());

// private 변수는 외부로 노출되지 않는다.
console.log(Counter.num); // undefined

console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
console.log(Counter.decrease()); // 0
```

### ES6 모듈

> ES6모듈을 사용하면 전역 변수를 사용할 수 없다.
> script태그에 `type=module`을 추가하면 로드된 자바스크립트 파일은 모듈로 작동한다. 확장자는 `mjs`를 추천한다.

# 15장 let, const 키워드와 블록 레벨 스코프

## 15.1 var 키워드로 선언한 변수의 문제점

### 변수의 중복 선언 허용

> var로 선언한 변수는 같은 스코프에서 중복 선언이 가능하다.

### 함수 레벨 스코프

> var로 선언한 변수는 함수레벨 스코프를 가진다. 즉, 코드 블록 내에서 선언했어도 전역 변수가 된다.

### 변수 호이스팅

> var로 선언한 변수는 변수 선언문 이전에 참조할 수 있다.(단, 언제나 undefined이다.)

## 15.2 let 키워드

var의 단점을 보완하기 위해 ES6에서 let과 const 키워드가 도입되었다.

### 변수 중복 선언 금지

> let 키워드로 선언한 변수의 경우 같은 스코프에서 변수의 중복 선언이 금지된다. 만약 중복해서 선언하면 문법 에러가 발생한다.

### 블록 레벨 스코프

> let 키워드로 선언한 변수는 블록 레벨 스코프를 가진다. 따라서 모든 코드 블록을 지역 스코프로 인정한다.

### 변수 호이스팅

> let 키워드로 선연한 변수는 선언과 초기화가 분리되어 진행된다. 변수 선언문에 도달하면 초기화가 진행된다. 이때, 스코프 최상단에서 선언문에 이르기까지의 구역을 TDZ라고 부른다.

### 전역 객체와 let

> let 키워드로 선언한 변수는 전역 객체의 프로퍼티가 아니다. 렉시컬 환경의 선언적 환경 레코드 내에 존재하게 된다.

## 15.3 const 키워드

const 키워드는 상수를 선언하기 위해 사용한다.

### 선언과 초기화

> const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.
> let 과 마찬가지로 블록레벨 스코프를 가지며, 호이스팅이 발생하지 않는 것처럼 작동한다.

### 재할당 금지

> const 키워드로 선언한 변수는 재할당이 금지된다.

### 상수

> const 키워드로 선언한 변수에 원시값을 할당하면 할당된 값을 변경할 수 없다.

일반적으로 상수 이름은 대문자로 선언한다.

### 객체

> const 키워드로 선언된 변수에 객체가 할당되면 값을 변경할 수 있다.
> 객체는 재할당 없이도 직접 변경이 가능하기 떄문이다.

## 15.4 var vs let vs const

변수 선언엔 기본적으로 const를 선언하고, let은 재할당이 필요한 경우에 한정해서 사용한다.

- ES6의 경우 var는 사용하지 말자
- 재할당이 필요하면 let을 사용하고, 스코프를 최대한 좁게 만든다.
- 읽기 전용의 원시 값과 객체에는 const를 선언한다.

단, 변수 선언 시점에는 재할당이 필요한가를 잘 모르는 경우가 많다. 따라서 일단 const를 사용한 후, 후에 재할당이 필요하다면 let으로 변경한다.

# 16장 프로퍼티 어트리뷰트

## 16.1 내부 슬롯과 내부 메서드

> 내부 슬롯과 내부 메서드는 JS엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사 메서드다.

=> ECMAScript 사양에서 이중 대괄호로 감싼 이름들이 이에 해당한다.

- 실제로 엔진에서 동작 하지만 개발자가 직접 접근할 수 있는 프로퍼티는 아님

- 그러나 몇몇 내부 슬롯과 메서드는 간접적 접근이 가능함([[prototype]]에 접근하는 `__proto __` 등)

## 16.2 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

> JS엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.

- 프로퍼티 상태: 프로퍼티 값, 값 갱신 가능 여부, 열거 가능 여부, 재정의 가능 여부

- 프로퍼티 어트리뷰트는 내부 슬롯[[value]], [[Writable]], [[Enumerable]], [[Configurable]] 이다.

- 여기에 직접 접근은 불가능하지만, `Object.getOwnProppertyDescriptor` 메서드로 간접 확인은 가능하다.
  => 첫번째 매개변수에는 객체의 참조, 두번째 매개변수에는 프로퍼티 키를 문자열로 전달한다. 리턴값은 **프로퍼티 디스크립터 객체** 이다. (없는 키 혹은 상속받은 프로퍼티에 대한 프로퍼티 디스크립터를 요구하면 undefined를 반환한다.)

```
const obj = {
    test: 1
}

Object.getOwnPropertyDescriptor(obj, "test");
/*
{
  value: 1,
  writable: true,
  enumerable: true,
  configurable: true
}
 */
```

## 16.3 데이터 프로퍼티와 접근자 프로퍼티

- 프로퍼티의 구분

1. 데이터 프로퍼티: 키와 값으로 구성된 일반적인 프로퍼티
2. 접근자 프로퍼티: 자체적인 값이 없고, 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티

### 16.3.1 데이터 프로퍼티

- JS엔진이 프로퍼티를 생성할 때 기본값으로 자동 정의되는 어트리뷰트

| 프로퍼티 어트리뷰트 | 프로퍼티 디스크립터 객체의 프로퍼티 | 설명                                                                                                                                                  |
| ------------------- | ----------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| [[value]]           | value                               | 키를 통해 값에 접근하면 반환됨. 값을 변경하면 [[Value]]에 값을 재할당. 프로퍼티가 없으면 동적 생성하고 생성된 프로퍼티의 [[Value]]에 값을 저장        |
| [[Writable]]        | writable                            | 값의 변경 여부를 나타냄(불리언 값). false인 경우 [[Value]]의 값을 변경 불가능한 읽기 전용 프로퍼티가 됨                                               |
| [[Enumerable]]      | enumerable                          | 열겨 가능 여부(불리언 값). false인 경우 `for...in`이나`Object.key`등으로 열거가 불가능해짐                                                            |
| [[Configurable]]    | configurable                        | 재정의 가능 여부(불리언 값) false인 경우 삭제, 변경이 금지된다. 단, [[Writable]]이 true면 [[Value]]의 변경과 [[Writable]]을 false로 바꾸는것은 허용됨 |

### 16.3.2 접근자 프로퍼티

- 자체적으로 값을 가지는 것이 아니라, 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 이루어진 프로퍼티

| 프로퍼티 어트리뷰트 | 프로퍼티 디스크립터 객체의 프로퍼티 | 설명                                                                                                                                                          |
| ------------------- | ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [[Get]]             | value                               | 접근자 프로퍼티를 통해 값을 읽을 때 호출되는 접근자 함수. 프로퍼티 키로 값에 접근 하면 [[Get]]의 값 getter함수가 호출되고, 결과가 프로퍼티 값으로 반환된다.   |
| [[Set]]             | writable                            | 접근자 프로퍼티를 통해 값을 저장할 때 호출되는 접근자 함수. 프로퍼티 키로 값을 저장 하면 [[Set]]의 값 Setter함수가 호출되고, 결과가 프로퍼티 값으로 반환된다. |
| [[Enumerable]]      | enumerable                          | 데이터 프로퍼티하고 똑같아욥                                                                                                                                  |
| [[Configurable]]    | configurable                        | 데이터 프로퍼티하고 똑같아욥                                                                                                                                  |

### 16.3.3 Get 메서드 동작 방식

1. 프로퍼티 키가 유효한지 확인(심볼 or 문자열).
2. 프로토타입 체인에서 프로퍼티 검색
3. 검색된 프로퍼티가 데이터 프로퍼티인지 접근자 프로퍼티인지 확인한다.
4. 접근자 프로퍼티라면 getter or setter 함수를 호출 해 결과를 반환한다.

## 16.4 프로퍼티 정의

> 새로운 프로퍼티를 정의하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거ㅏㄴ, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것

Object.defineProperty를 통해 프로퍼티의 어트리뷰트를 정의할 수 있다.

```
const person = {};

Object.defineProperty(person, 'firstName', {
	value: '성',
	writable: true,
	enumerable: true,
	configurable: true
})

```

| 프로퍼티 어트리뷰트 | 프로퍼티 디스크립터 객체의 프로퍼티 | 생략 시 기본값 |
| ------------------- | ----------------------------------- | -------------- |
| [[Value]]           | value                               | undefined      |
| [[Get]]             | writable                            | undefined      |
| [[Set]]             | enumerable                          | undefined      |
| [[Writable]]        | configurable                        | false          |
| [[Enumerable]]      | enumerable                          | false          |
| [[Configurable]]    | configurable                        | false          |

Object.defineProperties를 이용하면 여러개의 프로퍼티를 한번에 정의할 수 있다.

```
const person = {};

Object.defineProperties(person, {
  // 데이터 프로퍼티 정의
  firstName: {
    value: 'Ungmo',
    writable: true,
    enumerable: true,
    configurable: true
  },
  lastName: {
    value: 'Lee',
    writable: true,
    enumerable: true,
    configurable: true
  },
  // 접근자 프로퍼티 정의
  fullName: {
    // getter 함수
    get() {
      return `${this.firstName} ${this.lastName}`;
    },
    // setter 함수
    set(name) {
      [this.firstName, this.lastName] = name.split(' ');
    },
    enumerable: true,
    configurable: true
  }
});
```

## 16.5 객체 변경 방지

객체는 재할당 없이 직접 변경할 수 있다. 자바스크립트는 이러한 변경을 방지하는 다양한 메서드를 제공한다.
[프로퍼티 추가, 프로퍼티 삭제, 프로퍼티 값 읽기, 프로퍼티 값 쓰기, 프로퍼티 어트리뷰트 재정의]

- Object.preventExtensions - 객체 확장 금지: 프로퍼티 추가 x
- Object.seal - 객체 밀봉: 프로퍼티 추가, 삭제, 재정의 x
- Object.freeze - 객체 동결: 프로퍼티 값 읽기만 가능

### 16.5.1 Object.preventExtensions

> 확장 금지 = 프로퍼티 추가 금지

확장 가능 여부는 Object.isExtensible 메서드로 확인 가능

### 16.5.2 Object.seal

> 밀봉 = 읽기와 쓰기만 가능

밀봉 여부는 Object.isSealed 메서드로 확인 가능

### 16.5.3 Object.freeze

> 동결 = 읽기만 가능

동결 여부는 Object.isFrozen 메서드로 확인 가능

### 16.5.4 불변 객체

위의 방식들은 얕은 변경 방지이기 때문에 중첩 객체에 대해서는 적용이 되지 않는다. 중첩 객체도 변경이 불가능하도록 만드려면 재귀적으로 Object.freeze 메서드를 호출해야 한다.

```
function deepFreeze(target) {
  // 객체가 아니거나 동결된 객체는 무시하고 객체이고 동결되지 않은 객체만 동결한다.
  if (target && typeof target === 'object' && !Object.isFrozen(target)) {
    Object.freeze(target);
    /*
      모든 프로퍼티를 순회하며 재귀적으로 동결한다.
      Object.keys 메서드는 객체 자신의 열거 가능한 프로퍼티 키를 배열로 반환한다.
      ("19.15.2. Object.keys/values/entries 메서드" 참고)
      forEach 메서드는 배열을 순회하며 배열의 각 요소에 대하여 콜백 함수를 실행한다.
      ("27.9.2. Array.prototype.forEach" 참고)
    */
    Object.keys(target).forEach(key => deepFreeze(target[key]));
  }
  return target;
}

const person = {
  name: 'Lee',
  address: { city: 'Seoul' }
};

// 깊은 객체 동결
deepFreeze(person);

console.log(Object.isFrozen(person)); // true
// 중첩 객체까지 동결한다.
console.log(Object.isFrozen(person.address)); // true

person.address.city = 'Busan';
console.log(person); // {name: "Lee", address: {city: "Seoul"}}
```

# 17장 생성자 함수에 의한 객체 생성

## 17.1 Object 생성자 함수

> new 키워드와 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다. 이후 프로퍼티, 메서드를 추가하여 객체를 완성할 수 있다.

```
// 빈 객체의 생성
const person = new Object();

// 프로퍼티 추가
person.name = 'Lee';
person.sayHello = function () {
  console.log('Hi! My name is ' + this.name);
};

console.log(person); // {name: "Lee", sayHello: ƒ}
person.sayHello(); // Hi! My name is Lee
```

- **생성자 함수**란 new 연산자와 함께 호출해 객체를 생성하는 함수를 말한다. 이 방법으로 만들어진 객체를 인스턴스라고 한다.

객체 리터럴을 사용하는 방식이 더 간단하기는 한데...?

## 17.2 생성자 함수

### 17.2.1 객체 리터럴에 의한 객체 생성 방식의 문제점

동일한 프로퍼티를 갖는 객체를 여러개 생성해야 할 경우 매번 같은 프로퍼티를 기술해야 하기 떄문에 비효율적이다.

```
const circle1 = {
  radius: 5,
  getDiameter() {
    return 2 * this.radius;
  }
};

console.log(circle1.getDiameter()); // 10

const circle2 = {
  radius: 10,
  getDiameter() {
    return 2 * this.radius;
  }
};

console.log(circle2.getDiameter()); // 20
```

### 17.2.2 생성자 함수 방식에 의한 객체 생성의 장점

프로퍼티 구조가 비슷한 여러개의 객체를 간편하게 생성할 수 있다.

```
function Circle(radius) {
  // 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}

// 인스턴스의 생성
const circle1 = new Circle(5);  // 반지름이 5인 Circle 객체를 생성
const circle2 = new Circle(10); // 반지름이 10인 Circle 객체를 생성

console.log(circle1.getDiameter()); // 10
console.log(circle2.getDiameter()); // 20
```

만약 new 연산자를 동반하지 않으면 일반 함수로 작동한다.

```
const circle3 = Circle(15);
console.log(circle3); // undefined
```

## 17.2.3 생성자 함수의 인스턴스 생성 과정

- 생성자 함수의 역할: 템플릿으로 작동해서 인스터스를 생성(필수). 생성된 인스턴스를 초기화(옵션)

#### 1. 인스턴스 생성과 this 바인딩

암묵적으로 빈 객체가 생성된다. 인스턴스는 this에 바인딩된다. 이 처리는 런타임 이전에 실행된다.

#### 2. 인스턴스 초기화

코드가 한줄씩 실행되어 this에 바인딩 된 인스턴스를 초기화한다. 즉, tihs에 바인딩 된 인스턴스에 프로퍼티, 메서드를 추가하고, 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값을 할당한다.

#### 3. 인스턴스 반환

내부의 처리가 모두 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다. 만약 다른 객체를 명시적으로 리턴한다면 그 객체가 반환된다.

### 17.2.4 내부 메서드 [[Call]]과 [[Construct]]

함수는 객체이므로 일반 객체와 동일하게 동작할 수 있다. 허나 일반 객체와는 다르다. 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다. 따라서 일반 객체가 가진 내부 슬롯, 내부 메서드에 더불어 함수 객체만을 위한 내부 슬롯과 메서드를 추가로 가지고 있다. 함수가 호출되면 내부 메서드 [[Call]]이 호출되고, new 연산자와 함께 생성자 함수로 호출되면 [[Construct]]가 호출된다.

[[Call]]을 가지는 함수 객체를 callable, [[Construct]]를 가지는 함수 객체를 constructor, 그렇지 않은 함수 객체를 non-constructor 라고 부른다. 함수 객체는 반드시 callable이어야 한다. 하지만 반드시 constructor일 필요는 없다.

### 17.2.5 constructor 와 non-constructor의 구분

- constructor: 함수 선언문, 함수 표현식, 클래스
- non-constructor: 메서드, 화살표 함수

그러나 ECMAScript에서는 메서드는 ES6의 메서드 축약 표현만을 의미한다. 즉, 함수 선언문과 함수 표현식으로 정의된 함수만 constructor이고, ES6의 화살표 함수와 축약 표현으로 정의된 함수는 non-constructor이다.

### 17.2.6 new 연산자

사실 생성자 함수와 일반 함수에 특별한 형식적 차이는 없다. 단, new 연산자와 함께 사용하면 [[Call]]이 아니라 [[Constructor]]가 호출된다. 말했듯 형식적 차이가 없으므로 파스칼 케이스를 사용해서 일반 함수와 표기를 구분하는 것이 좋다.

### 17.2.7 new.target

new 없이 생성자 함수를 사용하는 것을 막기 위해 ES6에서 new.target을 도입했다. 메타 프로퍼티라고 불리며 함수 내부에서 사용 시 생성자 함수로 사용되었는지 호출할 수 있다.

- new와 함께 호출 시: new.target은 함수 자신
- new 없이 호출: new.target은 undefined

Object와 Function 생성자 함수는 new 없이 호출해도 동일하게 작동한다. 하지만 String, Number, Boolean은 타입을 변환한다.

# 18장 함수와 일급 객체

## 18.1 일급 객체

다음의 조건을 만족하면 일급 객체라고 한다.

> - 무명의 리터럴로 생성 가능

- 변수나 자료구조에 저장 가능
- 함수의 매개변수에 전달가능
- 함수의 반환값으로 사용 가능

함수가 일급객체라는 뜻은 객체와 동일하게 사용할 수 있다는 의미이다. 따라서 함수는 값을 사용하는 곳이라면 어디서든지 리터럴로 정의할 수 있으며, 런타임에 함수 객체로 평가된다. **함수가 일급 객체로 가지는 가장 큰 특징은 매개변수에 전달할 수 있으며 함수의 반환값으로 사용이 가능하다는 것이다.**
그러나 일반 객체는 호출이 불가능하지만 함수 객체는 호출이 가능하다는 점, 함수 객체는 고유의 프로퍼티를 소유한다는 점(프로퍼티 어트리뷰트 참고)의 차이점이 있다.

## 18.2 함수 객체의 프로퍼티

### 18.2.1 arguments 프로퍼티

> 함수 객체의 arguments프로퍼티의 값은 arguments 객체이다.

- arguments 객체는 전달받은 인수를 담고 있는 순회 가능한 유사 배열 객체이며, 함수 내부에서 지역 변수에서 사용된다.
- ES3에서 arguments 프로퍼티는 폐지되었다.
- 자바스크립트는 함수의 매개변수와 인수의 개수가 일치하는지 확인하지 않는다. 따라서 함수 호출 시 개수만큼 인수를 전달하지 않아도 오류가 나지 않는다.
- 초과된 인수는 무시되는데, 그냥 버려지는 것은 아니다. 암묵적으로 arguments 객체의 프로퍼티로 보관된다.
- arguments 객체는 인수를 프로퍼티 값으로 소유하며, 프로퍼티 키는 인수의 순서이다. calle 프로퍼티는 함수 자신이고, length프로퍼티는 인수의 개수이다.
- 함수 호출 시 인수 개수를 확인하고 동작을 달리할 수 있는데, 이때 유용하게 사용하는 것이 arguments 객체이다. 가변 인자 함수를 구현할 때 유용하다.

```
function sum() {
  let res = 0;

  // arguments 객체는 length 프로퍼티가 있는 유사 배열 객체이므로 for 문으로 순회할 수 있다.
  for (let i = 0; i < arguments.length; i++) {
    res += arguments[i];
  }

  return res;
}

console.log(sum());        // 0
console.log(sum(1, 2));    // 3
console.log(sum(1, 2, 3)); // 6
```

- arguments 객체는 유사배열객체이다. 따라서 배열로 변환하고 배열메서드를 사용해야하는 번거로움이 있는데, 이를 해결하기 위해 ES6에서 Rest 파라미터를 도입했다.

```
function sum(...args) {
  return args.reduce((pre, cur) => pre + cur, 0);
}

console.log(sum(1, 2));          // 3
console.log(sum(1, 2, 3, 4, 5)); // 15
```

### 18.2.2 caller 프로퍼티

> ECMAScript에 포함되지 않은 비표준 프로퍼티이다. caller 프로퍼티는 함수 자신을 호출한 함수를 가리킨다.

### 18.2.3 length 프로퍼티

> 함수를 정의할 때 선언한 매개변수의 개수를 가리킨다.

단, arguments 객체의 length 프로퍼티(인자의 개수)와 함수 객체의 length 프로퍼티의 값이 다를 수 있으므로 주의한다.

### 18.2.4 name 프로퍼티

> 함수의 이름을 나타낸다.

단, ES5에서는 익명 함수 표현식의 경우 빈 문자열을, ES6에서는 함수 객체를 가리키는 식별자를 값으로 가진다.

```
// 기명 함수 표현식
var namedFunc = function foo() {};
console.log(namedFunc.name); // foo

// 익명 함수 표현식
var anonymousFunc = function() {};
// ES5: name 프로퍼티는 빈 문자열을 값으로 갖는다.
// ES6: name 프로퍼티는 함수 객체를 가리키는 변수 이름을 값으로 갖는다.
console.log(anonymousFunc.name); // anonymousFunc

// 함수 선언문(Function declaration)
function bar() {}
console.log(bar.name); // bar
```

### 18.2.5 `__proto__` 접근자 프로퍼티

> 모든 객체는 [[Prototype]]이라는 내부 슬롯을 가진다. 이는 프로토 타입 객체를 가리킨다. `__proto__` 프로퍼티는 [[Prototype]]내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위한 접근자 프로퍼티이다.

```
const obj = { a: 1 };

// 객체 리터럴 방식으로 생성한 객체의 프로토타입 객체는 Object.prototype이다.
console.log(obj.__proto__ === Object.prototype); // true

// 객체 리터럴 방식으로 생성한 객체는 프로토타입 객체인 Object.prototype의 프로퍼티를 상속받는다.
// hasOwnProperty 메서드는 Object.prototype의 메서드다.
console.log(obj.hasOwnProperty('a'));         // true
console.log(obj.hasOwnProperty('__proto__')); // false
```

### 18.2.6 prototype 프로퍼티

> 생성자 함수로 호출할 수 있는 함수 객체, 즉, constructor만이 소유하는 프로퍼티이다.

```
// 함수 객체는 prototype 프로퍼티를 소유한다.
(function () {}).hasOwnProperty('prototype'); // -> true

// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.
({}).hasOwnProperty('prototype'); // -> false
```

함수가 객체를 생성하는 생성자 함수로 호출될 때 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다.

# 19장 프로토타입

> **자바스크립트는 멀티 패러다임(명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍) 프로그래밍 언어이다.**

자바스크립트는 객체 기반 프로그래밍 언어이며 **자바스크립트를 이루고 있는 거의 "모든 것'이 객체이다.** 원시 값을 제외한 나머지 값들은 모두 객체이다.

## 19.1 객체지향 프로그래밍

> 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임

- 객체지향 프로그래밍에서 실체는 특성이나 성질을 나타내는 속성을 지니고 있고, 이를 통해 실체를 인식하거나 구분할 수 있다. (사람 - 나이, 이름, 주소, 성별 등)

```
const person = {
  name: 'Lee',
  address: 'Seoul'
};

console.log(person); // {name: "Lee", address: "Seoul"}
```

- 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복잡한 자료구조를 객체라고 하며, 객체지향 프로그래밍은 독립적인 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임이다.

- 객체지향 프로그래밍에서는 객체의 상태를 나타내는 데이터와 상태 데이터를 조작할 수 있는 동작을 하나의 논리적인 단위로 묶어 생각한다. 이때 이 상태를 프로퍼티, 동작을 메서드라고 부른다.

```
const circle = {
  radius: 5, // 반지름

  // 원의 지름: 2r
  getDiameter() {
    return 2 * this.radius;
  },

  // 원의 둘레: 2πr
  getPerimeter() {
    return 2 * Math.PI * this.radius;
  },

  // 원의 넓이: πrr
  getArea() {
    return Math.PI * this.radius ** 2;
  }
};

console.log(circle);
// {radius: 5, getDiameter: ƒ, getPerimeter: ƒ, getArea: ƒ}

console.log(circle.getDiameter());  // 10
console.log(circle.getPerimeter()); // 31.41592653589793
console.log(circle.getArea());      // 78.53981633974483
```

## 19.2 상속과 프로토타입

> 상속: 어떤 객체의 프로퍼티, 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것

자바스크립트는 프로토타입을 기반으로 상속을 구현해 불필요한 중복을 제거한다(코드의 재사용).

```
// 생성자 함수
function Circle(radius) {
  this.radius = radius;
}

// Circle 생성자 함수가 생성한 모든 인스턴스가 getArea 메서드를
// 공유해서 사용할 수 있도록 프로토타입에 추가한다.
// 프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩되어 있다.
Circle.prototype.getArea = function () {
  return Math.PI * this.radius ** 2;
};

// 인스턴스 생성
const circle1 = new Circle(1);
const circle2 = new Circle(2);

// Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체의 역할을 하는
// 프로토타입 Circle.prototype으로부터 getArea 메서드를 상속받는다.
// 즉, Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메서드를 공유한다.
console.log(circle1.getArea === circle2.getArea); // true

console.log(circle1.getArea()); // 3.141592653589793
console.log(circle2.getArea()); // 12.566370614359172

```

아래의 생성자함수는 인스턴스가 생성될때마다 getArea 메서드가 중복 생성된다는 문제가 있다

```
function Circle(radius) {
  this.radius = radius;
  this.getArea = function () {
    // Math.PI는 원주율을 나타내는 상수다.
    return Math.PI * this.radius ** 2;
  };
}
```

## 19.3 프로토타입 객체

프로토타입 객체(이하 프로토타입)은 객체 간 상속을 구현하기 위해 사용된다. 프로토타입은 어떤 객체의 부모역할을 하는 개체로써 다른 객체에 공유 프로퍼티를 제공한다.

모든 객체는 [[Prototype]]이라는 내부 슬롯을 가지며, 이 내부 슬롯의 값은 프로토타입의 참조이다. 여기에 저장되는 값은 객체 생성 방식에 의해 결정된다. 즉, 객체 생성 방식에 따라 프로토타입이 결정되고 [[Prototype]]에 저장되는 것이다. **모든 객체는 하나의 프로토타입을 가진다.** 그리고 모든 프로토타입은 생성자 함수와 연결되어 있다.

- [[Prototype]]내부 슬롯은 직접 접근이 불가능하고, `__proto__` 접근자 프로퍼티를 통해 [[Prototype]]내부 슬롯이 참조하는 프로토타입에 간접 접근할 수 있다. 그리고 프로토타입은 constructor 프로퍼티를 통해 생성자 함수에 접근할 수 있고, 생성자 함수는 자신의 prototype 프로퍼티를 통해 프로토타입에 접근할 수 있다.

### 19.3.1 `__proto__`접근자 프로퍼티

> 모든 객체는 `__proto__`접근자 프로퍼티를 통해 자신의 프로토타입, [[Prototype]] 내부 슬롯에 간접 접근할 수 있다.

> `__proto__`는 접근자 프로퍼티다.

내부 슬롯은 프로퍼티가 아니기 때문에, 직접적으로 접근할 방법이 제공되지 않는다. 다만, 일부에 한하여 간접 접근할 방법을 제공한다. [[Prototype]]에 간접 접근할 방법이 `__proto__`인 것이다.

`__proto__`는 getter/setter 함수라고 부르는 접근자 함수를 통해 프로토타입을 취득하거나 할당한다.

> `__proto__` 접근자 프로퍼티는 상속을 통해 사용된다.

`__proto__` 접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 Object.prototype의 프로퍼티이다. 모든 객체는 상속을 통해 `Object.prototype.__proto__` 접근자 프로퍼티를 사용할 수 있다.

```
const person = { name: 'Lee' };

// person 객체는 __proto__ 프로퍼티를 소유하지 않는다.
console.log(person.hasOwnProperty('__proto__')); // false

// __proto__ 프로퍼티는 모든 객체의 프로토타입 객체인 Object.prototype의 접근자 프로퍼티다.
console.log(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__'));
// {get: ƒ, set: ƒ, enumerable: false, configurable: true}

// 모든 객체는 Object.prototype의 접근자 프로퍼티 __proto__를 상속받아 사용할 수 있다.
console.log({}.__proto__ === Object.prototype); // true
```

> `__proto__`접근자 프로퍼티를 통해 프로토타입에 접근하는 이유

**상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해서다.**

```
const parent = {};
const child = {};

// child의 프로토타입을 parent로 설정
child.__proto__ = parent;
// parent의 프로토타입을 child로 설정
parent.__proto__ = child; // TypeError: Cyclic __proto__ value
```

위의 경우 parent가 child의 프로토타입이 되고, child가 parent의 프로토타입이 되는, 서로가 서로의 프로토타입이 되는 비정상적인 상황이 되기 때문에 에러를 발생시킨다.<br/>
프로토타입 체인은 단방향 링크드 리스트로 구현되어야 한다. 즉, 프로퍼티 검생이 한쪽 방향으로만 흘러가야 하는 것이다. 따라서 아무런 체크 없이 무조건적으로 프로토타입을 교체할 수 없도록 접근자 프로퍼티를 통해 프로토타입에 접근하고 교체하도록 구현되어있다.

> `__proto__` 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 권장하지 않는다.

모든 객체가 `__proto__`접근자 프로퍼티를 사용할 수 있는 것은 아니기 때문이다.

```
// obj는 프로토타입 체인의 종점이다. 따라서 Object.__proto__를 상속받을 수 없다.
const obj = Object.create(null);

// obj는 Object.__proto__를 상속받을 수 없다.
console.log(obj.__proto__); // undefined

// 따라서 __proto__보다 Object.getPrototypeOf 메서드를 사용하는 편이 좋다.
console.log(Object.getPrototypeOf(obj)); // null
```

`__proto__`접근자 프로퍼티 대신 프로토타입의 참조를 취득하고 싶은 경우, Object.getPrototypeof 메서드를 사용하고, 프로토타입을 교차하고 싶으면 Object.setPrototypeof 메서드를 사용하는 것을 권장한다.

### 19.3.2 함수 객체의 prototype 프로퍼티

> 함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.

```
// 함수 객체는 prototype 프로퍼티를 소유한다.
(function () {}).hasOwnProperty('prototype'); // -> true

// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.
({}).hasOwnProperty('prototype'); // -> false
```

따라서 생성자 함수로 호출할 수 없는 함수(화살표 함수, ES6의 메서드 축약 표현으로 정의한 메서드)는 prototype 프로퍼티를 쇼유하지 않으며 프로토타입도 생성하지 않는다.

모든 객체가 가지고 있는 `__proto__` 접근자 프로퍼티와 햄수 객체만 가지는 prototype프로퍼티는 결국 동일한 프로토타입을 가리킨다.

| 구분        | 소유        | 값                | 사용 주체   | 사용 목적                                                          |
| ----------- | ----------- | ----------------- | ----------- | ------------------------------------------------------------------ |
| `__proto__` | 모든 객체   | 프로토타입의 참조 | 모든 객체   | 객체가 자신의 프로토타입에 접근, 혹은 교체                         |
| prototype   | constructor | 프로토타입의 참조 | 생성자 함수 | 생성자 함수가 자신이 생성할 객체의 프로토타입을 할당하기 위해 사용 |

```
function Person(name) {
  this.name = name;
}

const me = new Person('Lee');

// 결국 Person.prototype과 me.__proto__는 결국 동일한 프로토타입을 가리킨다.
console.log(Person.prototype === me.__proto__);  // true
```

### 19.3.3 프로토타입의 constructor 프로퍼티와 생성자 함수

> 모든 프로토타입은 constructor 프로퍼티를 가지고, constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다.

```
// 생성자 함수
function Person(name) {
  this.name = name;
}

const me = new Person('Lee');

// me 객체의 생성자 함수는 Person이다.
console.log(me.constructor === Person);  // true
```

Person 생성자 함수는 me 객체를 생성했다. 이때 me 객체는 constructor 프로퍼티를 통해 생성자 함수와 연결된다. me 객체에는 constructor 프로퍼티가 없지만 me 객체의 프로토타입인 Person.prototype에는 constructor 프로퍼티가 있다. 따라서 me 객체는 Person.prototype의 constructor 프로퍼티를 상속받아 사용할 수 있다.

## 19.4 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

리터럴 표기법으로 생성한 객체도 프로토타입이 존재한다. 하지만 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수라고 단정할 수 없다.

```
// obj 객체는 Object 생성자 함수로 생성한 객체가 아니라 객체 리터럴로 생성했다.
const obj = {};

// 하지만 obj 객체의 생성자 함수는 Object 생성자 함수다.
console.log(obj.constructor === Object); // true
```

Object 생성자 함수에 인수가 없거나 udnefined, null을 인수로 전달하면 추상 연산 OrdinaryObjectCreate를 호출하여 Object.prototype을 프로토타입으로 가지는 빈 객체를 생성한다.
객체 리터럴의 평가 시에는 OrdinaryObjectCreate를 호출하여 빈 객체를 생성하고 프로퍼티를 추가되도록 정의되어 있다.

이처럼 Object 생성자 함수 호출과 객체 리터럴의 ㅍ평가는 추상 연산 OrdinaryObjectCreate를 호출하여 빈 객체를 생성한다는 점에서는 동일하나, 세부 내용은 다르다. 따라서 객체 리터럴에 의해 생성된 객체는 Object 생성자 함수가 생성한 객체가 아니다.

> 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 쌍으로 존재한다.

리터럴 표기법에 의해 생성된 객체는 큰 틀에서 보았을 때 생성자 함수로 생성한 객체와 본질적으로 큰 차이가 없다. 따라서 프로토타입의 constructor 프로퍼티를 통해 연결되어 있는 생성자 함수를 리터럴 표기법으로 생성한 객체를 생성한 생성자 함수로 생각해도 큰 무리는 없다.

## 19.5 프로토타입의 생성 시점

> 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.

생성자 함수는 사용자 정의 생성자 함수와 빌트인 생성자 함수로 구분할 수 있다.

### 19.5.1 사용자 정의 생성자 함수와 프로토타입 생성 시점

> 생성자 함수로서 호출할 수 있는 함수, 즉 constructor는 ㅎ마수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.

```
// 함수 정의(constructor)가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.
console.log(Person.prototype); // {constructor: ƒ}

// 생성자 함수
function Person(name) {
  this.name = name;
}
```

함수 선언문은 런타임 이전 JS엔진에 의해 먼저 실행된다. 따라서 함수 선언문으로 정의돈 Person 생성자 함수는 어떤 코드보다 먼저 평가되어 함수 객체가 된다. 이때 프로토타입도 더불어 생성된다. 이 프로토타입은 Person 생성자 함수의 prototype 프로퍼티에 바인딩된다. 이 프로토타입은 오직 constructor 프로퍼티만을 가지는 객체다. 프로토타입도 객체고 모든 객체는 프로터타입을 가지므로 프로토타입도 자신의 프로토타입을 가진다. 생성된 프로토타입의 프로토타입은 Object.prototype이다.

> 사용자 정의 함수는 평가 시점에 프로토타입도 생성되며, 이 프로토타입의 프로토타입은 언제나 Object.prototype이다.

### 19.5.2 빌트인 생성자 함수와 프로토타입 생성 시점

> 빌트인 생성자 함수도 생성자 함수가 생성되는 시점에 프로토타입도 생성된다. 모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성된다. 생성된 프로토타입은 빌트인 생성자 함수의 prototype 생성자 함수에 바인딩된다.

### 결론

> 객체 생성 이전에 생성자 함수와 프로토타입은 이미 객체화되어 존재한다. 이후 생성자 함수 또는 리터럴 표기법으로 객체를 생성하면 프로토타입은 생성된 객체의 [[Prototype]]내부 슬롯에 할당된다. 이로써 생성된 객체는 프로토타입을 상속받는다.

## 19.6 객체 생성 방식과 프로토타입의 결정

모든 객체는 생성 방식에 차이가 있어도 OrdinaryObjectCreate에 의해 생성되는 공통점이 있다.OrdinaryObjectCreate는 생성할 객체의 프로토타입을 인수로 전달받는다. 이후 빈 객체를 생성하고, 프로퍼티 목록이 인수로 전달되면 이를 객체에 추가한다. 그리고 인수로 전달받은 프로토타입을 자신이 생성할 객체의 [[Prototype]] 내부 슬롯에 할당하고, 생성한 객체를 반환한다. 즉, 프로토타입은 OrdinaryObjectCreate에 전달되는 인수에 의해 결정된다. 이 인수는 객체가 생성되는 시점에 객체 생성 방식에 의해 결정된다.

### 19.6.1 객체 리터럴에 의해 생성된 객체의 프로토타입

JS엔진은 객체 리터럴을 평가해 객체를 만들 때 OrdinaryObjectCreate를 호출한다. 이때 인수는 Object.prototype을 받는다. 즉, 객체 리터럴에 의해 생성되는 객체의 프로토타입은 Object.prototype이다.
따라서 객체 리터럴에 의해 생성된 객체는 Object.prototype을 상속받는다.

```
const obj = { x: 1 };

// 객체 리터럴에 의해 생성된 obj 객체는 Object.prototype을 상속받는다.
console.log(obj.constructor === Object); // true
console.log(obj.hasOwnProperty('x'));    // true
```

### 19.6.2 생성자 함수에 의해 생성된 객체의 프로토타입

Object 생성자 함수를 호출하면 추상 연산 OrdinaryObjectCreate를 호출한다. 이때 인수는 Object.prototype을 받는다.

```
const obj = new Object();
obj.x = 1;
```

위의 코드가 실행되면 Object 생성자 함수와 Object.prototype과 생성된 객체 사이에 연결이 만들어진다. 이는 객체 리터럴에 의해 생성된 객체와 동일한 구조이다.
즉, 생성자 함수에 의해 생성된 객체 또한 Object.prototype을 프로토타입으로 가지게 되며, 이로써 Object.prototype을 상속받는다.

### 19.6.3 생성자 함수에 의해 생성된 객체의 프로토타입

마찬가지로 OrdinaryObjectCreate를 호출한다.ㅏ 단, 인수는 생성자 함수의 prototype프로퍼티에 바인딩 되어있는 객체이다.

```
function Person(name) {
  this.name = name;
}

const me = new Person('Lee');
```

Person과 더불어 생성된 Person.prototype의 프로퍼티는 constructor뿐이다. 따라서 다음과 같이 프로토타입에 프로퍼티를 추가/삭제하는 것이 가능하다.

```
function Person(name) {
  this.name = name;
}

// 프로토타입 메서드
Person.prototype.sayHello = function () {
  console.log(`Hi! My name is ${this.name}`);
};

const me = new Person('Lee');
const you = new Person('Kim');

me.sayHello();  // Hi! My name is Lee
you.sayHello(); // Hi! My name is Kim
```

## 19.7 프로토타입 체인

```
function Person(name) {
  this.name = name;
}

// 프로토타입 메서드
Person.prototype.sayHello = function () {
  console.log(`Hi! My name is ${this.name}`);
};

const me = new Person('Lee');

// hasOwnProperty는 Object.prototype의 메서드다.
console.log(me.hasOwnProperty('name')); // true
```

여기서 me객체의 프로토타입은 Person.prototype이다. 또한 프로토타입의 프로토타입은 언제나 Object.prototype이다.

```
Object.getPrototypeOf(Person.prototype) === Object.prototype; // -> true
```

> **자바스크립트는 객체의 프로퍼티에 접근하려고 할때, 찾는 프로퍼티가 해당 객체에 없으면 [[Prototype]]슬롯의 참조를 따라서 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색하며, 이를 프로토타입 체인이라고 한다.**

자바스크립트 엔진이 프로퍼티(와 메서드)를 검색하는 방법은 다음과 같다.

1. 먼저 프로퍼티(이하 메서드 포함)를 호출한 객체에서 해당 프로퍼티를 검색한다. 존재하지 않을 경우, 해당 객체의 [[Prototype]] 슬롯이 참조하는 프로토타입(A)으로 이동해 해당 프로퍼티를 검색한다.

2. A에도 해당 프로퍼티가 없을 경우 다시 A의 내부 슬롯 [[Prototype]]으로 이동하여 검색한다.

3. 해당 프로퍼티를 찾으면 자바스크립트 엔진은 이 프로퍼티를 호출한다. 만약 this 가 있다면 맨 처음의 객체가 바인딩된다.

- 프로토타입 체인의 제일 최상위 객체는 언제나 Object.prototype이다. 이는 곧 모든 객체는 Object.prototype을 상속받는다고 할 수 있다. 따라서 Object.prototype을 프로토타입 체인의 종점 이라고 한다.(Object.prototype의 [[Prototype]]의 값은 `null`이다.). ** 만약 Object.prototype에서도 프로퍼티를 찾을 수 없는 경우 에러없이 `unedefined`를 반환한다는 점에 주의하자**

* 프로토타입 체인이 **상속과 프로퍼티 검색을 위한 메커니즘**인 반면, 스코프 체인은 **식별자 검색**을 위한 메커니즘 이다. 이 둘은 서로 협력하여, 식별자와 프로퍼티를 검색하는데에 사용된다.

## 19.8 오버라이딩과 프로퍼티 섀도잉

```
const Person = (function () {
  // 생성자 함수
  function Person(name) {
    this.name = name;
  }

  // 프로토타입 메서드
  Person.prototype.sayHello = function () {
    console.log(`Hi! My name is ${this.name}`);
  };

  // 생성자 함수를 반환
  return Person;
}());

const me = new Person('Lee');

// 인스턴스 메서드
me.sayHello = function () {
  console.log(`Hey! My name is ${this.name}`);
};

// 인스턴스 메서드가 호출된다. 프로토타입 메서드는 인스턴스 메서드에 의해 가려진다.
me.sayHello(); // Hey! My name is Lee
```

프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가하면 인스턴스 프로퍼티로 추가한다. 이떄, 인스턴트 메서드는 프로토타입 메서드를 오버라이딩하고, 프로토타입 메서드는 가려진다. 이처럼 상속관계에 의해 프로퍼티가 가려지는 것을 **프로퍼티 섀도잉**이라고 한다.

- 오버라이딩: 상위 클래스의 메서드를 하위 클래스가 재정의하여 사용하는 방식
- 오버로딩: 함수의 이름은 같지만 매개변수의 타입 또는 개수가 다른 메서드를 구현하고 매개변수에 의해 메서드를 구별하여 호출하는 방식이다. 자바스크립트는 이를 지원하지 않지만, arguments 객체를 사용해 구현할 수 있다.

프로퍼티를 삭제하는 경우에는 프로토타입 프로퍼티를 덮은 인스턴스 프로퍼티가 삭제된다.

```
// 인스턴스 메서드를 삭제한다.
delete me.sayHello;
// 인스턴스에는 sayHello 메서드가 없으므로 프로토타입 메서드가 호출된다.
me.sayHello(); // Hi! My name is Lee
```

하지만 프로토타입 메서드의 삭제는 하위 객체를 통해 삭제하는 것이 불가능하다. 다시말해 하위 객체를 통한 get 액세스는 허용되나 set액세스는 허용되지 않는다. **프로토타입 프로퍼티를 변경/삭제 하려면 프로토타입에 직접 접근해야한다.**

## 19.9 프로토타입 교체

프로토 타입은 다른 객체로 교체할 수 있고, 이는 곧 객체 간의 상속 관계를 동적으로 변경할 수 있다는 말이다. 프로토타입은 생성자 함수 또는 인스턴스에 의해 교체할 수 있다.

### 19.9.1 생성자 함수에 의한 프로토타입 교체

```
const Person = (function () {
  function Person(name) {
    this.name = name;
  }

  // ① 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체
  Person.prototype = {
    sayHello() {
      console.log(`Hi! My name is ${this.name}`);
    }
  };

  return Person;
}());

const me = new Person('Lee');
```

이 방법을 사용하면, constructor 프로퍼티와 생성자 함수 간 연결이 파괴된다. 교체된 객체 리터럴에 constructor 프로퍼티를 추가해 프로토타입의 constructor 프로퍼티를 추가할 수 있다.

```
const Person = (function () {
  function Person(name) {
    this.name = name;
  }

  // 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체
  Person.prototype = {
    // constructor 프로퍼티와 생성자 함수 간의 연결을 설정
    constructor: Person,
    sayHello() {
      console.log(`Hi! My name is ${this.name}`);
    }
  };

  return Person;
}());

const me = new Person('Lee');

// constructor 프로퍼티가 생성자 함수를 가리킨다.
console.log(me.constructor === Person); // true
console.log(me.constructor === Object); // false
```

### 19.9.3 인스턴스에 의한 프로토타입 교체

인스턴스의 `__proto__` 접근자 프로퍼티를 통해 프로토타입을 교체할 수 있다. 이 방법을 사용한 인스턴스의 프로토타입은 교체되나, 생성자 함수의 prototype 프로퍼티가 교체되는 것은 아니다. 즉, 생성자 함수와의 연결이 파괴되는 것은 오직 `__proto__` 접근자 프로퍼티를 통해 프로토타입을 교체한 인스턴스만이다.

```
function Person(name) {
  this.name = name;
}

const me = new Person('Lee');

// 프로토타입으로 교체할 객체
const parent = {
  sayHello() {
    console.log(`Hi! My name is ${this.name}`);
  }
};

// ① me 객체의 프로토타입을 parent 객체로 교체한다.
Object.setPrototypeOf(me, parent);
// 위 코드는 아래의 코드와 동일하게 동작한다.
// me.__proto__ = parent;

me.sayHello(); // Hi! My name is Lee
```

프로토타입 교체를 통해 상속 관계를 동적으로 변경하는 것은 꽤나 번거롭다. 따라서 프로토타입은 직접 교체하지 않는 것이 좋다.

## 19.10 instanceof 연산자

> `객체 instanceof 생성자함수`

우변의 생성자 함수의 prototype 프로퍼티에 바인딩된 객체가 좌변의 객체의 프로토타입 체인에 존재하면 true로 평가된다. 아니면 당연히 false고.

```
function Person(name) {
  this.name = name;
}

const me = new Person('Lee');

// Person.prototype이 me 객체의 프로토타입 체인 상에 존재하므로 true로 평가된다.
console.log(me instanceof Person); // true

// Object.prototype이 me 객체의 프로토타입 체인 상에 존재하므로 true로 평가된다.
console.log(me instanceof Object); // true
```

instanceof 연산자는 프로토타입의 constructor프로퍼티가 가리키는 생성자 함수를 찾는 것이 아니라, ** 생성자 함수의 prototype에 바인딩된 객체가 프로토타입 체인 상에 존재하는지를 확인한다.** 즉, 프로토타입이 교체되더라도 instanceof는 아무런 영향을 받지 않는다.

## 19.11 직접 상속

### 19.11.1 Obejct.create에 의한 직접 상속

> Object.create 는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다. Object.create 메서드도 다른 객체 생성 방식과 마찬가지로 추상 연산 OrdinaryObectCreate를 호출한다.

첫번쨰 매개변수로는 프로토타입이 될 객체를 전달하고, 두번째 매개변수로는 프로퍼티 키와 프로퍼티 디스크럽터 객체로 이뤄진 객체를 전달한다(두번쨰는 옵션이라 생략이 가능하다.).

```
// 프로토타입이 null인 객체를 생성한다. 생성된 객체는 프로토타입 체인의 종점에 위치한다.
// obj → null
let obj = Object.create(null);
console.log(Object.getPrototypeOf(obj) === null); // true
// Object.prototype을 상속받지 못한다.
console.log(obj.toString()); // TypeError: obj.toString is not a function

// obj → Object.prototype → null
// obj = {};와 동일하다.
obj = Object.create(Object.prototype);
console.log(Object.getPrototypeOf(obj) === Object.prototype); // true

// obj → Object.prototype → null
// obj = { x: 1 };와 동일하다.
obj = Object.create(Object.prototype, {
  x: { value: 1, writable: true, enumerable: true, configurable: true }
});
// 위 코드는 다음과 동일하다.
// obj = Object.create(Object.prototype);
// obj.x = 1;
console.log(obj.x); // 1
console.log(Object.getPrototypeOf(obj) === Object.prototype); // true

const myProto = { x: 10 };
// 임의의 객체를 직접 상속받는다.
// obj → myProto → Object.prototype → null
obj = Object.create(myProto);
console.log(obj.x); // 10
console.log(Object.getPrototypeOf(obj) === myProto); // true

// 생성자 함수
function Person(name) {
  this.name = name;
}

// obj → Person.prototype → Object.prototype → null
// obj = new Person('Lee')와 동일하다.
obj = Object.create(Person.prototype);
obj.name = 'Lee';
console.log(obj.name); // Lee
console.log(Object.getPrototypeOf(obj) === Person.prototype); // true
```

Object.create 메서드는 첫 번째 매개변수로 전달한 객체의 프로토타입 체인에 속하는 객체를 생성한다. 직접적으로 상속을 구현하는 것이다. 이 메서드의 장점은 다음과 같다.

- new연산자 없이도 객체를 생성할 수 있다.
- 프로토타입을 지정하면서 객체를 생성할 수 있다.
- 객체 리터럴에 의해 생성된 객체도 상속받을 수 있다..

ESLint에서는 Object.prototype의 빌트인 메서드를 객체가 직접 호출하는것을 권장하지 않는데, 프로토타입 체인 종점에 위치하는 객체는 빌트인 메서드를 사용할 수 없기 때문이다.

```
// 프로토타입이 null인 객체, 즉 프로토타입 체인의 종점에 위치하는 객체를 생성한다.
const obj = Object.create(null);
obj.a = 1;

console.log(Object.getPrototypeOf(obj) === null); // true

// obj는 Object.prototype의 빌트인 메서드를 사용할 수 없다.
console.log(obj.hasOwnProperty('a')); // TypeError: obj.hasOwnProperty is not a function
```

따라서 간접적인 호출이 더 좋은 방법이다.

```
// 프로토타입이 null인 객체를 생성한다.
const obj = Object.create(null);
obj.a = 1;

// console.log(obj.hasOwnProperty('a')); // TypeError: obj.hasOwnProperty is not a function

// Object.prototype의 빌트인 메서드는 객체로 직접 호출하지 않는다.
console.log(Object.prototype.hasOwnProperty.call(obj, 'a')); // true
```

### 19.11.2 객체 리터럴 내부에서 `__proto__`에 의한 직접 상속

Object.create 메서드는 장점이 많지만, 두번째 인자로 프로퍼티를 정의하는 것이 번거롭다. ES6에서는 객체 리터럴 내부에서`__proto__`접근자 프로퍼티를 사용해 직접 상속을 구현할 수 있다.

```
const myProto = { x: 10 };

// 객체 리터럴에 의해 객체를 생성하면서 프로토타입을 지정하여 직접 상속받을 수 있다.
const obj = {
  y: 20,
  // 객체를 직접 상속받는다.
  // obj → myProto → Object.prototype → null
  __proto__: myProto
};
/* 위 코드는 아래와 동일하다.
const obj = Object.create(myProto, {
  y: { value: 20, writable: true, enumerable: true, configurable: true }
});
*/

console.log(obj.x, obj.y); // 10 20
console.log(Object.getPrototypeOf(obj) === myProto); // true
```

## 19.12 정적 프로퍼티/ 메서드

> 정적 프로퍼티/메서드는 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티와 메서드이다.

```
// 생성자 함수
function Person(name) {
  this.name = name;
}

// 프로토타입 메서드
Person.prototype.sayHello = function () {
  console.log(`Hi! My name is ${this.name}`);
};

// 정적 프로퍼티
Person.staticProp = 'static prop';

// 정적 메서드
Person.staticMethod = function () {
  console.log('staticMethod');
};

const me = new Person('Lee');

// 생성자 함수에 추가한 정적 프로퍼티/메서드는 생성자 함수로 참조/호출한다.
Person.staticMethod(); // staticMethod

// 정적 프로퍼티/메서드는 생성자 함수가 생성한 인스턴스로 참조/호출할 수 없다.
// 인스턴스로 참조/호출할 수 있는 프로퍼티/메서드는 프로토타입 체인 상에 존재해야 한다.
me.staticMethod(); // TypeError: me.staticMethod is not a function
```

생성자 함수 또한 객체이므로 자신의 프로퍼티와 메서드를 가질 수 있다. 생성자 함수 객체가 소유하는 프로퍼티/메서드를 정적 프로퍼티/메서드라고 한다. 단, 생성자 함수로 만든 인스턴스는 정적 프로퍼티/메서드를 호출할 수 없다.
Obejct.create 메서드는 Object 생성자 함수의 정적 메서드이기 때문에 Object 생성자 함수로 생성한 객체로 호출할 수 없다.

만약 인스턴스/프로토타입 메서드 내에서 this를 사용하지 않았다면 그 메서드는 정적메서드로 변경할 수 있다.

```
function Foo() {}

// 프로토타입 메서드
// this를 참조하지 않는 프로토타입 메소드는 정적 메서드로 변경해도 동일한 효과를 얻을 수 있다.
Foo.prototype.x = function () {
  console.log('x');
};

const foo = new Foo();
// 프로토타입 메서드를 호출하려면 인스턴스를 생성해야 한다.
foo.x(); // x

// 정적 메서드
Foo.x = function () {
  console.log('x');
};

// 정적 메서드는 인스턴스를 생성하지 않아도 호출할 수 있다.
Foo.x(); // x
```

프로토타입 프로퍼티/메서드를 표기할 때 prototype을 #으로 표기하는 경우도 있다.(Object#isPrototypeOf 이렇게)

## 19.13 프로퍼티 존재 확인

### 19.13.1 in연산자

> in연산자는 객체에 특정 프로퍼티가 있는지를 확인한다.
> key in object

```
const person = {
  name: 'Lee',
  address: 'Seoul'
};

// person 객체에 name 프로퍼티가 존재한다.
console.log('name' in person);    // true
// person 객체에 address 프로퍼티가 존재한다.
console.log('address' in person); // true
// person 객체에 age 프로퍼티가 존재하지 않는다.
console.log('age' in person);     // false
```

단 이 방법은 상속받은 모든 프로토타입의 프로퍼티를 확인하므로 주의가 필요하다. 즉, 객체에 없는 프로퍼티가 있다고 출력할수도 있다.

Reflect.has 메서드를 사용할수도 있다. 이는 in연산자와 동일하게 동작한다.

### 19.13.2 Object.prototype.hasOwnProperty 메서드

Object.prototype.hasOwnProperty를 사용해도 객체에 특정 프로퍼티가 있는지 확인할 수 있다.

```
const person = {name: 'lee'};

console.log(person.hasOwnProperty('name')); // true
console.log(person.hasOwnProperty('age'));  // false
```

이 경우 객체 고유의 프로퍼티 키인 경우에만 true, 상속받은 프로퍼티의 경우 false를 리턴한다.

## 19.14 프로퍼티 열거

### 19.14.1 `for...in`문

> `for...in` 문을 사용하면 객체의 모든 프로퍼티를 순회하면서 열거한다.

```
const person = {
  name: 'Lee',
  address: 'Seoul'
};

// for...in 문의 변수 key에 person 객체의 프로퍼티 키가 할당된다.
for (const key in person) {
  console.log(key + ': ' + person[key]);
}
// name: Lee
// address: Seoul
```

이는 상속받은 프로퍼티까지 순회한다. 다만, Object.toString과 같은 Object.prototype의 프로퍼티는 열거되지 않는데, 그 이유는 순회되지 않도록 정의된 프로퍼티이기 떄문이다. Object.prototype.toString의 [[Enumerable]]의 값은 flase 이다.

따라서, **`for...in`문은 프로토타입 체인 상의 모든 프로토타입 프로퍼티 중에서 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 true인 값을 순회하며 열거한다.**

또한 키가 심벌인 프로퍼티 또한 열거하지 않는다.

객체 자신의 프로퍼티만 열거하려면 Object.prototype.hasOwnProperty 메서드를 사용해 객체 자신의 프로퍼티인지 확인한다.

```
const person = {
  name: 'Lee',
  address: 'Seoul',
  __proto__: { age: 20 }
};

for (const key in person) {
  // 객체 자신의 프로퍼티인지 확인한다.
  if (!person.hasOwnProperty(key)) continue;
  console.log(key + ': ' + person[key]);
}
// name: Lee
// address: Seoul
```

`for...in`문이 프로퍼티 열거에 순서를 보장하지 않지만, 대부분의 모던 브라우저는 순서를 보장하고 숫자(사실은 문자열)인 프로퍼티 키에서는 정렬을 한다.

```
const obj = {
  2: 2,
  3: 3,
  1: 1,
  b: 'b',
  a: 'a'
};

for (const key in obj) {
  if (!obj.hasOwnProperty(key)) continue;
  console.log(key + ': ' + obj[key]);
}

/*
1: 1
2: 2
3: 3
b: b
a: a
*/
```

### 19.14.2 Object.keys/values/entries 메서드

객체 고유의 프로퍼티만 열거하는 것은 Object.keys/values/entries 메서드를 사용하는 것이 더 권장된다.

Object.keys는 객체 자신의 열거 가능한 프로퍼티 키를 배열로 반환한다.

```
const person = {
  name: 'Lee',
  address: 'Seoul',
  __proto__: { age: 20 }
};

console.log(Object.keys(person)); // ["name", "address"]
```

Object.values는 객체 자신의 열거 가능한 프로퍼티 값은 배열로 반환한다.

```
console.log(Object.values(person)); // ["Lee", "Seoul"]
```

Object.entries 메서드는 객체 자신의 열거 가능한 프로퍼티 키와 값의 쌍의 배열을 배열에 담아 반환한다.

```
console.log(Object.entries(person)); // [["name", "Lee"], ["address", "Seoul"]]

Object.entries(person).forEach(([key, value]) => console.log(key, value));
/*
name Lee
address Seoul
*/
```

# 20장 strict mode

## 20.1 strict mode 란?

코드를 작성할 때, 오타 혹은 지식의 미비로 인한 실수는 언제나 발생한다. 따라서 잠재적인 오류를 발생시키기 어려운 환경을 만들고 그 환경에서 개발하는 것이 조금 더 근본적인 해결책일 것이다.

이러한 환경 생성을 위해서 ES6에서 strict mode 가 추가되었다. 문법을 좀 더 엄격히 적용시켜 오류가 발생할 가능성이 높거나 JS엔진 최적화에 문제를 일으킬 수 있는 코드에 명시적인 경고를 제공한다. ESLint 와 같은 린트 도구를 사용해도 유사한 효과를 얻을 수 있다. 린트 도구는 잠재적 오류까지 찾아내며, strict mode에서 제한하는 오류와 코딩 컨벤션을 설정 파일로 정의하고 강제할 수 있기 때문에 더욱 강력한 효과를 얻을 수 있다.

## 20.2 strict mode의 적용

전역의 선두 혹은 함수 몸체의 서두에 `'use strict';` 를 추가한다.

```
'use strict';

function foo() {
  x = 10; // ReferenceError: x is not defined
}
foo();
```

```
function foo() {
  'use strict';

  x = 10; // ReferenceError: x is not defined
}
foo();
```

```
function foo() {
  x = 10; // 에러를 발생시키지 않는다.
  'use strict';
}
foo();

function foo2() {
  x = 10; // 에러를 발생시키지 않는다.
  'use strict';
  y = 20; // 에러를 발생시키지 않는다.
}
foo2();
```

## 20.3 전역에 strict mode를 사용하는 것을 피하자

전역에 적용한 strict mode 는 스크립트 별로 적용된다.

```
<!DOCTYPE html>
<html>
<body>
  <script>
    'use strict';
  </script>
  <script>
    x = 1; // 에러가 발생하지 않는다.
    console.log(x); // 1
  </script>
  <script>
    'use strict';

    y = 1; // ReferenceError: y is not defined
    console.log(y);
  </script>
</body>
</html>
```

strict mode와 non-strict mode를 혼용하는 것은 오류를 발생시킬 수 있다. 특히 외부 서드파티 라이브러리일 경우 라이브러리가 non-strict mode 인 경우도 있기 때문에 전역에 strict mode를 적용하는 것은 바람직 하지 안핟. 이런 경우 즉시실행 함수로 스크립트 전체를 감싸서 스코프를 구분하고, 즉시실행 함수의 서두에 strict mode를 사용한다.

```
// 즉시 실행 함수의 선두에 strict mode 적용
(function () {
  'use strict';

  // Do something...
}());
```

## 20.4 함수 단위로 strict mode를 적용하는 것도 피하자

함수 단위로 strict mode를 적용할수도 있으나, 이 역시도 피하는 것이 좋다. 일일이 적용하는 것도 번거로울 뿐더러, strict mode 가 적용된 함수가 참조하는 외부 함수의 컨텍스트에 strict 를 적용하지 않는다면 이 또한 문제가 발생할수도 있다.

```
(function () {
  // non-strict mode
  var lеt = 10; // 에러가 발생하지 않는다.

  function foo() {
    'use strict';

    let = 20; // SyntaxError: Unexpected strict mode reserved word
  }
  foo();
}());
```

따라서 엄격 모드는 그냥 즉시실행 함수로 감싼 스크립트 단위로 사용하는 것이 바람직하다.

## 20.5 strict mode가 발생시키는 에러

### 20.5.1 암묵적 전역

선언하지 않은 변수를 참조하면 RefereneError 가 발생한다.

```
(function () {
  'use strict';

  x = 1;
  console.log(x); // ReferenceError: x is not defined
}());
```

### 20.5.2 변수, 함수, 매개변수의 삭제

delete 연산자로 변수, 함수, 매개변수를 삭제하면 SyntaxError가 발생한다.

```
(function () {
  'use strict';

  var x = 1;
  delete x;
  // SyntaxError: Delete of an unqualified identifier in strict mode.

  function foo(a) {
    delete a;
    // SyntaxError: Delete of an unqualified identifier in strict mode.
  }
  delete foo;
  // SyntaxError: Delete of an unqualified identifier in strict mode.
}());
```

### 20.5.3 매개변수 이름의 중복

```
(function () {
  'use strict';

  //SyntaxError: Duplicate parameter name not allowed in this context
  function foo(x, x) {
    return x + x;
  }
  console.log(foo(1, 2));
}());
```

### 20.5.4 with문의 사용

with문을 사용하면 SyntaxError 가 발생한다. with문은 전달된 객체를 스코프 체인에 추가한다. 프로퍼티를 반복해서 사용할 때 이름을 생략할 수 있는 장점이 있으나, 가독성과 성능이 나빠진다.

```
(function () {
  'use strict';

  // SyntaxError: Strict mode code may not include a with statement
  with({ x: 1 }) {
    console.log(x);
  }
}());
```

## 20.6 strict mode 적용에 의한 변화

### 20.6.1 일반 함수의 this

strict mode 에서 함수를 인반 함수로 호출하면 this에 undefined가 바인딩된다. 일반 함수 내부에서는 this를 사용할 필요가 없기 때문이다.

```
(function () {
  'use strict';

  function foo() {
    console.log(this); // undefined
  }
  foo();

  function Foo() {
    console.log(this); // Foo
  }
  new Foo();
}());
```

### 20.6.2 arguments 객체

strict mode에서는 매개변수에 전달한 인수를 재할당하여 변경해도 arguments 객체에 반영되지 않는다.

```
(function (a) {
  'use strict';
  // 매개변수에 전달된 인수를 재할당하여 변경
  a = 2;

  // 변경된 인수가 arguments 객체에 반영되지 않는다.
  console.log(arguments); // { 0: 1, length: 1 }
}(1));
```

# 21장 빌트인 객체

## 21.1 자바스크립트 객체의 분류

자바스크립트 객체는 다음 3개의 객체로 분류할 수 있다.

- 표준 빌트인 객체: ECMAScript 사양에 정의된 객체 . 애플리케이션 전역의 공통 기능을 제공한다. 자바스크립트 런타임 환경에 관계없이 사용 가능하며, 전역 객체의 프로퍼티로 제공된다.

- 호스트 객체: 자바스크립트 런타임 환경에서 추가로 제공하는 객체.

- 사용자 정의 객체: 사용자가 직접 정의한 객체

## 21.2 표준 빌트인 객체

자바스크립트는 40여개의 표준 빌트인 객체를 제공한다. `Math`, `Reflect`, `JSON`을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체다. 표준 빌트인 객체가 생성자 함수 객체이면 프로토타입 메서드와 정적 메서드 둘 다 제공하고, 생성자 함수 객체가 아니라면 정적 메서드만 제공한다.

```
// String 생성자 함수에 의한 String 객체 생성
const strObj = new String('Lee'); // String {"Lee"}
console.log(typeof strObj);       // object

// Number 생성자 함수에 의한 Number 객체 생성
const numObj = new Number(123); // Number {123}
console.log(typeof numObj);     // object

// Boolean 생성자 함수에 의한 Boolean 객체 생성
const boolObj= new Boolean(true); // Boolean {true}
console.log(typeof boolObj);      // object

// Function 생성자 함수에 의한 Function 객체(함수) 생성
const func = new Function('x', 'return x * x'); // ƒ anonymous(x )
console.log(typeof func);                       // function

// Array 생성자 함수에 의한 Array 객체(배열) 생성
const arr = new Array(1, 2, 3); // (3) [1, 2, 3]
console.log(typeof arr);        // object

// RegExp 생성자 함수에 의한 RegExp 객체(정규 표현식) 생성
const regExp = new RegExp(/ab+c/i); // /ab+c/i
console.log(typeof regExp);         // object

// Date 생성자 함수에 의한 Date 객체 생성
const date = new Date();  // Fri May 08 2020 10:43:25 GMT+0900 (대한민국 표준시)
console.log(typeof date); // object
```

표준 빌트인 객체이면서 생성자 함수가 생성한 인스턴스의 프로토타입은 표준 빌트인 객체의 prototype에 바인딩 된 객체이다.

```
// String 생성자 함수에 의한 String 객체 생성
const strObj = new String('Lee'); // String {"Lee"}

// String 생성자 함수를 통해 생성한 strObj 객체의 프로토타입은 String.prototype이다.
console.log(Object.getPrototypeOf(strObj) === String.prototype); // true
```

표준 빌트인 객체의 prototype에 바인딩된 객체는 다양한 기능의 빌트인 프로토타입 메서드를 제공한다. 또한 정적 메서드 또한 제공한다.

```
// Number 생성자 함수에 의한 Number 객체 생성
const numObj = new Number(1.5); // Number {1.5}

// toFixed는 Number.prototype의 프로토타입 메서드다.
// Number.prototype.toFixed는 소수점 자리를 반올림하여 문자열로 반환한다.
console.log(numObj.toFixed()); // 2

// isInteger는 Number의 정적 메서드다.
// Number.isInteger는 인수가 정수(integer)인지 검사하여 그 결과를 Boolean으로 반환한다.
console.log(Number.isInteger(0.5)); // false
```

## 21.3 원시값과 래퍼 객체

원시값에 객체처럼 접근하면 JS엔진이 일시적, 암묵적으로 연관된 객체를 생성하여 그 객체로 프로퍼티에 접근 혹은 메서드를 호출하고 다시 원시값으로 되돌린다. **이 때, 불리며 임시적으로 생성되는 객체를 래퍼 객체**라고 한다.

문자열에 대해 마침표 표기법으로 접근하면 String 생성자 함수의 인스턴스가 생성되고, 문자열은 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된다.

```
const str = 'hi';

// 원시 타입인 문자열이 래퍼 객체인 String 인스턴스로 변환된다.
console.log(str.length); // 2
console.log(str.toUpperCase()); // HI

// 래퍼 객체로 프로퍼티에 접근하거나 메서드를 호출한 후, 다시 원시값으로 되돌린다.
console.log(typeof str); // string
```

되돌아간 래퍼 객체는 가비지 컬렉션의 대상이 된다.

이처럼 문자열, 숫자, 불리언, 심벌은 암묵적으로 생성되는 래퍼 객체에 의해 객체처럼 사용할 수 있으며, 따라서 String, Number, Boolean 생성자 함수를 new 연산자와 함께 호출해 인스턴스를 생성할 필요가 없다.

## 21.4 전역 객체

전역 객체는 JS엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며, 어떤 객체에도 속하지 않은 최상위 객체다. 런타임 환경에 따라 이름이 제각각인데, 브라우저는 window, node 환경에서는 global이라 불린다.

- 전역객체는 표준 빌트인 객체와 환경에 따른 호스트 객체, var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 가진다. 전역 객체 자신은 누구의 프로퍼티도 아니며, 단순히 계층 구조상 표준 빌트인 객체와 호스트 객체를 프로퍼티로 소유한다.

전역 객체의 특징

- 개발자 임의로 생성할 수 없다.
- 프로퍼티를 참조할 때 window를 생략할 수 있다.
- 모든 표준 빌트인 객체를 프로퍼티로 가진다.
- 런타임에 따라 프로퍼티와 메서드를 가진다.(호스트 객체)
- 브라우저 환경의 모든 JS코드는 하나의 전역 객체를 공유한. 스크립트를 분리해도 마찬가지이다.

### 21.4.1 빌트인 전역 프로퍼티

전역 객체의 프로퍼티를 의미한다. 주로 어플리케이션 전역에서 사용하는 값을 제공한다.

- Infinity: 무한대를 나타내는 숫자값.

```
// 전역 프로퍼티는 window를 생략하고 참조할 수 있다.
console.log(window.Infinity === Infinity); // true

// 양의 무한대
console.log(3/0);  // Infinity
// 음의 무한대
console.log(-3/0); // -Infinity
// Infinity는 숫자값이다.
console.log(typeof Infinity); // number
```

- NaN: 숫자가 아님을 나타내는 숫자값. Number.NaN 프로퍼티와 같다.

```
console.log(window.NaN); // NaN

console.log(Number('xyz')); // NaN
console.log(1 * 'string');  // NaN
console.log(typeof NaN);    // number
```

- undefined: 원시값 undefined를 값으로 가지는 프로퍼티

```
console.log(window.undefined); // undefined

var foo;
console.log(foo); // undefined
console.log(typeof undefined); // undefined
```

## 21.4.2 빌트인 전역 함수

애플리케이션 전역에서 호출할 수 있는 전역 객체의 메서드

- eval : JS코드를 나타내는 문자열을 인수로 전달받는다. 전달받은 코드가 표현식이라면 이를 런타임에 평가해 값을 생성하고, 아니라면 코드를 런타임에 실행한다. 여러 문으로 이루어진 코드라면 모든 문을 실행하고 마지막 결과값을 반환한다.

```
// 표현식인 문
eval('1 + 2;'); // -> 3
// 표현식이 아닌 문
eval('var x = 5;'); // -> undefined

// eval 함수에 의해 런타임에 변수 선언문이 실행되어 x 변수가 선언되었다.
console.log(x); // 5

// 객체 리터럴은 반드시 괄호로 둘러싼다.
const o = eval('({ a: 1 })');
console.log(o); // {a: 1}

// 함수 리터럴은 반드시 괄호로 둘러싼다.
const f = eval('(function() { return 1; })');
console.log(f()); // 1
```

```
console.log(eval('1 + 2; 3 + 4;')); // 7
```

또한 자신이 호출된 위치에 해당하는 기존의 스코프를 런타임에 동적으로 수정한다.

```
const x = 1;

function foo() {
  // eval 함수는 런타임에 foo 함수의 스코프를 동적으로 수정한다.
  eval('var x = 2;');
  console.log(x); // 2
}

foo();
console.log(x); // 1
```

eval에 전달된 코드는 원래 그 위치에 존재하던 코드처럼 작동한다.

단, strict mode에서는 기존의 스코프를 수정하지 않고, 자신의 자체적인 스코프를 생성한다.

또한 인수로 let, const를 전달받았다면, 암묵적으로 strict mode가 적용된다.

```
const x = 1;

function foo() {
  eval('var x = 2; console.log(x);'); // 2
  // let, const 키워드를 사용한 변수 선언문은 strict mode가 적용된다.
  eval('const x = 3; console.log(x);'); // 3
  console.log(x); // 2
}

foo();
console.log(x); // 1
```

eval함수는 보안에 매우 취약하며 최적화 또한 진행되지 않기 때문에 속도가 느리다. 따라서 사용을 금지해야 한다.

- isFinite: 전달받은 인자가 정상적인 유한수이면 true를 반환하고, 아니라면 false를 반환한다. 인자를 숫자로 바꿔 평가하며, 숫자로 평가되지 않는 NaN인 경우 false를 반환한다.

```
// 인수가 유한수이면 true를 반환한다.
isFinite(0);    // -> true
isFinite(2e64); // -> true
isFinite('10'); // -> true: '10' → 10
isFinite(null); // -> true: null → 0

// 인수가 무한수 또는 NaN으로 평가되는 값이라면 false를 반환한다.
isFinite(Infinity);  // -> false
isFinite(-Infinity); // -> false

// 인수가 NaN으로 평가되는 값이라면 false를 반환한다.
isFinite(NaN);     // -> false
isFinite('Hello'); // -> false
isFinite('2005/12/12'); // -> false

console.log(+null); // 0
```

- isNaN: 전달받은 인수가 NaN인지를 검사해 불리언으로 반환한다. 인수를 숫자로 강제로 타입 변환한다.

```
// 숫자
isNaN(NaN); // -> true
isNaN(10);  // -> false

// 문자열
isNaN('blabla'); // -> true: 'blabla' => NaN
isNaN('10');     // -> false: '10' => 10
isNaN('10.12');  // -> false: '10.12' => 10.12
isNaN('');       // -> false: '' => 0
isNaN(' ');      // -> false: ' ' => 0

// 불리언
isNaN(true); // -> false: true → 1
isNaN(null); // -> false: null → 0

// undefined
isNaN(undefined); // -> true: undefined => NaN

// 객체
isNaN({}); // -> true: {} => NaN

// date
isNaN(new Date());            // -> false: new Date() => Number
isNaN(new Date().toString()); // -> true:  String => NaN
```

- parseFloat: 전달받은 문자열 인수를 실수로 해석하여 반환한다.

```
// 문자열을 실수로 해석하여 반환한다.
parseFloat('3.14');  // -> 3.14
parseFloat('10.00'); // -> 10

// 공백으로 구분된 문자열은 첫 번째 문자열만 변환한다.
parseFloat('34 45 66'); // -> 34
parseFloat('40 years'); // -> 40

// 첫 번째 문자열을 숫자로 변환할 수 없다면 NaN을 반환한다.
parseFloat('He was 40'); // -> NaN

// 앞뒤 공백은 무시된다.
parseFloat(' 60 '); // -> 60
```

- parseInt: 전달받은 문자열 인수를 정수로 해석해 반환한다.

```
// 문자열을 정수로 해석하여 반환한다.
parseInt('10');     // -> 10
parseInt('10.123'); // -> 10
```

인수를 문자열로 변환하고, 정수로 해석하여 반환한다.

```
parseInt(10);     // -> 10
parseInt(10.123); // -> 10
```

두번째 인수로 진법을 나타내는 기수를 전달할 수 있다. 반환값은 언제나 10진수이며, 기수를 생략하면 10진수로 해석하여 반환한다.

```
// 10'을 10진수로 해석하고 그 결과를 10진수 정수로 반환한다
parseInt('10'); // -> 10
// '10'을 2진수로 해석하고 그 결과를 10진수 정수로 반환한다
parseInt('10', 2); // -> 2
// '10'을 8진수로 해석하고 그 결과를 10진수 정수로 반환한다
parseInt('10', 8); // -> 8
// '10'을 16진수로 해석하고 그 결과를 10진수 정수로 반환한다
parseInt('10', 16); // -> 16
```

기수를 지정하여 10진수 숫자를 해당 기수의 문자열로 변환하고 싶으면 Number.prototype.toString 메서드를 사용한다.

```
const x = 15;

// 10진수 15를 2진수로 변환하여 그 결과를 문자열로 반환한다.
x.toString(2); // -> '1111'
// 문자열 '1111'을 2진수로 해석하고 그 결과를 10진수 정수로 반환한다
parseInt(x.toString(2), 2); // -> 15

// 10진수 15를 8진수로 변환하여 그 결과를 문자열로 반환한다.
x.toString(8); // -> '17'
// 문자열 '17'을 8진수로 해석하고 그 결과를 10진수 정수로 반환한다
parseInt(x.toString(8), 8); // -> 15

// 10진수 15를 16진수로 변환하여 그 결과를 문자열로 반환한다.
x.toString(16); // -> 'f'
// 문자열 'f'를 16진수로 해석하고 그 결과를 10진수 정수로 반환한다
parseInt(x.toString(8), 8); // -> 15

// 숫자값을 문자열로 변환한다.
x.toString(); // -> '15'
// 문자열 '15'를 10진수로 해석하고 그 결과를 10진수 정수로 반환한다
parseInt(x.toString()); // -> 15
```

두번째 인수를 생략해도, 첫번째 인수의 전달값이 '0x' 혹은 '0X' 로 시작하는 16진수 리터럴이면 16진수로 해석하여 10진수 정수로 반환한다.

```
// 16진수 리터럴 '0xf'를 16진수로 해석하고 10진수 정수로 그 결과를 반환한다.
parseInt('0xf'); // -> 15
// 위 코드와 같다.
parseInt('f', 16); // -> 15
```

하지만 위의 경우 2진수 리터럴과 8진수 리터럴은 제대로 해석하지 못한다. ES5에서는 0으로 시작하는 숫자를 8진수로 여겼지만, ES6에서는 10진수로 여기기 때문이다. 따라서 8진수 해석을 위해선 반드시 지정이 필요하다.

```
// 2진수 리터럴(0b로 시작)은 제대로 해석하지 못한다. 0 이후가 무시된다.
parseInt('0b10'); // -> 0
// 8진수 리터럴(ES6에서 도입. 0o로 시작)은 제대로 해석하지 못한다. 0 이후가 무시된다.
parseInt('0o10'); // -> 0

// 문자열 '10'을 2진수로 해석한다.
parseInt('10', 2); // -> 2
// 문자열 '10'을 8진수로 해석한다.
parseInt('10', 8); // -> 8
```

숫자로 변환될 수 없으면 NaN을 반환하다.

```
// 'A'는 10진수로 해석할 수 없다.
parseInt('A0'); // -> NaN
// '2'는 2진수로 해석할 수 없다.
parseInt('20', 2); // -> NaN
```

첫째인자의 두번째 문자부터 숫자가 아닌 문자와 마주치면 무시되며, 해석된 정수값만 반환된다.

```
// 10진수로 해석할 수 없는 'A' 이후의 문자는 모두 무시된다.
parseInt('1A0'); // -> 1
// 2진수로 해석할 수 없는 '2' 이후의 문자는 모두 무시된다.
parseInt('102', 2); // -> 2
// 8진수로 해석할 수 없는 '8' 이후의 문자는 모두 무시된다.
parseInt('58', 8); // -> 5
// 16진수로 해석할 수 없는 'G' 이후의 문자는 모두 무시된다.
parseInt('FG', 16); // -> 15
```

공백이 있다면 첫번쨰 문자열만 해석해 앞뒤 공백은 무시된다.

```
// 공백으로 구분된 문자열은 첫 번째 문자열만 변환한다.
parseInt('34 45 66'); // -> 34
parseInt('40 years'); // -> 40
// 첫 번째 문자열을 숫자로 변환할 수 없다면 NaN을 반환한다.
parseInt('He was 40'); // -> NaN
// 앞뒤 공백은 무시된다.
parseInt(' 60 '); // -> 60
```

- encodeURI / decodeURI: 완전한 URI를 전달받아 이스케이프 처리를 위해 인코딩한다.

인코딩이란 URI문자들을 이스케이프 처리를 하는 것을 말한다.

> 이스케이프 처리: 네트워크로 정보를 공유할 때 어떤 시스템에서도 읽을 수 있게 아스키 코드로 변환하는 것.

URL은 아스키 문자 셋으로만 구성되어야 하며 한글을 포함한 대부분의 외국어나 아스키 셋에 없는 경우 URL에 포함될 수 없다.

```
// 완전한 URI
const uri = 'http://example.com?name=이웅모&job=programmer&teacher';

// encodeURI 함수는 완전한 URI를 전달받아 이스케이프 처리를 위해 인코딩한다.
const enc = encodeURI(uri);
console.log(enc);
// http://example.com?name=%EC%9D%B4%EC%9B%85%EB%AA%A8&job=programmer&teacher
```

decodeURI는 인코딩된 URI를 전달받아 이스케이프 처리 전으로 디코딩한다.

```
const uri = 'http://example.com?name=이웅모&job=programmer&teacher';

// encodeURI 함수는 완전한 URI를 전달받아 이스케이프 처리를 위해 인코딩한다.
const enc = encodeURI(uri);
console.log(enc);
// http://example.com?name=%EC%9D%B4%EC%9B%85%EB%AA%A8&job=programmer&teacher

// decodeURI 함수는 인코딩된 완전한 URI를 전달받아 이스케이프 처리 이전으로 디코딩한다.
const dec = decodeURI(enc);
console.log(dec);
// http://example.com?name=이웅모&job=programmer&teacher
```

- encodeURIComponent / decodeURIComponent: encodeURIComponent함수는 URI 구성 요소를 인수로 전달받아 인코딩한다. decodeURIComponent함수는 매개변수로 전달된 URI 구성 요소를 디코딩한다.

encodeURIComponent는 문자열을 URI의 구성요소인 쿼리 스트링의 일부로 간주하며, 따라서 구분자인 =, ? & 도 인코딩한다.

```
// URI의 쿼리 스트링
const uriComp = 'name=이웅모&job=programmer&teacher';

// encodeURIComponent 함수는 인수로 전달받은 문자열을 URI의 구성요소인 쿼리 스트링의 일부로 간주한다.
// 따라서 쿼리 스트링 구분자로 사용되는 =, ?, &까지 인코딩한다.
let enc = encodeURIComponent(uriComp);
console.log(enc);
// name%3D%EC%9D%B4%EC%9B%85%EB%AA%A8%26job%3Dprogrammer%26teacher

let dec = decodeURIComponent(enc);
console.log(dec);
// 이웅모&job=programmer&teacher

// encodeURI 함수는 인수로 전달받은 문자열을 완전한 URI로 간주한다.
// 따라서 쿼리 스트링 구분자로 사용되는 =, ?, &를 인코딩하지 않는다.
enc = encodeURI(uriComp);
console.log(enc);
// name=%EC%9D%B4%EC%9B%85%EB%AA%A8&job=programmer&teacher

dec = decodeURI(enc);
console.log(dec);
// name=이웅모&job=programmer&teacher
```

### 21.4.3 암묵적 전역

선언되지 않은 식별자가 마치 전역적으로 선언된것처럼 작동하는 현상

```
var x = 10; // 전역 변수

function foo () {
  // 선언하지 않은 식별자에 값을 할당
  y = 20; // window.y = 20;
}
foo();

// 선언하지 않은 식별자 y를 전역에서 참조할 수 있다.
console.log(x + y); // 30
```

실제로는 변수가 아니라 전역 객체의 프로퍼티로 추가되었을 뿐이다. 따라서 호이스팅은 발생하지 않는다.

```
// 전역 변수 x는 호이스팅이 발생한다.
console.log(x); // undefined
// 전역 변수가 아니라 단지 전역 객체의 프로퍼티인 y는 호이스팅이 발생하지 않는다.
console.log(y); // ReferenceError: y is not defined

var x = 10; // 전역 변수

function foo () {
  // 선언하지 않은 식별자에 값을 할당
  y = 20; // window.y = 20;
}
foo();

// 선언하지 않은 식별자 y를 전역에서 참조할 수 있다.
console.log(x + y); // 30
```

또한 암묵적 전역이 적용된 변수는 delete 연산자로 삭제할 수 있다.

```
var x = 10; // 전역 변수

function foo () {
  // 선언하지 않은 식별자에 값을 할당
  y = 20; // window.y = 20;
  console.log(x + y);
}

foo(); // 30

console.log(window.x); // 10
console.log(window.y); // 20

delete x; // 전역 변수는 삭제되지 않는다.
delete y; // 프로퍼티는 삭제된다.

console.log(window.x); // 10
console.log(window.y); // undefined
```

# 22장 this

## 22.1 this 키워드

메서드는 속한 객체의 상태(프로퍼티)를 변경할 수 있어야 하는데, 그러려면 해당 객체를 가리키는 식별자를 참조할 수 있어야 한다. 객체 리터럴 방식으로 생성한 경우에도 재귀적 참조가 가능하다.

```
const circle = {
  // 프로퍼티: 객체 고유의 상태 데이터
  radius: 5,
  // 메서드: 상태 데이터를 참조하고 조작하는 동작
  getDiameter() {
    // 이 메서드가 자신이 속한 객체의 프로퍼티나 다른 메서드를 참조하려면
    // 자신이 속한 객체인 circle을 참조할 수 있어야 한다.
    return 2 * circle.radius;
  }
};

console.log(circle.getDiameter()); // 10
```

하지만 이는 일반적이지도, 바람직하지도 않다. 생성자 함수를 생각해보자

```
function Circle(radius) {
  // 이 시점에는 생성자 함수 자신이 생성할 인스턴스를 가리키는 식별자를 알 수 없다.
  ????.radius = radius;
}

Circle.prototype.getDiameter = function () {
  // 이 시점에는 생성자 함수 자신이 생성할 인스턴스를 가리키는 식별자를 알 수 없다.
  return 2 * ????.radius;
};

// 생성자 함수로 인스턴스를 생성하려면 먼저 생성자 함수를 정의해야 한다.
const circle = new Circle(5);
```

이렇듯 객체는 스스로를 참조할 식별자가 필요한데, 그게 바로 this이다. this는 자신이 속한 객체 또는 인스턴스를 가리키는 자기 참조 변수이다. this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.

> 바인딩: 식별자와 값을 연결하는 과정. 변수 선언은 식별자와 메모리 공간의 주소를 바인딩하는 것이다.

객체 리터럴의 this는 객체 스스로를, 생성자 함수의 this는 인스턴스를 가리킨다.

```
// 객체 리터럴
const circle = {
  radius: 5,
  getDiameter() {
    // this는 메서드를 호출한 객체를 가리킨다.
    return 2 * this.radius;
  }
};

console.log(circle.getDiameter()); // 10

// 생성자 함수
function Circle(radius) {
  // this는 생성자 함수가 생성할 인스턴스를 가리킨다.
  this.radius = radius;
}

Circle.prototype.getDiameter = function () {
  // this는 생성자 함수가 생성할 인스턴스를 가리킨다.
  return 2 * this.radius;
};

// 인스턴스 생성
const circle = new Circle(5);
console.log(circle.getDiameter()); // 10
```

this는 코드 어디에서든 참조가 가능하다.

```
// this는 어디서든지 참조 가능하다.
// 전역에서 this는 전역 객체 window를 가리킨다.
console.log(this); // window

function square(number) {
  // 일반 함수 내부에서 this는 전역 객체 window를 가리킨다.
  console.log(this); // window
  return number * number;
}
square(2);

const person = {
  name: 'Lee',
  getName() {
    // 메서드 내부에서 this는 메서드를 호출한 객체를 가리킨다.
    console.log(this); // {name: "Lee", getName: ƒ}
    return this.name;
  }
};
console.log(person.getName()); // Lee

function Person(name) {
  this.name = name;
  // 생성자 함수 내부에서 this는 생성자 함수가 생성할 인스턴스를 가리킨다.
  console.log(this); // Person {name: "Lee"}
}

const me = new Person('Lee');
```

this는 메서드 내부나 생성자 함수 내부에서만 의미가 있다. 따라서 strict mode 적용 하에서 this는 undefined이다.

## 22.2 함수 호출 방식과 this 바인딩

> this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다.

### 22.2.1 일반 함수 호출

```

function foo() {
  console.log("foo's this: ", this);  // window
  function bar() {
    console.log("bar's this: ", this); // window
  }
  bar();
}
foo();
```

기본적으로 일반 함수로 호출하면 this에는 전역 객체가 바인딩 된다. strict mode에서는 undefined가 바인딩 된다.

또한 메서드 내에서 정의한 중첩함수도 일반함수로 호출하면 전역객체가 바인딩 된다.

```
// var 키워드로 선언한 전역 변수 value는 전역 객체의 프로퍼티다.
var value = 1;
// const 키워드로 선언한 전역 변수 value는 전역 객체의 프로퍼티가 아니다.
// const value = 1;

const obj = {
  value: 100,
  foo() {
    console.log("foo's this: ", this);  // {value: 100, foo: ƒ}
    console.log("foo's this.value: ", this.value); // 100

    // 메서드 내에서 정의한 중첩 함수
    function bar() {
      console.log("bar's this: ", this); // window
      console.log("bar's this.value: ", this.value); // 1
    }

    // 메서드 내에서 정의한 중첩 함수도 일반 함수로 호출되면 중첩 함수 내부의 this에는 전역 객체가 바인딩된다.
    bar();
  }
};

obj.foo();
```

**어떠한 함수라도 일반 함수로 호출되면 this에는 전역 객체가 바인딩 된다.**

```
var value = 1;

const obj = {
  value: 100,
  foo() {
    console.log("foo's this: ", this); // {value: 100, foo: ƒ}
    // 콜백 함수 내부의 this에는 전역 객체가 바인딩된다.
    setTimeout(function () {
      console.log("callback's this: ", this); // window
      console.log("callback's this.value: ", this.value); // 1
    }, 100);
  }
};

obj.foo();
```

메서드 내의 중첩 함수 혹은 콜백 함수의 this를 메서드의 this와 일치시키기 위해서는 다음과 같은 방법을 사용한다.

```
var value = 1;

const obj = {
  value: 100,
  foo() {
    // this 바인딩(obj)을 변수 that에 할당한다.
    const that = this;

    // 콜백 함수 내부에서 this 대신 that을 참조한다.
    setTimeout(function () {
      console.log(that.value); // 100
    }, 100);
  }
};

obj.foo();
```

또한 Function.prototype.apply, Function.prototype.call, Function.prototype.bind 메서드를 활용한다. 또한 화살표 함수를 사용해서도 일치시킬 수 있다.

```
var value = 1;

const obj = {
  value: 100,
  foo() {
    // 콜백 함수에 명시적으로 this를 바인딩한다.
    setTimeout(function () {
      console.log(this.value); // 100
    }.bind(this), 100);
  }
};

obj.foo();

var value = 1;
```

```
const obj = {
  value: 100,
  foo() {
    // 화살표 함수 내부의 this는 상위 스코프의 this를 가리킨다.
    setTimeout(() => console.log(this.value), 100); // 100
  }
};

obj.foo();
```

### 22.2.2 메서드 호출

메서드 내부의 this에는 메서드를 호출한 객체가 바인딩 된다.

```
const person = {
  name: 'Lee',
  getName() {
    // 메서드 내부의 this는 메서드를 호출한 객체에 바인딩된다.
    return this.name;
  }
};

// 메서드 getName을 호출한 객체는 person이다.
console.log(person.getName()); // Lee
```

따라서 메서드가 가리키는 함수 객체는 다른 객체의 프로퍼티에 할당하는 것으로 다른 객체의 메서드가 되거나, 아니면 일반 함수로 만들수도 있다.

```
const anotherPerson = {
  name: 'Kim'
};
// getName 메서드를 anotherPerson 객체의 메서드로 할당
anotherPerson.getName = person.getName;

// getName 메서드를 호출한 객체는 anotherPerson이다.
console.log(anotherPerson.getName()); // Kim

// getName 메서드를 변수에 할당
const getName = person.getName;

// getName 메서드를 일반 함수로 호출
console.log(getName()); // ''
// 일반 함수로 호출된 getName 함수 내부의 this.name은 브라우저 환경에서 window.name과 같다.
// 브라우저 환경에서 window.name은 브라우저 창의 이름을 나타내는 빌트인 프로퍼티이며 기본값은 ''이다.
// Node.js 환경에서 this.name은 undefined다.
```

**따라서 메서드 내부의 this 는 호출한 객체에 바인딩된다.**
프로토타입 메서드 내부에서 사용된 this도 일반 메서드와 마찬가지로 해당 메서드를 호출한 객체에 바인딩 된다.

```
function Person(name) {
  this.name = name;
}

Person.prototype.getName = function () {
  return this.name;
};

const me = new Person('Lee');

// getName 메서드를 호출한 객체는 me다.
console.log(me.getName()); // ① Lee

Person.prototype.name = 'Kim';

// getName 메서드를 호출한 객체는 Person.prototype이다.
console.log(Person.prototype.getName()); // ② Kim
```

### 22.2.3 생성자 함수 호출

생성자 함수가 만들 인스턴스가 바인딩된다.

```
// 생성자 함수
function Circle(radius) {
  // 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.
  this.radius = radius;
  this.getDiameter = function () {
    return 2 * this.radius;
  };
}

// 반지름이 5인 Circle 객체를 생성
const circle1 = new Circle(5);
// 반지름이 10인 Circle 객체를 생성
const circle2 = new Circle(10);

console.log(circle1.getDiameter()); // 10
console.log(circle2.getDiameter()); // 20
```

new 연산자와 함께 사용하지 않는다면 일반함수로 동작하는데, 이때는 전역 객체가 바인딩된다.

```
// new 연산자와 함께 호출하지 않으면 생성자 함수로 동작하지 않는다. 즉, 일반적인 함수의 호출이다.
const circle3 = Circle(15);

// 일반 함수로 호출된 Circle에는 반환문이 없으므로 암묵적으로 undefined를 반환한다.
console.log(circle3); // undefined

// 일반 함수로 호출된 Circle 내부의 this는 전역 객체를 가리킨다.
console.log(radius); // 15
```

### 22.2.4 Function.prototype.apply/call/bind 에 의한 간접 호출

Function.prototype.apply, Function.prototype.call 메서드는 this로 사용할 객체와 인수리스트를 인수로 전달받아 함수를 호출하고, 첫번째 인수로 전달한 특정 객체를 호출한 함수의 this에 바인딩한다.

```
function getThisBinding() {
  return this;
}

// this로 사용할 객체
const thisArg = { a: 1 };

console.log(getThisBinding()); // window

// getThisBinding 함수를 호출하면서 인수로 전달한 객체를 getThisBinding 함수의 this에 바인딩한다.
console.log(getThisBinding.apply(thisArg)); // {a: 1}
console.log(getThisBinding.call(thisArg)); // {a: 1}
```

apply와 call 메서드를 사용해 함수 호출과 동시에 인수를 전달하면 다음과 같다.

```
function getThisBinding() {
  console.log(arguments);
  return this;
}

// this로 사용할 객체
const thisArg = { a: 1 };

// getThisBinding 함수를 호출하면서 인수로 전달한 객체를 getThisBinding 함수의 this에 바인딩한다.
// apply 메서드는 호출할 함수의 인수를 배열로 묶어 전달한다.
console.log(getThisBinding.apply(thisArg, [1, 2, 3]));
// Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]
// {a: 1}

// call 메서드는 호출할 함수의 인수를 쉼표로 구분한 리스트 형식으로 전달한다.
console.log(getThisBinding.call(thisArg, 1, 2, 3));
// Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]
// {a: 1}
```

arguments 객체는 배열이 아니라 배열의 메서드를 사용할 수 없지만, apply와 call메서드를 사용하면 가능하다.

```
function convertArgsToArray() {
  console.log(arguments);

  // arguments 객체를 배열로 변환
  // Array.prototype.slice를 인수없이 호출하면 배열의 복사본을 생성한다.
  const arr = Array.prototype.slice.call(arguments);
  // const arr = Array.prototype.slice.apply(arguments);
  console.log(arr);

  return arr;
}

convertArgsToArray(1, 2, 3); // [1, 2, 3]
```

Function.prototype.bind 메서드는 this로 사용할 객체만 전달한다.

```
function getThisBinding() {
  return this;
}

// this로 사용할 객체
const thisArg = { a: 1 };

// bind 메서드는 첫 번째 인수로 전달한 thisArg로 this 바인딩이 교체된
// getThisBinding 함수를 새롭게 생성해 반환한다.
console.log(getThisBinding.bind(thisArg)); // getThisBinding
// bind 메서드는 함수를 호출하지는 않으므로 명시적으로 호출해야 한다.
console.log(getThisBinding.bind(thisArg)()); // {a: 1}
```

bind메서드는 메서드의 this와 메서드 내부의 중첩 함수 혹은 콜백 함수의 this가 불일치하는 문제를 해결한다.

```
const person = {
  name: 'Lee',
  foo(callback) {
    // ①
    setTimeout(callback, 100);
  }
};

person.foo(function () {
  console.log(`Hi! my name is ${this.name}.`); // ② Hi! my name is .
  // 일반 함수로 호출된 콜백 함수 내부의 this.name은 브라우저 환경에서 window.name과 같다.
  // 브라우저 환경에서 window.name은 브라우저 창의 이름을 나타내는 빌트인 프로퍼티이며 기본값은 ''이다.
  // Node.js 환경에서 this.name은 undefined다.
});
```

1의 시점에서 this는 person객체를 가리킨다. 그러나 2에서는 this는 전역 객체를 가리킨다. 따라서 콜백함수 내부의 this와 외부 함수의 this를 일치시켜줘야 하는데, 이때 bind 메서드를 사용한다.

```
const person = {
  name: 'Lee',
  foo(callback) {
    // bind 메서드로 callback 함수 내부의 this 바인딩을 전달
    setTimeout(callback.bind(this), 100);
  }
};

person.foo(function () {
  console.log(`Hi! my name is ${this.name}.`); // Hi! my name is Lee.
});
```

| 함수 호출 방식                                             | this 바인딩                             |
| ---------------------------------------------------------- | --------------------------------------- |
| 일반 함수 호출                                             | 전역 객체                               |
| 메서드 호출                                                | 메서드를 호출한 객체                    |
| 생성자 함수 호출                                           | 인스턴스                                |
| Function.prototype.apply/call/bind 메서드에 의한 간접 호출 | 해당 메서드들에 첫째 인수로 전달한 객체 |

# 23장 실행 컨텍스트

> 실행 컨텍스트는 코드가 실행되는 환경(을 제공해주는 객체)이다.

## 23.1 소스코드의 타입

실행 컨텍스트는 소스코드의 타입에 따라 다른 실행 컨텍스트를 만든다.

- 전역 소스코드 - 전역 실행 컨텍스트(var 키워드 변수와 함수 선언문으로 선언된 함수를 전역 객체에 바인딩)
- 함수 소스코드 - 함수 실행 컨텍스트(지역 변수, 매개변수, arguments 객체 관리)

## 23.2 소스코드의 평가와 실행

JS엔진은 소스코드를 **평가**와 **실행**으로 나누어서 처리한다.

- 평가 과정: 실행 컨텍스트를 생성, 이후 선언문(변수, 함수 등)만 먼저 실행해서 생성된 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록한다.

- 실행 과정: 평가 과정 이후. 필요한 정보(변수 혹은 함수의 참조)를 실행 컨텍스트가 관리하는 스코프에서 검색해서 획득한다. 변수 값의 변경 등과 같은 실행 결과는 다시 스코프에 등록된다.

다음 예시를 살펴보자.

```
var x;
x=1;
```

1. 전역 코드 평가 과정에서 전역 실행 컨텍스트가 생성된다.
2. `var x`가 실행되어 `x`가 전역 실행 컨텍스트의 렉시컬 환경의 환경 레코드에 등록되고 `undefined`로 초기화된다.(정확히는 환경 레코드 안의 객체 환경 레코드).
3. 코드가 실행된다.
4. 선언문 `x=1`을 만나고 실행된다. 이때 `x`가 선언된 변수인지를 확인한다. 실행 컨텍스트의 스코프에 있으므로 환경 레코드에 등록된 `x`의 값이 1로 바뀐다.

## 23.3 실행 컨텍스트의 역할

다음의 코드가 어떻게 평가되고 실행될지를 생각해보자.

```
// 전역 변수 선언
const x = 1;
const y = 2;

// 함수 정의
function foo(a) {
  // 지역 변수 선언
  const x = 10;
  const y = 20;

  // 메서드 호출
  console.log(a + x + y); // 130
}

// 함수 호출
foo(100);

// 메서드 호출
console.log(x + y); // 3
```

1. 전역 코드 평가
   전역 실행 컨텍스트가 생성된다. 전역 선언문들이 먼저 실행되면서 전역 실행 컨텍스트의 렉시컬 환경의 환경 레코드에 등록된다. 이때 `var`로 선언된 변수와 함수 선언문으로 선언된 함수는 전역 객체의 프로퍼티와 메서드가 된다.(렉시컬 환경 - 환경 레코드 - 객체 환경 레코드)

2. 전역 코드 실행
   코드가 실행된다. 전역 변수에 값이 할당되고 함수들이 실행된다. 함수가 실행되면 전역 코드의 실행을 잠시 멈추고 주도권이 함수로 넘어간다.

3. 함수 코드 평가
   함수 실행 컨텍스트가 생성된다. 지역 변수, 매개변수, 함수 내부에서 정의된 함수들이 함수 실행 컨텍스트의 렉시컬 환경의 함수 환경 레코드에 등록된다. this바인딩도 이때 결정되는데, 위의 코드에서는 전역 객체가 바인딩된다.

4. 함수 코드 실행
   평가가 끝나고 차례대로 함수 코드가 실행된다. 지역 변수의 값들이 할당되고 `console.log`가 호출된다.<br> 이때 `console`을 스코프 체인을 통해서 있는지 확인한다. 현재 실행중인 실행 컨텍스트에는 없으므로 스코프 체인을 타고 위로 올라가는데, 사실 `console`은 전역 객체의 프로퍼티이다. 즉, 전역 객체의 프로퍼티를 마치 전역 변수처럼 검색이 가능하다는 뜻이다.<br> 그 후 `console`의 프로토타입 체인을 통해 `log`를 검색한다. 이후 `console.log`메서드에 전달된 `a + x + y`가 평가된다. 이 식별자들 역시 스코프 체인을 통해 검색된다. `console.log`의 실행이 종료되면 함수 코드의 실행도 종료되고, 다시 전역 코드로 돌아간다.

이처럼 코드의 실행을 위해서는 스코프를 구별해 식별자와 식별자에 바인딩 된 값이 구별되어야 한다. 검색을 위해서는 스코프 체인도 필요하고, 전역 객체의 프로퍼티도 전역 변수처럼 검색이 가능해야 한다. 이 모든 것을 관리하는 것이 **실행 컨텍스트**이다. 실행 컨텍스트는 ** 소스코드를 평가하고 실행하는데에 필요한 모든 정보(환경)을 제공하고 실행 결과를 실제로 관리하는 영역이다** 식별자와 스코프는 **렉시컬 환경**을 통해 관리하고, 실행 순서는 **실행 컨텍스트 스택(콜스택)** 을 통해 관리된다.

## 23.4 실행 컨텍스트 스택

```
const x = 1;

function foo () {
  const y = 2;

  function bar () {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}

foo(); // 6
```

위의 예제는 전역 코드를 평가해 전역 실행 컨텍스트를 생성하고, 함수 코드를 평가해 함수 실행 컨텍스트를 생성한다. 이떄 생성된 실행 컨텍스트들은 스택의 형태로 관리되는데, 이를 **실행 컨텍스트 스택(콜스택)**이라고 부른다.

예제가 거치는 과정은 다음과 같다.

1. 전역 코드 평가와 실행
   전역 코드가 평가되고 전역 실행 컨텍스트가 생성된다. 콜스택에 전역 실행 컨텍스트가 푸시된다. 변수 `x`와 함수 `foo`가 실행 컨텍스트의 렉시컬 환경의 환경 레코드의 객체 환경 레코드(`foo`)와 선언적 환경 레코드(`x`)에 각각 등록된다. `foo`는 함수로 바로 초기화된다. 이후 코드가 실행되어 `x`에는 1이 할당되고, `foo`가 실행되어 주도권이 함수 내부로 넘어간다.

2. `foo` 함수 코드 평가와 실행
   함수 코드가 평가되어 `foo` 함수 실행 컨텍스트가 생성된다. 콜스택에 `foo`함수 실행 컨텍스트가 푸시된다. 변수 `y`와 함수 `bar`가 함수 실행 컨텍스트의 렉시컬 환경의 함수 환경 레코드에 등록된다. `bar`는 함수로 바로 초기화된다. 이후 함수 코드가 실행되어 `y`엔 2가 할당이 되고, 함수 `bar`가 호출된다.

3. `bar`함수 코드 평가와 실행
   함수 코드가 평가되어 `bar` 함수 실행 컨텍스트가 생성된다. 콜스택에 `bar`함수 실행 컨텍스트가 푸시된다. 변수 `z`가 함수 실행 컨텍스트의 렉시컬 환경의 함수 환경 레코드에 등록된다. 이후 코드가 실행되어 `z`에 3이 할당되고 `console.log`를 호출한 후 종료된다.

4. `foo`함수로 복귀
   제어권이 다시 `foo`함수로 복귀한다. 콜스택에서 `bar`함수 실행컨텍스트가 팝되어 제거된다. `foo`함수 역시 실행할 코드가 없으므로 종료된다.

5. 전역 코드로 복귀
   `foo`함수의 실행 컨텍스트도 콜스택에서 팝되어 제거된다. 전역 코드도 더이상 실행할 코드가 없으므로 실행 컨텍스트가 팝되어 제거된다. 이제 콜스택에는 아무것도 남아있지 않다.

이처럼 ** 소스코드가 평가되어 실행 컨텍스트가 생기면 콜스택에 푸시되어 쌓인다. 콜스택의 최상위에 있는 실행 컨텍스트를 **실행중인 실행 컨텍스트\*\*라고 부른다.

## 23.5 렉시컬 환경

> 식별자와 식별자에 바인딩 된 값, 상위 스코프에 대한 참조를 기록하는 자료구조이다. 즉, 식별자와 스코프를 관리한다.

렉시컬 환경의 키와 값을 가지는 객체 형태의 스코프를 생성하여 식별자를 키로 식별자에 바인딩된 값을 관리한다. 즉, 렉시컬 환경은 렉시컬 스코프의 실체이다.<br>
실행 컨텍스트는 **렉시컬 환경(Lexical Environment)과 변수 환경(Variable Environment)로 구성된다.** 생성 초기에 이 둘은 동일한 렉시컬 환경을 참조한다. 이후 몇가지 상황을 만나면 Variable Environment을 위한 렉시컬 환경을 생성하고, 이떄부터 이 둘은 그 내용이 달라질 수도 있다.

렉시컬 환경은 **환경 레코드(Environment Record)와 외부 렉시컬 환경에 대한 참조(Outer Lexical Environment Reference), 이 두개의 컴포넌트로 구성된다.**

- 환경 레코드: 식별자를 등록하고 바인딩 된 값을 관리하는 저장소.
- 외부 렉시컬 환경에 대한 참조: 상위 스코프를 참조한다. 이를 통해 스코프 체인을 구현한다.

## 23.6 실행 컨텍스트 생성과 식별자 검색 과정

```

var x = 1;
const y = 2;

function foo (a) {
  var x = 3;
  const y = 4;

  function bar (b) {
    const z = 5;
    console.log(a + b + x + y + z);
}
  bar(10);
}

foo(20); // 42
23-05
```

### 23.6.1 전역 객체 생성

** 전역 객체는 전역 코드 평가 전에 생성된다.** 빌트인 전역 프로퍼티와 빌트인 전역 함수, 표준 빌트인 객체가 추가되며 동작 환경에 따라 클라이언트 사이드 API, 또는 호스트 객체가 포함된다. 전역 객체도 `Object.prototype`을 상속받는다. 이는 곧 스코프 체인에 포함이 된다는 의미이다.

### 23.6.2 전역 코드 평가

전역 코드 평가는 다음과 같은 순서이다.

1. 전역 실행 컨텍스트 생성
2. (전역) 렉시컬 환경 생성

- 2.1 (전역) 환경 레코드 생성
  - 2.1.1 객체 환경 레코드 생성
  - 2.1.2 선언적 환경 레코드 생성
- 2.2 this 바인딩
- 2.3 외부 렉시컬 환경에 대한 참조 결정

#### 1. 전역 실행 컨텍스트 생성

전역 코드가 평가되어 전역 실행 컨텍스트가 생성되고, 콜스택에 푸시된다. 이는 실행중인 실행 컨텍스트가 된다.

#### 2. 전역 렉시컬 환경 생성

전역 렉시컬 환경이 생성되어 전역 실행 컨텍스트에 바인딩된다.

#### 2.1 전역 환경 레코드 생성

전역 환경 레코드는 전역 스코프와 전역 객체의 빌트인 전역 프로퍼티와 빌트인 전역 함수, 표준 빌트인 객체를 제공한다. 전역 환경 레코드는 객체 환경 레코드와 선언적 환경 레코드로 구성된다.

- 객체 환경 레코드: `var`로 선언한 전역 변수와 함수 선언문으로 선언된 전역 함수, 빌트인 전역 프로퍼티와 빌트인 전역 함수, 표준 빌트인 객체를 관리
- 선언적 환경 레코드: `let`, `const`로 선언한 전역 변수를 관리한다.

이 둘이 협력하여 전역 스코프와 전역 객체를 관리한다.

#### 2.1.1 객체 환경 레코드 생성

객체 환경 레코드는 `BindingObejct`라는 객체와 연결된다. 이 객체는 전역 코드 평가 전 만들어진 전역 객체이다. `var`로 선언된 전역 변수와 함수 선언문으로 선언된 전역 함수는 `BindingObject`를 통해 전역 객체에 프로퍼티와 메서드로 등록된다. 위 예제에서는 변수 `x`와 함수 `foo`가 그렇다.<br>
`x`는 선언과 초기화가 동시에 이루어진다. 즉, 객체 환경 레코드에 바인딩 된 `BindingObject`를 통해 전역 객체에 변수 식별자 `x`를 키로 등록하고, 암묵적으로 `undefined`를 바인딩한다. 따라서 변수 선언문 전에도 전역 객체의 프로퍼티로써 참조할 수 있는 것이다. 이것이 변수 호이스팅이 발생하는 원인이다. <br>
`foo` 역시 함수 이름과 동일한 이름의 식별자가 객체 환경 레코드에 바인딩된 `BindingObejct`를 통해 전역 객체의 키로 등록되고 생성된 함수 객체를 즉시 할당한다. 이것이 변수 호이스팅과 함수 호이스팅의 차이이다. 따라서 함수 선언문으로 선언한 함수는 선언문 이전에도 호출할 수 있다.(따라서 함수 선언문을 가독성 때문에 지양하자는 의견도 있다.)
<br>

#### 2.1.2 선언적 환경 레코드 생성

`let` 과 `const`로 선언한 변수와 함수는 선언적 환경 레코드에 등록되고 관리된다. `let` 과 `const`가 존재하는 개념적인 블록이 바로 선언적 환경 레코드인 것이다. 따라서 예제의 변수 `y`는 전역 변수의 프로퍼티로서 참조할 수 없다. 따라서 변수 선언문(초기화 단계) 도달하기 전에 참조할 수 없는데 이 구간을 일시적 사각지대(TDZ)라고 부른다.

#### 2.2 this 바인딩

전역 환경 레코드의 [[GlobalThisValue]] 내부 슬롯에 this가 바인딩된다. 전역 코드의 this는 전역 객체를 가리키므로 [[GlobalThisValue]]에는 전역 객체가 바인딩된다. this 바인딩은 전역 환경 레코드와 함수 환경 레코드에만 존재한다. 따라서 객체 환경 레코드와 선언적 환경 레코드에는 this 바인딩이 존재하지 않는다.

#### 2.3 외부 렉시컬 환경에 대한 참조

상위 스코프를 가리킨다. 이를 통해 단방향 스코프 체인을 구현할 수 있다.
전역 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에는 `null`이 할당된다. 이는 전역 렉시컬 환경이 스코프 체인의 종점에 위치함을 의미한다.

### 23.6.3 전역 코드 실행

전역 코드가 실행되어 `x`와 `y`에 값이 할당되고, `foo`함수가 호출된다. 이때 코드의 식별자가 등록되어 있는지를 확인해야 하는데 이를 **식별자 검색**이라고 한다. 식별자 결정을 위해 실행 중인 컨텍스트에서 식별자를 검색하기 실행한다. 발견하지 못하면 외부 렉시컬 환경에 대한 참조가 가리키는 상위 렉시컬 환경(=상위 스코프)로 이동하여 검색한다. 이것이 스코프 체이닝의 원리이다. 단, 전역 코드의 경우 식별자를 발견하지 못하면 `Reference Error`를 발생시킨다.

### 23.6.4 foo함수 평가

현재 `foo`함수를 호출되면 제어권은 `foo`함수 내부로 이동하게 되고 함수 코드를 평가한다. 과정은 다음과 같다.

1. 함수 실행 컨텍스트 생성
2. 함수 렉시컬 환경 생성

- 2.1 함수 환경 레코드 생성
- 2.2 this 바인딩
- 2.3 외부 렉시컬 환경에 대한 참조 결정

#### 1. 함수 실행 컨텍스트 생성

함수 실행 컨텍스트는 함수 렉시컬 환경이 완성된 다음 콜스택에 푸시되고 실행중인 실행 컨텍스트가 된다.

#### 2. 함수 렉시컬 환경 생성

`foo` 함수 렉시컬 환경을 생성하고 `foo` 함수 실행 컨텍스트에 바인딩한다. 함수 렉시컬 환경은 함수 환경 레코드와 외부 렉시컬 환경에 대한 참조로 구성된다.

#### 2.1 함수 환경 레코드

매개변수, 지역변수, 함수 내부에서 정의된 함수, arguments 객체를 등록하고 관리한다.

#### 2.2 this 바인딩

함수 환경 레코드의 [[ThisValue]] 내부 슬롯에 this가 바인딩된다. this는 함수 호출 방식에 따라 경정되는데, 여기서는 일반 함수로 호출되었으므로 this에는 전역 객체 (=`window`)가 바인딩된다. 따라서 foo 내부에서 this를 참조하면 [[ThisValue]]에 바인딩 된 전역 객체가 반환된다.

#### 2.3 외부 렉시컬 환경에 대한 참조 결정

`foo`함수 정의가 평가된 시점에 실행중인 실행 컨텍스트의 렉시컬 환경이 바인딩 된다.... 넘 어려운 말인데 함수가 정의됐을떄의 실행컨텍스트가 뭐였는지를 생각하면 된다. 따라서 여기서는 전역 렉시컬 환경이 바인딩 된다.

JS엔진은 함수의 상위 스코프를 함수 객체의 내부 슬롯 [[Environment]]에 저장한다. 함수 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 할당되는 것은 함수 객체의 내부 슬롯 [[Environment]]에 저장된 렉시컬 환경의 참조이다. 즉 [[Environment]] 이 렉시컬 스코프를 구현하는 메커니즘이다.

### 23.6.5 foo 함수 실행

런타임이 되어 `foo`함수의 소스코드가 실행된다. 매개변수에 인수가 할당되고, 변수 할당문이 실행되어 변수 `x`와 `y`에 값이 할당된다. 그리고 함수 `bar`가 호출된다. 이떄 식별자 결정을 위해 `bar`가 실행중인 실행 컨텍스트의 렉시컬 환경에서 검색되기 시작한다. 여기서는 검색이 되므로 `bar`에 값이 바인딩된다.

### 23.6.6 bar 함수 코드 평가

`bar`함수가 실행되면 제어권이 `bar`함수 내부로 이동한다. 그리고 `bar`함수를 평가하고, `foo`함수처럼 실행 컨텍스트가 생성된다.

### 23.6.7 bar 함수 실행

평가가 끝나면 `bar`함수의 코드가 순차적으로 실행된다. 매개변수에 인수가 할당되고, 변수 할당문이 실행되어 `z`에 값이 할당된다. `console.log`가 실행된다.

#### 1. console 식별자 검색

`console`이라는 식별자를 스코프 체인에서 검색하는데, 현재 실행중인 실행 컨텍스트의 렉시컬 환경에서는 찾을 수 없으므로 외부 렉시컬 환경에 대한 참조(`foo`의 렉시컬 환경)로 이동해 검색한다. 여기에도 없으므로 전역 렉시컬 환경으로 이동해 검색하는데, 객체 환경 레코드의 `BindingObject`를 통해 전역 객체에서 찾을 수 있다.

#### 2. log 메서드 검색

`console`객체의 프로토타입 체인을 통해 `log`를 검색한다. `console`객체의 프로퍼티이다.

#### 3. 표현식 a + b + x + y + z 평가

`a, b, x, y, z`식별자를 검색한다. 이 또한 현재 실행중인 실행 컨텍스트의 렉시컬 환경~ 외부 렉시컬 환경에 대한 참조를 통해 검색한다.

#### 4. console.log 메서드 호출

표현식이 평가된 값 42를 `console.log`에 전달해 호출한다.

### 23.6.8 bar 함수 코드 실행 종료

`console.log`이후 실행할 코드가 없으므로 `bar`함수 코드 실행이 종료된다. 콜스택에서 `bar`함수 실행 컨텍스트가 팝되어 사라지고 `foo`실행 컨텍스트가 실행중인 컨텍스트가 된다.

이때 주의할 점은 `bar`함수 렉시컬 환경까지 즉시 소멸하는 것은 아니다. 렉시컬 환경은 참조될 뿐, 엄연히 독립적인 객체이다. 따라서 가비지 콜렉터에 의해 일정 시간이 지나면 메모리 공간이 해제되어 소멸한다. 즉, 누군가 `bar`의 렉시컬 환경의 참조하고 있다면 이는 사라지지 않는다.

### 23.6.9 foo 함수 코드 실행 종료

`foo`함수 역시 더이상 실행할 코드가 없으므로 종료되고 콜스택에서 팝되어 사라진다. 실행중인 실행 컨텍스트는 전역 실행 컨텍스트가 된다.

### 23.6.19 전역 코드 실행 종료

역시 마찬가지로 실행할 코드가 없어 종료된다. 전역 실행 컨텍스트도 팝되어 사라지며 콜스택에는 아무것도 남아있지 않게 된다.

## 23.7 실행 컨텍스트와 블록 레벨 스코프

```
let x = 1;

if (true) {
  let x = 10;
  console.log(x); // 10
}

console.log(x); // 1
```

`if`문의 내부에서 `let`키워드를 사용해 변수를 선언했으므로 `if`문을 위한 블록 레벨 스코프를 새엇ㅇ해야 한다. 이를 위해 선언적 환경 레코드를 가지는 렉시컬 환경을 새롭게 생성해 기존의 렉시컬 환경을 교체한다. 이때 새로운 렉시컬 환경의 외부 렉시컬 환경에 대한 참조는 기존의 렉시컬 환경을 가리킨다. 이는 모든 블록 레벨 스코프를 만드는 블록문에 적용된다.

`for`문의 경우 변수 선언에 `let`을 사용했으면 코드 블록이 반복되서 실행될때마다 코드 블록을 위한 새로운 렉시컬 환경을 생성한다. `for`문 내부에서 정의된 함수는 `for`문의 코드블록이 생성한 렉시컬 환경을 상위 스코프로 가진다. 이때 함수의 상위 스코프는 `for`문이 반복될 때마다 식별자(`for`문의 변수 선언문 및 `for`의 코드 블록 내부에서 선언된 지역 변수)의 값을 유지해야 한다.이를 위해 `for`문의 코드 블록이 반복되서 실행될 때마다 독립적인 렉시컬 환경을 생성해 식별자의 값을 항상 유지한다.

# 24장 클로저

MDN에서는 클로저를 다음과 같이 정의하고 있다.

> 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.

## 24.1 렉시컬 스코프

> 자바스크립트는 함수를 어디서 호출했느냐가 아닌 어디서 정의했느냐에 따라 상위 스코프를 결정한다. 이를 렉시컬 스코프라고 한다.

```
const x = 1;

function foo() {
  const x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // ?
bar(); // ?
```

`foo`함수와 `bar`함수는 전역 함수이다. 자바스크립트는 렉시컬 스코프 이므로 `foo`와 `bar`의 상위 스코프는 전역 스코프이다.

스코프의 실체는 실행 컨텍스트의 렉시컬 환경이다(렉시컬 환경의 함수 환경 레코드 혹은 전역 환경 레코드(선언적, 객체)에서 검색, 없으면 외부 렉시컬 환경에 대한 참조로 검색).

따라서 `함수의 상위 스코프를 결정한다`라는 말은 `외부 렉시컬 환경에 대한 참조값을 무엇으로 할지 결정한다`라는말과 같고, 이는 즉

> 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조값, 그러니까 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 위치에 따라 결정된다.

## 24.2 함수 객체의 내부 슬롯 [[Environment]]

함수는 스스로가 정의된 환경을 기억하기 위해서 함수 객체 내부의 `[[Environment]]`에 자신이 정의된 환경 = 상위 스코프의 참조를 저장한다. 즉, `[[Environment]]`에는 현재 실행중인 실행 컨텍스트의 렉시컬 환경이 저장된다.

함수 내부에 정의된 함수의 경우 외부 함수가 실행되는 시점에 평가되어 함수 객체를 형성하는데, 이 내부 함수의 `[[Environment]]` 슬롯에는 외부 함수의 실행컨텍스트의 렉시컬 환경이 참조값으로 저장된다.

따라서 함수 객체의 `[[Environment]]`에 저장되는 현재 실행중인 실행 컨텍스트의 렉시컬 환경이 바로 상위 스코프이다. 이는 곧 자신이 호출되었을 때 생성될 실행 컨텍스트의 렉시컬 환경의 외부 렉시컬 환경에 대한 참조값이기도 하다. 함수 객체는 `[[Environment]]`에 저장한 상위 스코프를 자신이 존재하는 한 기억한다.

```
const x = 1;

function foo() {
  const x = 10;

  // 상위 스코프는 함수 정의 환경(위치)에 따라 결정된다.
  // 함수 호출 위치와 상위 스코프는 아무런 관계가 없다.
  bar();
}

// 함수 bar는 자신의 상위 스코프, 즉 전역 렉시컬 환경을 [[Environment]]에 저장하여 기억한다.
function bar() {
  console.log(x);
}

foo(); // ?
bar(); // ?
```

`foo`와 `bar`는 전역에서 정의되었으므로 둘 다 `window`의 객체가 된다. 이때 생성된 함수 객체의 `[[Environment]]` 슬롯에는 현재 실행중인 실행 컨텍스트 = 전역 실행 컨텍스트의 렉시컬 환경의 참조가 저장된다.

이후 `foo`함수가 참조되면서 코드의 제어권이 함수 내부로 이동해 평가해 다음과 같은 과정을 거친다.

> 함수 실행 컨텍스트 생성 - 함수 렉시컬 환경 생성(함수 환경 레코드 생성 - this 바인딩 - 외부 렉시컬 환경에 대한 참조 결정)

이때 **외부 렉시컬 환경에 대한 참조에는 함수 객체의 내부 슬롯 `[[Environment]]`에 참조된 렉시컬 환경의 참조가 할당된다.** 이것이 바로 렉시컬 스코프의 실체이다.

## 24.3 클로저와 렉시컬 환경

```
const x = 1;

// ①
function outer() {
  const x = 10;
  const inner = function () { console.log(x); }; // ②
  return inner;
}

// outer 함수를 호출하면 중첩 함수 inner를 반환한다.
// 그리고 outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 팝되어 제거된다.
const innerFunc = outer(); // ③
innerFunc(); // ④ 10
```

여기서 `outer` 는 호출되었을 때 내부에서 정의한 `inner`를 반환하고 생명주기를 마감한다. 즉, 콜스택에서 팝되어 사라진다. 이때 내부에서 정의된 변수 `x`또한 생명 주기를 마감해서 이에 접근할 방법은 없어 보인다.

하지만, `innerFunc`의 호출 결과는 놀랍게도 `10`이다. 이미 생명주기를 마감한 변수에 접근해 값을 참조한 것이다.

> 이렇게 외부 함수보다 중첩 함수가 더 오래 유지되는 경우, 중첩 함수는 이미 생명주기가 끝난 외부 함수의 변수를 참조할 수 있다. 이를 **클로저**라고 한다.

즉, 콜스택에서 팝된 실행 컨텍스트의 렉시컬 환경을 참조하는 것이다. 어떻게 이럴수 있는 것일까?

자바스크립트의 모든 함수는 자신의 상위 스코프를 `[[Environment]]`에 저장하고 기억한다. 따라서 `inner` 함수는 자신이 평가될때 자신이 정으된 위치에 의해 결정된 상위 스코프를 `[[Environment]]`에 저장한다. 이 스코프는 함수가 존재하는 한 유지된다.

다시 코드를 보면, `outer`함수가 평가될 때 전역 렉시컬 환경의 `outer`함수 객체의 `[[Environment]]`에 상위 스코프로서 저장한다.

`outer` 함수를 호출하면 `outer` 함수 실행 컨텍스트가 생성되고, `outer`의 `[[Environment]]`에 저장된 값을 `외부 렉시컬 환경에 대한 참조`에 할당한다. 이후 중첩함수 `inner`가 평가된다. 이때 중첩함수 `inner`또한 자신의 상위 스코프, 즉 `outer`함수의 렉시컬 환경을 `[[Environment]]`에 상위 스코프로 저장한다.

`outer` 함수 실행이 종료되면 `inner` 함수가 반환되면서 `outer`함수의 생명 주기가 마감된다. 즉 콜스택에서 팝되어 사라진다. 이때 실행컨텍스트는 스택에서 팝되어 사라지더라도 실행 컨텍스트의 렉시컬 환경까지 제거되는 것은 아니다. `inner`함수의 `[[Environment]]`에 의해 참조되고 있기 때문이다.

`inner`함수를 호출하면 `inner`함수 실행 컨텍스트가 생성된다. 이때 `외부 렉시컬 환경에 대한 참조`에는 `inner`의 `[[Environment]]`에 참조된 값이 할당된다.

중첩함수 `inner`는 외부 함수 `outer`보다 오래 생존했다. 외부 함수보다 오래 생존하는 중첩 함수는 외부 함수의 생존 여부, 그러니까 콜 스택에 외부 함수의 실행 컨텍스트가 있는가에 상관없이 자신이 정의된 위치에 의해 결정된 상위 스코프를 결정한다. 그러므로 `inner`함수는 `outer`함수의 지역 변수를 참조하고, 재할당 할수도 있는 것이다.

자바스크립트의 모든 함수는 자신의 상위 스코프를 기억하는데, 그럼 모든 함수가 클로저일까 일반적으로 모든 함수를 클로저라고 하지는 않는다. 중첩함수여도 상위 스코프의 어떤 식별자도 참조하지 않는 경우 모단 브라우저는 상위 스코프를 기억하지 않는다. 참조하지도 않는 식별자를 기억하는 것은 메모리 낭비이기 때문이다. 또한 다음의 예제를 보자.

```
    function foo() {
      const x = 1;

      // 일반적으로 클로저라고 하지 않는다.
      // bar 함수는 클로저였지만 곧바로 소멸한다.
      function bar() {
        debugger;
        // 상위 스코프의 식별자를 참조한다.
        console.log(x);
      }
      bar();
    }

    foo();
```

위의 예제처럼 중첩 함수(`bar`)가 외부 함수(`foo`)보다 일찍 종료되는 경우도 클로저라고 부르지 않는다. 외부 함수의 생명 주기가 중첩 함수의 생명 주기보다 길기 때문이다. 이는 **생명주기가 끝난 외부 함수의 지역 변수를 참조할 수 있다**라는 클로저의 본질에 맞지 않기 때문이다.

```
    function foo() {
      const x = 1;
      const y = 2;

      // 클로저
      // 중첩 함수 bar는 외부 함수보다 더 오래 유지되며 상위 스코프의 식별자를 참조한다.
      function bar() {
        debugger;
        console.log(x);
      }
      return bar;
    }

    const bar = foo();
    bar();
```

중첩함수 `bar`는 외부 함수 `foo`보다 오래 생존하고, 외부 함수의 지역 변수 `x`또한 참조한다. 이러한 중첩 함수를 클로저라고 부른다. **클로저는 중첩 함수가 상위 스코프를 참조하고, 외부 함수보다 더 오래 생존해 있을 때로 한정하는 것이 일반적이다.**

클로저에 의해 참조되는 지역변수를 **자유 변수**라고 부른다. 즉, 클로저란 **함수가 자유 함수에 의해 묶여있다**라는 뜻이다. 다만, 외부 함수의 변수 중에서 참조되지 않는 변수는 기억되지 않는다. 즉, 불필요한 메모리를 사용하지 않는다.

## 24.4 클로저의 활용

> 클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다. 상태가 의도치 않게 변경되는 것을 막도록 은닉하고 특정 함수에게만 변경을 허용하는 것이다.

```
// 카운트 상태 변수
let num = 0;

// 카운트 상태 변경 함수
const increase = function () {
  // 카운트 상태를 1만큼 증가 시킨다.
  return ++num;
};

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

위의 예제는 함수 `increase`로 상태 `num`를 증가시킨다. 하지만, 위 코드가 오류없이, 예측대로 동작하려면 다음과 같은 전제가 필요하다.

- `num`은 `increase`에 의해서만 변경 가능해야 한다.

하지만 `num`은 전역 변수이기 때문에 누구나 참조하고 재할당 할 수 있다. 이는 의도치 않은 변경이 있을 수도 있음을 의미한다. 따라서 `increase` 함수만이 `num`을 참조하고 재할당 할 수 있드록 하는 것이 좋다.

```
const increase = funciton () {
  let num = 0;

  return ++num
}

cosnole.log(increase());
cosnole.log(increase());
cosnole.log(increase());
```

위의 코드에서는 `num`의 의도치 않은 변경을 예방했다. 하지만, `increase`함수를 호출할 때마다 항상 `1`을 반환한다. 지역변수 `num`이 `increase`가 호출될 때마다 다시 선언되기 때문이다. 이를 방지하기 위해서 클로저를 사용해보자.

```
const increase = (function () {
  let num = 0;

  return function () {
    return ++num
  }
}())

console.log(increase());
console.log(increase());
```

`increase`는 즉시 실행 함수의 결과인 익명 함수를 할당받는다. 이 함수는 즉시 실행 함수의 렉시컬 환경을 기억하는 클로저이다. 따라서 어디서든 `num`을 참조하고 재할당 할 수 있다.
즉시 실행 함수는 딱 한번만 호출되어 실행되므로 `num`이 초기화 될 일은 없다. 또한 외부에서도 접근 할 수 없기 때문에 안정적인 프로그램이이 가능하다.

> 이처럼 클로저는 상태를 안전하게 은닉하고, 특정 함수에게만 상태 변경을 허용하여 상태를 보호하기 위해 사용된다.

## 24.5 캡슐화와 정보 은닉

> 캡슐화는 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작하는 동작인 메서드를 하나로 묶는 것을 말한다.

캡슐화는 프로퍼티 혹은 메서드를 숨길 목적으로 사용하기도 하는데 이를 정보 은닉이라고 한다. 정보 은닉은 정보를 보호하고, 상호 의존성을 낮추는 효과가 있다.

자바스크립트에서는 접근 제한자를 제공하지 않기 때문에 기본적으로 객체의 모든 프로퍼티와 메스드는 누구나 접근할 수 있다.

```
function Person(name, age) {
  this.name = name; // public
  let _age = age;   // private

  // 인스턴스 메서드
  this.sayHi = function () {
    console.log(`Hi! My name is ${this.name}. I am ${_age}.`);
  };
}

const me = new Person('Lee', 20);
me.sayHi(); // Hi! My name is Lee. I am 20.
console.log(me.name); // Lee
console.log(me._age); // undefined

const you = new Person('Kim', 30);
you.sayHi(); // Hi! My name is Kim. I am 30.
console.log(you.name); // Kim
console.log(you._age); // undefined
```

위 예제의 `name`은 누구나 참조하고 재할당 할 수 있다. 하지만 `_age`는 보호된다.
위 예제의 `sayHi`는 인스턴스 메서드이므로 중복 생성된다. 이를 방지해보자.

```
function Person(name, age) {
  this.name = name; // public
  let _age = age;   // private
}

// 프로토타입 메서드
Person.prototype.sayHi = function () {
  // Person 생성자 함수의 지역 변수 _age를 참조할 수 없다
  console.log(`Hi! My name is ${this.name}. I am ${_age}.`);
};
```

하지만 이제는 `sayHi`메서드가 지역 변수 `_age`를 참조할 수 없는 문제가 생긴다. 따라서 즉시 실행 함수를 사용해 이를 모아보자.

```
const Person = (function () {
  let _age = 0; // private

  // 생성자 함수
  function Person(name, age) {
    this.name = name; // public
    _age = age;
  }

  // 프로토타입 메서드
  Person.prototype.sayHi = function () {
    console.log(`Hi! My name is ${this.name}. I am ${_age}.`);
  };

  // 생성자 함수를 반환
  return Person;
}());

const me = new Person('Lee', 20);
me.sayHi(); // Hi! My name is Lee. I am 20.
console.log(me.name); // Lee
console.log(me._age); // undefined

const you = new Person('Kim', 30);
you.sayHi(); // Hi! My name is Kim. I am 30.
console.log(you.name); // Kim
console.log(you._age); // undefined
```

여기서 `sayHi`메서드는 즉시 실행 함수가 종료된 후 지역변수 `_age`를 참조하는 클로저이다.
하지만 위 코드도 문제가 있는데, 여러개의 인스턴스를 생성할 경우 `_age`의 상태가 유지되지 않는다는 점이다.

```
const me = new Person('Lee', 20);
me.sayHi(); // Hi! My name is Lee. I am 20.

const you = new Person('Kim', 30);
you.sayHi(); // Hi! My name is Kim. I am 30.

// _age 변수 값이 변경된다!
me.sayHi(); // Hi! My name is Lee. I am 30.
```

이는 `sayHi` 메서드가 단 한번 생성되는 클로저이기 때문에 생기는 문제점이다. 인스턴스를 여러개 생성하더라도, `sayHi`는 하나의 상위 스코프만을 공유한다.
이처럼 자바스크립트는 정보 은닉을 완전하게 지원하지는 않는다. 이를 위한 대안으로 class에 private 필드를 정의할 수 있는 표준 사양이 정의되고 구현되어 있다.

## 24.6 자주 발생하는 실수

```
var funcs = [];

for (var i = 0; i < 3; i++) {
  funcs[i] = function () { return i; }; // ①
}

for (var j = 0; j < funcs.length; j++) {
  console.log(funcs[j]()); // ②
}
```

0, 1, 2를 콘솔에 찍을 것이라고 기대한 것과는 달리 3을 세번 출력한다. 원인은 단순한데, `i`가 `var`로 선언되었기 때문에 전역변수가 된 것이다. 따라서 증가한 `i`값 3이 3번 출력되는 것이다.
이를 바르게 동작하는 코드로 만들어보면

```
var funcs = [];

for (var i = 0; i < 3; i++){
  funcs[i] = (function (id) { // ①
    return function () {
      return id;
    };
  }(i));
}

for (var j = 0; j < funcs.length; j++) {
  console.log(funcs[j]());
}
```

전역 변수 `i`에 할당된 값을 인수로 전달받아 매개변수 `id`에 할당한 후 중첩 함수를 반환하고 종료하는 즉시 실행 함수를 사용했다. 중첩 함수는 즉시 실행 함수의 렉시컬 환경을 외부 렉시컬 환경에 대한 참조로 기억한다. 즉시 실행 함수는 반복문이 실행될 때마다 새롭게 만들어져 실행되기 때문에 전달한 `id`값이 유지되는 것이다.

그런데 사실 위 문제는 그냥 `var`키워드를 사용했기 때문에 발생하는 문제이다. `let`키워드를 사용하면 간단하게 해결된다.

```
const funcs = [];

for (let i = 0; i < 3; i++) {
  funcs[i] = function () { return i; };
}

for (let i = 0; i < funcs.length; i++) {
  console.log(funcs[i]()); // 0 1 2
}
```

`for`문이 반복될 때마다 새로운 렉시컬 환경이 생성된다. 이때 내부에서 정의된 함수가 있다면 이 함수의 상위 스코프는 `for`문이 생성한 새로운 렉시컬 환경이다.
이때 상위 스코프는 `for`문의 코드 블록이 생성될 때마다 식별자의 값을 유지해야 한다. 이를 위해 반복 시마다 독립적인 렉시컬 환경을 생성하여 식별자 값을 유지한다.

1. `for`문의 변수 선언문에서 `let`으로 선언한 초기화 변수를 사용한 `for`문이 평가되면 먼저 새로운 렉시컬 환경을 생성하고 초기화 변수 식별자와 값을 등록한다. 그리고 현재 실행중인 실행 컨텍스트의 렉시컬 환경을 해당 렉시컬 환경으로 교체한다.

2. `for`문의 코드 블록이 반복 실행되면 새로운 렉시컬 환경을 생성하고 `for`문의 코드 블록의 식별자와 값을 등록한다. 이렇게 생성한 렉시컬 환경을 현재 실행중인 실행 컨텍스트의 렉시컬 환경으로 교체해준다.

3. 모든 반복이 끝나면 반복 전 렉시컬 환경을 실행중인 실행 컨텍스트의 렉시컬 환경으로 되돌린다.

이처럼 `let` 혹은 `const`를 사용하는 반복문은 코드 블록을 반복 실행할 때마다 새로운 렉시컬 환경을 만들어 반복할 당시의 상태를 스냅숏을 찍는 것처럼 저장한다. 반복문 코드 블록 내부에서 함수를 정의할 때 의미가 있다. 반복문의 코드 블록 내부에 함수 정의가 없다면 해당 렉시컬 환경은 아무도 참조하지 않기 때문에 가비지 컬렉션의 대상이 된다.

또 다른 방법으로는 고차 함수의 사용이 있다.

```
// 요소가 3개인 배열을 생성하고 배열의 인덱스를 반환하는 함수를 요소로 추가한다.
// 배열의 요소로 추가된 함수들은 모두 클로저다.
const funcs = Array.from(new Array(3), (_, i) => () => i); // (3) [ƒ, ƒ, ƒ]

// 배열의 요소로 추가된 함수 들을 순차적으로 호출한다.
funcs.forEach(f => console.log(f())); // 0 1 2
```

# 26장 ES6 함수의 추가 기능

## 26.1 함수의 구분

ES6 이전까지 함수는 별 구분없이 다양한 목적으로 호출되었다. 즉, 하나의 함수를 일반함수로 호출하거나, 생성자 함수로서 호출하고(with `new`), 객체에 바인딩해 메서드로 호출할 수도 있다.

```
var foo = function () {
  return 1;
};

// 일반적인 함수로서 호출
foo(); // -> 1

// 생성자 함수로서 호출
new foo(); // -> foo {}

// 메서드로서 호출
var obj = { foo: foo };
obj.foo(); // -> 1
```

**한마디로, ES6 이전의 함수는 목적에 따른 명확한 구분이 없었다. 모든 함수가 `callable`이며 `constructor`였다.**

```
// 프로퍼티 f에 바인딩된 함수는 callable이며 constructor다.
var obj = {
  x: 10,
  f: function () { return this.x; }
};

// 프로퍼티 f에 바인딩된 함수를 메서드로서 호출
console.log(obj.f()); // 10

// 프로퍼티 f에 바인딩된 함수를 일반 함수로서 호출
var bar = obj.f;
console.log(bar()); // undefined

// 프로퍼티 f에 바인딩된 함수를 생성자 함수로서 호출
console.log(new obj.f()); // f {}
```

물론 위 경우가 흔한 경우는 아니지만, 가능하다는 것 자체가 문제가 있다. 또한 모든 함수가 프로토타입을 만들기 때문에 성능 면에서도 손해이다(안만들어도 될 프로토타입을 만듦).

**ES6에서는 이러한 문제를 해결하기 위해 함수를 사용 목적에 따라 세가지로 구분했다.**

| ES6 함수 구분 | `constructor` | `prototype` | `super` | `arguments` |
| ------------- | ------------- | ----------- | ------- | ----------- |
| 일반 함수     | O             | O           | O       | O           |
| 메서드        | X             | X           | O       | O           |
| 화살표 함수   | X             | X           | X       | X           |

## 26.2 메서드

> ES6 사양에서 메서드는 메서드 축약 표현으로 객체 내부에서 정의된 함수만을 의미한다.

```
const obj = {
  x: 1,
  // foo는 메서드이다.
  foo() { return this.x; },
  // bar에 바인딩된 함수는 메서드가 아닌 일반 함수이다.
  bar: function() { return this.x; }
};

console.log(obj.foo()); // 1
console.log(obj.bar()); // 1
```

ES6 사양의 메서드는 인스턴스를 생성할 수 없다(`non-constructor`). 따라서 생성자 함수로 호출할 수 없다.

```
new obj.foo(); // -> TypeError: obj.foo is not a constructor
new obj.bar(); // -> bar {}
```

인스턴스를 생성할 수 없으니 `prototype`프로퍼티가 없고, 프로토타입도 생성하지 않는다.

```
// obj.foo는 constructor가 아닌 ES6 메서드이므로 prototype 프로퍼티가 없다.
obj.foo.hasOwnProperty('prototype'); // -> false

// obj.bar는 constructor인 일반 함수이므로 prototype 프로퍼티가 있다.
obj.bar.hasOwnProperty('prototype'); // -> true
```

표준 빈트인 객체가 제공하는 프로토타입 메서드와 정적 메서드는 모두 `non-constructor`이다.

```
String.prototype.toUpperCase.prototype; // -> undefined
String.fromCharCode.prototype           // -> undefined

Number.prototype.toFixed.prototype; // -> undefined
Number.isFinite.prototype;          // -> undefined

Array.prototype.map.prototype; // -> undefined
Array.from.prototype;          // -> undefined
```

ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부슬롯 `[[HomeObject]]`를 가진다. 따라서 `[[HomeObject]]`를 가지는 메서드는 `super`를 사용할 수 있다.

```
const base = {
  name: 'Lee',
  sayHi() {
    return `Hi! ${this.name}`;
  }
};

const derived = {
  __proto__: base,
  // sayHi는 ES6 메서드다. ES6 메서드는 [[HomeObject]]를 갖는다.
  // sayHi의 [[HomeObject]]는 sayHi가 바인딩된 객체인 derived를 가리키고
  // super는 sayHi의 [[HomeObject]]의 프로토타입인 base를 가리킨다.
  sayHi() {
    return `${super.sayHi()}. how are you doing?`;
  }
};

console.log(derived.sayHi()); // Hi! Lee. how are you doing?
```

ES6 메서드가 아닌 함수는 `super` 키워드를 사용할 수 없다.`[[HomeObject]]`가 없으니까...

```
const derived = {
  __proto__: base,
  // sayHi는 ES6 메서드가 아니다.
  // 따라서 sayHi는 [[HomeObject]]를 갖지 않으므로 super 키워드를 사용할 수 없다.
  sayHi: function () {
    // SyntaxError: 'super' keyword unexpected here
    return `${super.sayHi()}. how are you doing?`;
  }
};
```

ES6에서는 메서드에서 본연의 기능(`super`)을 추가하고 의미적으로 맞지 않는 기능(`constructor`)는 제거했다. 따라서 메서드를 정의할 때 이전 방식은 사용하지 않는 것이 좋다.

## 26.3 화살표 함수

> 화살표 함수는 이전보다 간략하게 함수를 표현하고, 내부의 동작도 기존 함수보다 간략하다.

### 26.3.1 화살표 함수 정의

정의 문법은 다음과 같다.

#### 함수 정의

함수 표현식으로 정의해야 하며 호출 방식은 기존과 같다.

```
const multiply = (x, y) => x * y;
multiply(2, 3); // -> 6
```

#### 매개변수 선언

- 매개변수가 하나라면, ()를 생략할 수 있다.

```
const arrow = x => { ... };
```

- 매개변수가 여러개인 경우, () 안에 매개변수를 선언한다.

```
const arrow = (x, y) => { ... };
```

- 매개변수가 없는 경우, ()생략이 불가능하다.

```
const arrow = () => { ... };
```

#### 함수 몸체 정의

- 하나의 문으로 구성된 경우 몸체를 감싸는 중괄호{}를 생략할 수 있다. 이떄 이 문이 값으로 평가될 수 있는 표현식인 문이면 암묵적으로 반환된다.

```
// concise body
const power = x => x ** 2;
power(2); // -> 4

// 위 표현은 다음과 동일하다.
// block body
const power = x => { return x ** 2; };
```

- {}를 생략했는데 함수 몸체 내부 문이 표현식이 아닌 문이면 에러가 발생한다.

```
const arrow = () => const x = 1; // SyntaxError: Unexpected token 'const'

// 위 표현은 다음과 같이 해석된다.
const arrow = () => { return const x = 1; };
```

- 객체 리터럴을 반환하는 경우 소괄호로 감싸준다.

```
const create = (id, content) => ({ id, content });
create(1, 'JavaScript'); // -> {id: 1, content: "JavaScript"}

// 위 표현은 다음과 동일하다.
const create = (id, content) => { return { id, content }; };
```

만약 감싸주지 않는다면, 객체 리터럴의 중괄호를 함수 몸체의 중괄호로 잘못 해석한다.

```
// { id, content }를 함수 몸체 내의 쉼표 연산자문으로 해석한다.
const create = (id, content) => { id, content };
create(1, 'JavaScript'); // -> undefined
```

- 함수가 여러 문으로 구성되면 중괄호 생략이 불가능하며, 반환값이 있으면 명시적으로 반환해야한다.

```
const sum = (a, b) => {
  const result = a + b;
  return result;
};
```

- 즉시 실행 함수로 사용 가능하다.

```
const person = (name => ({
  sayHi() { return `Hi? My name is ${name}.`; }
}))('Lee');

console.log(person.sayHi()); // Hi? My name is Lee.
```

- 고차 함수에 인수로 전달이 가능하다.

```
// ES5
[1, 2, 3].map(function (v) {
  return v * 2;
});

// ES6
[1, 2, 3].map(v => v * 2); // -> [ 2, 4, 6 ]
```

### 26.3.2 화살표 함수와 일반 함수의 차이

1. 화살표 함수는 인스턴스 생성이 불가능한 `non-constructor`이다.

```
const Foo = () => {};
// 화살표 함수는 생성자 함수로서 호출할 수 없다.
new Foo(); // TypeError: Foo is not a constructor
```

따라서 프로토타입도 생성하지 않는다.

```
const Foo = () => {};
// 화살표 함수는 prototype 프로퍼티가 없다.
Foo.hasOwnProperty('prototype'); // -> false
```

2. 중복된 매개변수 이름을 선언할 수 없다.

```
const arrow = (a, a) => a + a;
// SyntaxError: Duplicate parameter name not allowed in this context
```

단, 일반함수에서도 strict mode에서는 불가능하다.

3. 화살표 함수는 함수 자체의 `this`, `arguments`, `super`, `new.target` 바인딩을 갖지 않는다.

따라서 `this`, `arguments`, `super`, `new.target`를 참조하면 스코프 체인을 따라 상위 스코프의 `this`, `arguments`, `super`, `new.target`를 참조한다. 만약 중첩되어 있다면, 스코프 체인에서 가장 가까운 함수 중 화살표 함수가 아닌 함수의 `this`, `arguments`, `super`, `new.target`를 참조한다.

### 26.3.3. this

화살표 함수가 일반 함수와 구분되는 가장 큰 특징이다. 콜백 함수 내부의 `this`가 외부 함수의 `this`와 다르기 때문에 발생하는 문제를 해결하기 위해 의도적으로 설계된 것이다. this는 어떻게 호출하느냐에 따라 동적으로 결정되는데, 일반 함수로 호출되는 콜백 함수를 주의해야 한다.

```
class Prefixer {
  constructor(prefix) {
    this.prefix = prefix;
  }

  add(arr) {
    // add 메서드는 인수로 전달된 배열 arr을 순회하며 배열의 모든 요소에 prefix를 추가한다.
    // ①
    return arr.map(function (item) {
      return this.prefix + item; // ②
      // -> TypeError: Cannot read property 'prefix' of undefined
    });
  }
}

const prefixer = new Prefixer('-webkit-');
console.log(prefixer.add(['transition', 'user-select']));
```

결과로 `['-webkit-transition', '-webkit-user-select']`를 기대하나, `TypeError`가 발생한다. 먼저 ①에서 `this`는 메서드를 호출한 객체를 가리킨다. 하지만 ②에서는 `this`는 `undefined`를 가리킨다. 이는 `map`메서드가 콜백함수를 일반 함수로서 호출하기 때문이다. 일반 함수로 호출되는 함수의 `this`는 전역 객체를 가리킨다. 그런데, **클래스 내부의 모든 코드에는 strict mode가 암묵적으로 적용된다.** 따라서 전역 객체가 아닌 `undefined`가 바인딩 되므로, ②에서는 `this`에 `undefined`가 바인딩 된다.

이를 피하기 위해 ES6 이전에는 다음과 같은 방법들을 사용하였다.

1. `add`메서드를 호출한 `prefixer`객체를 가리키는 `this`를 일단 회피 시키고 콜백 함수 내부에서 사용한다.

```
...
add(arr) {
  // this를 일단 회피시킨다.
  const that = this;
  return arr.map(function (item) {
    // this 대신 that을 참조한다.
    return that.prefix + ' ' + item;
  });
}
...
```

2. `map`의 두번째 인수로 `add`메서드를 호출한 `prefixer`객체를 가리키는 `this`를 전달한다. `map`메서드는 두번째 인수로 콜백 함수 내부에서 사용할 객체를 전달할 수 있다.

```
...
add(arr) {
  return arr.map(function (item) {
    return this.prefix + ' ' + item;
  }, this); // this에 바인딩된 값이 콜백 함수 내부의 this에 바인딩된다.
}
...
```

3. `Function.prototype.bind` 메서드를 사용해, `prefixer`객체를 가리키는 `this`를 바인딩한다.

```
...
add(arr) {
  return arr.map(function (item) {
    return this.prefix + ' ' + item;
  }.bind(this)); // this에 바인딩된 값이 콜백 함수 내부의 this에 바인딩된다.
}
...
```

ES6에서는 화살표 함수를 사용해 이와 같은 문제를 해결할 수 있다.

```
class Prefixer {
  constructor(prefix) {
    this.prefix = prefix;
  }

  add(arr) {
    return arr.map(item => this.prefix + item);
  }
}

const prefixer = new Prefixer('-webkit-');
console.log(prefixer.add(['transition', 'user-select']));
// ['-webkit-transition', '-webkit-user-select']
```

**화살표 함수는 함수 자체의 `this` 바인딩이 없기 때문에 내부에서 `this`를 참조하면 상위 스코프의 `this`를 참조한다. 이를 `lexical this`라고 한다.**
화살표 함수를 제외한 모든 함수는 `this`바인딩이 존재한다. 만약 화살표 함수끼리 중첩되어 있다면, 가장 가까운 상위 함수중 화살표 함수가 아닌 함수의 `this`를 참조한다.

```
// 중첩 함수 foo의 상위 스코프는 즉시 실행 함수다.
// 따라서 화살표 함수 foo의 this는 상위 스코프인 즉시 실행 함수의 this를 가리킨다.
(function () {
  const foo = () => console.log(this);
  foo();
}).call({ a: 1 }); // { a: 1 }

// bar 함수는 화살표 함수를 반환한다.
// bar 함수가 반환한 화살표 함수의 상위 스코프는 화살표 함수 bar다.
// 하지만 화살표 함수는 함수 자체의 this 바인딩을 갖지 않으므로 bar 함수가 반환한
// 화살표 함수 내부에서 참조하는 this는 화살표 함수가 아닌 즉시 실행 함수의 this를 가리킨다.
(function () {
  const bar = () => () => console.log(this);
  bar()();
}).call({ a: 1 }); // { a: 1 }
```

만약 화살표 함수가 전역 함수라면, 화살표 함수의 `this`는 전역 객체를 가리킨다.

```
// 전역 함수 foo의 상위 스코프는 전역이므로 화살표 함수 foo의 this는 전역 객체를 가리킨다.
const foo = () => console.log(this);
foo(); // window
```

프로퍼티에 할당한 화살표 함수도 마찬가지이다.

```
// increase 프로퍼티에 할당한 화살표 함수의 상위 스코프는 전역이다.
// 따라서 increase 프로퍼티에 할당한 화살표 함수의 this는 전역 객체를 가리킨다.
const counter = {
  num: 1,
  increase: () => ++this.num
};

console.log(counter.increase()); // NaN
```

화살표 함수는 `Function.prototype.call`, `Function.prototype.bind`, `Function.prototype.apply` 메서드를 사용해도 화살표 함수 내부의 this를 교체할 수 없다. 물론 호출할 수 없다는 의미는 아니다.

```
const add = (a, b) => a + b;

console.log(add.call(null, 1, 2));    // 3
console.log(add.apply(null, [1, 2])); // 3
console.log(add.bind(null, 1, 2)());  // 3
```

따라서 메서드를 화살표 함수로 정의하는 것은 피한다. 여기서 말하는 메서드는 일반적인 의미의 메서드이다.

```
// Bad
const person = {
  name: 'Lee',
  sayHi: () => console.log(`Hi ${this.name}`)
};

// sayHi 프로퍼티에 할당된 화살표 함수 내부의 this는 상위 스코프인 전역의 this가 가리키는
// 전역 객체를 가리키므로 이 예제를 브라우저에서 실행하면 this.name은 빈 문자열을 갖는
// window.name과 같다. 전역 객체 window에는 빌트인 프로퍼티 name이 존재한다.
person.sayHi(); // Hi

// Good
const person = {
  name: 'Lee',
  sayHi() {
    console.log(`Hi ${this.name}`);
  }
};

person.sayHi(); // Hi Lee
```

프로토타입 객체의 프로퍼티에 화살표 함수를 할당하는 경우도 동일한 문제가 발생한다.

```
// Bad
function Person(name) {
  this.name = name;
}

Person.prototype.sayHi = () => console.log(`Hi ${this.name}`);

const person = new Person('Lee');
// 이 예제를 브라우저에서 실행하면 this.name은 빈 문자열을 갖는 window.name과 같다.
person.sayHi(); // Hi

// Good
function Person(name) {
  this.name = name;
}

Person.prototype.sayHi = function () { console.log(`Hi ${this.name}`); };

const person = new Person('Lee');
person.sayHi(); // Hi Lee
```

ES6 메서드를 동적 추가하고 싶다면, 객체 리터럴을 바인딩하고 프로토타입의 `constructor`프로퍼티와 생성자 함수 간의 연결을 재설정한다.

```
function Person(name) {
  this.name = name;
}

Person.prototype = {
  // constructor 프로퍼티와 생성자 함수 간의 연결을 재설정
  constructor: Person,
  sayHi() { console.log(`Hi ${this.name}`); }
};

const person = new Person('Lee');
person.sayHi(); // Hi Lee

```

클래스 필드 정의 제안을 사용해 클래스 필드에 화살표 함수를 할당할 수도 있다.

```
// Bad
class Person {
  // 클래스 필드 정의 제안
  name = 'Lee';
  sayHi = () => console.log(`Hi ${this.name}`);
}

const person = new Person();
person.sayHi(); // Hi Lee
```

이는 다음과 같은 의미이다.

```
class Person {
  constructor() {
    this.name = 'Lee';
    // 클래스가 생성한 인스턴스(this)의 sayHi 프로퍼티에 화살표 함수를 할당한다.
    // sayHi 프로퍼티는 인스턴스 프로퍼티이다.
    this.sayHi = () => console.log(`Hi ${this.name}`);
  }
}
```

`sayHi` 클래스 필드에 할당한 화살표 함수의 상위 스코프는 `constructor`이다. 따라서 `sayHi` 클래스 필드에 할당한 화살표 함수가 참조한 `this`는 `constructor` 내부의 `this`바인딩과 같다. 이는 곧 클래스의 인스턴스를 가리키므로, 화살표 함수가 참조한 `this`또한 인스턴스를 가리킨다.
하지만, 클래스 필드에 할당한 화살표 함수는 인스턴스 메서드가 된다. 따라서 메서드를 정의할 때에는 축약 표현을 사용한 ES6 메서드를 사용하는 편이 좋다.

```
// Good
class Person {
  // 클래스 필드 정의
  name = 'Lee';

  sayHi() { console.log(`Hi ${this.name}`); }
}
const person = new Person();
person.sayHi(); // Hi Lee
```

### 26.3.4 super

화살표 함수는 자체의 `super` 바인딩을 갖지 않는다. 상위 스코프의 `super`를 참조한다.

```
class Base {
  constructor(name) {
    this.name = name;
  }

  sayHi() {
    return `Hi! ${this.name}`;
  }
}

class Derived extends Base {
  // 화살표 함수의 super는 상위 스코프인 constructor의 super를 가리킨다.
  sayHi = () => `${super.sayHi()} how are you doing?`;
}

const derived = new Derived('Lee');
console.log(derived.sayHi()); // Hi! Lee how are you doing?
```

`super`는 내부 슬롯 `[[HomdObject]]`를 갖는 ES6메서드 내에서만 사용할 수 있다. 화살표 함수는 함수 자체의 `super`바인딩을 가지지 않으므로 상위 스코프인 `constructor`의 `super` 바인딩을 참조한다.

### 26.3.5 arguments

화살표 함수는 자체의 `arguments` 바인딩을 갖지 않는다. 상위 스코프의 `arguments`바인딩을 참조한다.

```

(function () {
  // 화살표 함수 foo의 arguments는 상위 스코프인 즉시 실행 함수의 arguments를 가리킨다.
  const foo = () => console.log(arguments); // [Arguments] { '0': 1, '1': 2 }
  foo(3, 4);
}(1, 2));

// 화살표 함수 foo의 arguments는 상위 스코프인 전역의 arguments를 가리킨다.
// 하지만 전역에는 arguments 객체가 존재하지 않는다. arguments 객체는 함수 내부에서만 유효하다.
const foo = () => console.log(arguments);
foo(1, 2); // ReferenceError: arguments is not defined
```

`arguments`는 함수를 정의할 때 매개변수의 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용하다. 하지만 이를 상위 스코프에서 참조해도, 스스로의 인수 목록을 참조하는 것이 아니기 때문에 별로...유용하지는....
따라서 화살표 함수로 가변인자 함수를 구현하려면 반드시 Rest 파라미터를 이용한다.

## 26.4 Rest 파라미터

### 26.4.1 기본 문법

매개변수 이름 앞에 ...을 붙여서 정의한다.**Rest 파라미터는 전달된 인수들을 배열로 전달받는다.**

```
function foo(...rest) {
  // 매개변수 rest는 인수들의 목록을 배열로 전달받는 Rest 파라미터다.
  console.log(rest); // [ 1, 2, 3, 4, 5 ]
}

foo(1, 2, 3, 4, 5);
```

일반 매개변수와 함께 사용이 가능하다. 인수들은 일반 매개변수와 Rest 매개변수에 순차적 할당되며, 이때 Rest 파라미터는 마지막에 위치해야 한다. 또한 Rest 매개변수는 동시에 여러개를 사용할 수 없다.

```
function foo(param, ...rest) {
  console.log(param); // 1
  console.log(rest);  // [ 2, 3, 4, 5 ]
}

foo(1, 2, 3, 4, 5);

function bar(param1, param2, ...rest) {
  console.log(param1); // 1
  console.log(param2); // 2
  console.log(rest);   // [ 3, 4, 5 ]
}

bar(1, 2, 3, 4, 5);

function foo(...rest, param1, param2) { }

foo(1, 2, 3, 4, 5);
// SyntaxError: Rest parameter must be last formal parameter

function foo(...rest1, ...rest2) { }

foo(1, 2, 3, 4, 5);
// SyntaxError: Rest parameter must be last formal parameter
```

Rest 파라미터는 함수 정의 시 선언한 매개변수 개수를 나타내는 `length` 프로퍼티에 영향을 주지 않는다. 즉, Rest 파라미터는 인자의 개수를 미리 정할 수 없기 때문에 length가 0이다.

```
function foo(...rest) {}
console.log(foo.length); // 0

function bar(x, ...rest) {}
console.log(bar.length); // 1

function baz(x, y, ...rest) {}
console.log(baz.length); // 2
```

### 26.4.2 Rest 파라미터와 arguments 객체

`arguments` 객체는 유사 배열 객체이므로, `arguments`객체를 배열로 전환해야하는 번거로움이 있었다.

```
function sum() {
  // 유사 배열 객체인 arguments 객체를 배열로 변환한다.
  var array = Array.prototype.slice.call(arguments);

  return array.reduce(function (pre, cur) {
    return pre + cur;
  }, 0);
}

console.log(sum(1, 2, 3, 4, 5)); // 15
```

Rest 파라미터를 사용하면서 이러한 번거로움을 피할 수 있다.

```
function sum(...args) {
  // Rest 파라미터 args에는 배열 [1, 2, 3, 4, 5]가 할당된다.
  return args.reduce((pre, cur) => pre + cur, 0);
}
console.log(sum(1, 2, 3, 4, 5)); // 15
```

따라서 화살표 함수로 가변 인자 함수를 구현하기 위해서는 반드시 Rest 파라미터를 사용한다.

## 25.6 매개변수 기본값

개인적으로 정말 편리하다고 생각하는 기능이다.
함수 호출 시 매개변수 개수만큼 인수를 전달하지 않아도 오류가 발생하지 않고, 전달되지 않은 매개변수는 `undefined`이다.

```
function sum(x, y) {
  return x + y;
}

console.log(sum(1)); // NaN
```

이러한 오류를 막기 위해서 방어 코드가 필요하다.

```
function sum(x, y) {
  x = x || 0;
  y = y || 0;

  return x + y;
}

console.log(sum(1)); // 1
```

ES6에서 도입된 매개변수 기본값을 사용하면 이런 번거로움을 줄일 수 있다.

```
function sum(x = 0, y = 0) {
  return x + y;
}

console.log(sum(1, 2)); // 3
console.log(sum(1));    // 1
```

매개변수를 전달하지 않은 경우와 `undefined`를 전달한 경우에만 유효하다.

```
function logName(name = 'Lee') {
  console.log(name);
}

logName();          // Lee
logName(undefined); // Lee
logName(null);      // null
```

Rest 파라미터에는 기본값 지정이 불가능하다.

```
function foo(...rest = []) {
  console.log(rest);
}
// SyntaxError: Rest parameter may not have a default initializer
```

함수 객체의 `length` 프로퍼티와 `arguments`객체에 영향을 주지 않는다.

```
function sum(x, y = 0) {
  console.log(arguments);
}

console.log(sum.length); // 1

sum(1);    // Arguments { '0': 1 }
sum(1, 2); // Arguments { '0': 1, '1': 2 }
```

# 27장 배열

## 27.1 배열이란?

> 여러개의 값을 순차적으로 나열한 자료구조

- 요소: 배열이 가지고 있는 값
- 인덱스: 배열에서 요소 자신의 위치. 0에서부터 시작한다.

요소에 접근할 때는 대괄호 표기법을 사용한다.

```
const arr = ['apple', 'banana', 'orange'];

arr[0] // -> 'apple'
arr[1] // -> 'banana'
arr[2] // -> 'orange'
```

배열은 배열 리터럴, `Array` 생성자 함수, `Array.of`, `Array.from` 메서드로 생성할 수 있다. 생성자 함수는 `Array`이며, 프로토타입 객체는 `Array.prototype`이다.

배열은 객체지만, 일반 객체와 구별되는 특징이 있다.
|구분|객체|배열|
|--|--|--|
|구조|프로퍼티 키와 프로퍼티 값|인덱스와 요소|
|값의 참조|프로퍼티 키|인덱스|
|값의 순서|X|O|
|`length`프로퍼티|X|O|

이중 가장 명확한 차이는 값의 순서와 `length`프로퍼티이다. 배열은 반복문을 통해 접근하기 쉬운 구조이다.

```
const arr = [1, 2, 3];

// 반복문으로 자료 구조를 순서대로 순회하기 위해서는 자료 구조의 요소에 순서대로
// 접근할 수 있어야 하며 자료 구조의 길이를 알 수 있어야 한다.
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]); // 1 2 3
}
```

## 27.2 JS의 배열은 배열이 아니다.

자료구조에서 말하는 배열은 동일 크기의 메모리 공간이 빈틈없이 나열된 자료구조를 말한다. 즉, 하나의 데이터 타입으로 통일되어 있으며 서로 연속적으로 인접해 있다. 이를 **밀집 배열**이라고 한다. 이러한 일반적 배열은 빈틈없이 연속적으로 이어져 있고, 인덱스를 통해 단 한번의 연산만으로 요소에 접근할 수 있다. 효율적이고 고속이다.

> 검색 대상 요소의 메모리 주소 = 배열의 시작 메모리 주소 + 인덱스 \* 요소의 바이트 수

하지만 정렬되지 않은 배열에서는 검색하려면 특정 요소를 검색하기 위해 그 요소까지 차례대로 다 뒤져봐야 한다.

```
// 선형 검색을 통해 배열(array)에 특정 요소(target)가 존재하는지 확인한다.
// 배열에 특정 요소가 존재하면 특정 요소의 인덱스를 반환하고, 존재하지 않으면 -1을 반환한다.
function linearSearch(array, target) {
  const length = array.length;

  for (let i = 0; i < length; i++) {
    if (array[i] === target) return i;
  }

  return -1;
}

console.log(linearSearch([1, 2, 3, 4, 5, 6], 3)); // 2
console.log(linearSearch([1, 2, 3, 4, 5, 6], 0)); // -1
```

또한, 배열에 요소를 삽입 혹은 삭제할 경우 배열을 연속적으로 유지하기 위해 요소를 이동시켜야 한다.

JS배열은 앞에서 말한 배열과는 다르다. 각각의 메모리 공간의 크기가 같지 않아도 되며, 연속적으로 이어져 있지 않아도 된다. 이렇게 배열의 요소가 연속적이지 않은 배열을 **희소 배열**이라고 한다.
이처럼 **JS의 배열은 일반적인 배열의 동작을 흉내 낸 객체이다!!**

```
// "16.2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체" 참고
console.log(Object.getOwnPropertyDescriptors([1, 2, 3]));
/*
{
  '0': {value: 1, writable: true, enumerable: true, configurable: true}
  '1': {value: 2, writable: true, enumerable: true, configurable: true}
  '2': {value: 3, writable: true, enumerable: true, configurable: true}
  length: {value: 3, writable: true, enumerable: false, configurable: false}
}
*/
```

이처럼 JS의 배열은 인덱스 나타내는 문자열을 프로퍼티 키로 가지며, `length` 프로퍼티를 가지는 특수한 객체이다. JS 배열의 요소는 사실 프로퍼티 값이다. 프로퍼티 값은 JS에서 사용하는 모든 값이 될 수 있으므로 어떤 타입이라도 배열의 요소가 될 수 있다.

```
const arr = [
  'string',
  10,
  true,
  null,
  undefined,
  NaN,
  Infinity,
  [ ],
  { },
  function () {}
];
```

일반 배열과 JS배열의 장단점은 다음과 같다.

- 일반배열: 인덱스로 요소에 빠르게 접근 가능. 그러나 특정 요소를 검색하거나 요소를 삽입 또는 삭제하는 경우엔 효율적이지 않다.

- JS배열은 해시 테이블로 구현된 객체여서 성능적인 면에서는 일반 배열보다 느리다. 하지만 특정 요소 검색, 요소 삽입 혹은 삭제에서는 일반 배열보다 빠른 성능을 기대할 수 있다.

성능적은 부분을 개선하기 위해 JS배열은 객체와 구별해 좀 더 배열처럼 작동하도록 최적화 했고, 배열이 객체보다 약 2배정도 빠른 속도를 가진다.

```
const arr = [];

console.time('Array Performance Test');

for (let i = 0; i < 10000000; i++) {
  arr[i] = i;
}
console.timeEnd('Array Performance Test');
// 약 340ms

const obj = {};

console.time('Object Performance Test');

for (let i = 0; i < 10000000; i++) {
  obj[i] = i;
}

console.timeEnd('Object Performance Test');
// 약 600ms
```

## 27.3 length 프로퍼티와 희소 배열

`length`프로퍼티는 배열의 길이이다. 즉, 0이상의 정수이며, 요소가 1개 이상 있는 경우 인덱스 + 1의 값을 가진다.

```
[].length        // -> 0
[1, 2, 3].length // -> 3
```

배열은 요소를 최대 40억개...정도 가질 수 있다.

`length`프로퍼티는 배열에 요소를 추가하거나 삭제하면 자동 갱신된다.

```
const arr = [1, 2, 3];
console.log(arr.length); // 3

// 요소 추가
arr.push(4);
// 요소를 추가하면 length 프로퍼티의 값이 자동 갱신된다.
console.log(arr.length); // 4

// 요소 삭제
arr.pop();
// 요소를 삭제하면 length 프로퍼티의 값이 자동 갱신된다.
console.log(arr.length); // 3
```

`length`프로퍼티는 명시적으로 임의 값을 할당할 수 있고, 원래의 값보다 작은 값을 할당하면 배열의 길이가 줄어든다.

```
const arr = [1, 2, 3, 4, 5];

// 현재 length 프로퍼티 값인 5보다 작은 숫자 값 3을 length 프로퍼티에 할당
arr.length = 3;

// 배열의 길이가 5에서 3으로 줄어든다.
console.log(arr); // [1, 2, 3]
```

그러나 원래 값보다 더 큰 값을 할당하면? `length`프로퍼티 값은 변경되어도 실제 배열의 길이는 그대로이다.

```
const arr = [1];

// 현재 length 프로퍼티 값인 1보다 큰 숫자 값 3을 length 프로퍼티에 할당
arr.length = 3;

// length 프로퍼티 값은 변경되지만 실제로 배열의 길이가 늘어나지는 않는다.
console.log(arr.length); // 3
console.log(arr); // [1, empty × 2]
```

비어있는 요소를 위해 메모리 공간을 확보하지 않으며 빈 요소를 생성하지도 않는다.

```
console.log(Object.getOwnPropertyDescriptors(arr));
/*
{
  '0': {value: 1, writable: true, enumerable: true, configurable: true},
  length: {value: 3, writable: true, enumerable: false, configurable: false}
}
*/
```

JS는 이러한 희소 배열을 문법적으로 허용한다.

```
const sparse = [, 2, , 4];

// 희소 배열의 length 프로퍼티 값은 요소의 개수와 일치하지 않는다.
console.log(sparse.length); // 4
console.log(sparse); // [empty, 2, empty, 4]

// 배열 sparse에는 인덱스가 0, 2인 요소가 존재하지 않는다.
console.log(Object.getOwnPropertyDescriptors(sparse));
/*
{
  '1': { value: 2, writable: true, enumerable: true, configurable: true },
  '3': { value: 4, writable: true, enumerable: true, configurable: true },
  length: { value: 4, writable: true, enumerable: false, configurable: false }
}
```

**희소 배열의 `length`와 배열의 요소의 개수가 일치하지 않는다. 희소 배열의 `length`는 언제나 실제 요소 개수보다 크다.**

그러나 희소 배열은 사용하지 않는 것이 좋다. 배열의 기본적인 개념에도 어긋나며, 성능상으로도 별로이다. 모던 JS 엔진은 희소배열을 위해 일반적 배열처럼 연속된 메모리 공간을 확보한다. 즉, 빈 값을 위해 확보하는 메모리 공간은 낭비이다. 그러므로 **배열에는 같은 타입의 요소를 연속적으로 위치시키는 것이 최선이다.**

## 27.4 배열 생성

### 27.4.1 배열 리터럴

가장 일반적, 편한 방법이다. 0개 이상의 요소를 쉼표로 구분해 대괄호로 묶는다. 값만 존재한다.

```
const arr = [1, 2, 3];
console.log(arr.length); // 3
```

요소를 추가하지 않으면 `length`프로퍼티 값이 0인 배열이다.

```
const arr = [];
console.log(arr.length); // 0
```

요소를 생략하면 희소 배열이 생성된다.

```
const arr = [1, , 3]; // 희소 배열

// 희소 배열의 length는 배열의 실제 요소 개수보다 언제나 크다.
console.log(arr.length); // 3
console.log(arr);        // [1, empty, 3]
console.log(arr[1]);     // undefined
```

### 27.4.2 Array 생성자 함수

`Array`생성자 함수를 통해 생성한다. 인수의 개수에 따라 다르게 동작한다.

- 인수가 1개이고 숫자인 경우 `length`프로퍼티 값이 인수인 배열을 생성한다. 이렇게 생성한 배열은 희소 배열이다.

```
const arr = new Array(10);

console.log(arr); // [empty × 10]
console.log(arr.length); // 10

console.log(Object.getOwnPropertyDescriptors(arr));
/*
{
  length: {value: 10, writable: true, enumerable: false, configurable: false}
}
```

앞서 말했듯 배열의 요소는 최대 40억개정도 가질 수 있다. 이 범위를 벗어나면 `RangeError`가 발생한다.

```
// 배열은 요소를 최대 4,294,967,295개 가질 수 있다.
new Array(4294967295);

// 전달된 인수가 0 ~ 4,294,967,295를 벗어나면 RangeError가 발생한다.
new Array(4294967296); // RangeError: Invalid array length

// 전달된 인수가 음수이면 에러가 발생한다.
new Array(-1); // RangeError: Invalid array length
```

- 전달된 인수가 없는 경우 빈 배열을 생성한다.(=`[]`)

```
new Array(); // -> []
```

- 전달된 인수가 2개 이상이거나 숫자가 아닌 경우, 인수를 요소로 가지는 배열을 생성한다.

```
// 전달된 인수가 2개 이상이면 인수를 요소로 갖는 배열을 생성한다.
new Array(1, 2, 3); // -> [1, 2, 3]

// 전달된 인수가 1개지만 숫자가 아니면 인수를 요소로 갖는 배열을 생성한다.
new Array({}); // -> [{}]
```

- `new` 키워드 없이 호출해도 생성자 함수로 동작한다. 생성자 함수 내부에서 `new.target`을 확인하기 때문이다.

```
Array(1, 2, 3); // -> [1, 2, 3]
```

### 27.4.3 Array.of

`Array.of`는 인수를 요소로 가지는 배열을 생성한다. 인수가 1개이고 숫자이더라도 인수를 요소로 가진다.

```
// 전달된 인수가 1개이고 숫자이더라도 인수를 요소로 갖는 배열을 생성한다.
Array.of(1); // -> [1]

Array.of(1, 2, 3); // -> [1, 2, 3]

Array.of('string'); // -> ['string']
```

### 27.4.4 Array.from

유사 배열 객체 또는 이터러블 객체를 인수로 전달받아 배열로 변환해 반환한다.

```
// 유사 배열 객체를 변환하여 배열을 생성한다.
Array.from({ length: 2, 0: 'a', 1: 'b' }); // -> ['a', 'b']

// 이터러블을 변환하여 배열을 생성한다. 문자열은 이터러블이다.
Array.from('Hello'); // -> ['H', 'e', 'l', 'l', 'o']
```

두번째 인수로 전달한 콜백 함수를 통해 값을 만들며 요소를 채울 수 있다. 두번째 인수로 전달한 콜백 함수에 첫쨰 인수로 만들어진 배열의 요소값과 인덱스를 순차적으로 전달하면서 호출하고, 콜백 함수의 반환값으로 구성된 배열을 반환한다.

```
// Array.from에 length만 존재하는 유사 배열 객체를 전달하면 undefined를 요소로 채운다.
Array.from({ length: 3 }); // -> [undefined, undefined, undefined]

// Array.from은 두 번째 인수로 전달한 콜백 함수의 반환값으로 구성된 배열을 반환한다.
Array.from({ length: 3 }, (_, i) => i); // -> [0, 1, 2]
```

## 27.5 배열 요소의 참조

대괄호 표기법으로 요소를 참조한다. 대괄호 안에는 인덱스가 와야한다. 정수로 평가되는 표현식을 인덱스 대신 사용할 수 있다.

```
const arr = [1, 2];

// 인덱스가 0인 요소를 참조
console.log(arr[0]); // 1
// 인덱스가 1인 요소를 참조
console.log(arr[1]); // 2
```

존재하지 않는 요소는 `undefined`를 반환한다.

```
const arr = [1, 2];

// 인덱스가 2인 요소를 참조. 배열 arr에는 인덱스가 2인 요소가 존재하지 않는다.
console.log(arr[2]); // undefined
```

이는 배열이 프로퍼티 키로 문자열 형태의 인덱스를 가지는 객체이기 때문이다. 따라서 희소 배열에도 존재하지 않는 요소에는 `undefined`를 반환한다.

```
// 희소 배열
const arr = [1, , 3];

// 배열 arr에는 인덱스가 1인 요소가 존재하지 않는다.
console.log(Object.getOwnPropertyDescriptors(arr));
/*
{
  '0': {value: 1, writable: true, enumerable: true, configurable: true},
  '2': {value: 3, writable: true, enumerable: true, configurable: true},
  length: {value: 3, writable: true, enumerable: false, configurable: false}
*/

// 존재하지 않는 요소를 참조하면 undefined가 반환된다.
console.log(arr[1]); // undefined
console.log(arr[3]); // undefined

```

## 27.6 배열 요소의 추가와 갱신

배열에도 요소를 동적으로 추가할 수 있다. 존재하지 않는 인덱스에 값을 할당하면 요소가 추가되고, `length`프로퍼티 값은 자동 갱신된다.

```
const arr = [0];

// 배열 요소의 추가
arr[1] = 1;

console.log(arr); // [0, 1]
console.log(arr.length); // 2
```

희소 배열을 만들 수도 있다. 단, 이 경우에 명시적으로 값을 할당하지 않으면 요소는 생성되지 않는다.

```
arr[100] = 100;

console.log(arr); // [0, 1, empty × 98, 100]
console.log(arr.length); // 101

// 명시적으로 값을 할당하지 않은 요소는 생성되지 않는다.
console.log(Object.getOwnPropertyDescriptors(arr));
/*
{
  '0': {value: 0, writable: true, enumerable: true, configurable: true},
  '1': {value: 1, writable: true, enumerable: true, configurable: true},
  '100': {value: 100, writable: true, enumerable: true, configurable: true},
  length: {value: 101, writable: true, enumerable: false, configurable: false}
*/
```

이미 존재하는 요소에 재할당하면 값이 갱신된다.

```
// 요소값의 갱신
arr[1] = 10;

console.log(arr); // [0, 10, empty × 98, 100]
```

인덱스를 정수 값이 아닌 다른 값으로 사용하면 프로퍼티가 생성되며, `length`프로퍼티에는 영향을 주지 않는다.

```
const arr = [];

// 배열 요소의 추가
arr[0] = 1;
arr['1'] = 2;

// 프로퍼티 추가
arr['foo'] = 3;
arr.bar = 4;
arr[1.1] = 5;
arr[-1] = 6;

console.log(arr); // [1, 2, foo: 3, bar: 4, '1.1': 5, '-1': 6]

// 프로퍼티는 length에 영향을 주지 않는다.
console.log(arr.length); // 2
```

## 27.7 배열 요소의 삭제

`delete`연산자를 사용할 수 있다.

```
const arr = [1, 2, 3];

// 배열 요소의 삭제
delete arr[1];
console.log(arr); // [1, empty, 3]

// length 프로퍼티에 영향을 주지 않는다. 즉, 희소 배열이 된다.
console.log(arr.length); // 3
```

`delete`연산자는 희소 배열을 만들기 때문에 사용하지 않는 것이 좋다. 배열의 요소를 완전 삭제하려면 `Array.prototype.splice`메서드를 사용하는 것이 좋다.

```
const arr = [1, 2, 3];

// Array.prototype.splice(삭제를 시작할 인덱스, 삭제할 요소 수)
// arr[1]부터 1개의 요소를 제거
arr.splice(1, 1);
console.log(arr); // [1, 3]

// length 프로퍼티가 자동 갱신된다.
console.log(arr.length); // 2
```

## 27.8 배열 메서드

`Array`생성자 함수는 정적 메서드를, `Array.prototype`은 프로토타입 메서드를 제공한다. 또한 배열에는 **원본 배열을 변경하는 메서드**와 **새로운 배열을 생성하여 반환하는 메서드**가 있다. 가급적 원본 배열을 변경하지 않는 메서드를 사용하자...!

#### 27.8.1 Array.isArray

> 전달된 인수가 배열이면 `true`, 아니면 `false`를 전달한다.

```

// true
Array.isArray([]);
Array.isArray([1, 2]);
Array.isArray(new Array());

// false
Array.isArray();
Array.isArray({});
Array.isArray(null);
Array.isArray(undefined);
Array.isArray(1);
Array.isArray('Array');
Array.isArray(true);
Array.isArray(false);
Array.isArray({ 0: 1, length: 1 })
```

#### 27.8.2 Array.prototype.indexOf

> 배열에서 인수로 전달된 요소를 검색해 인덱스를 반환한다.

- 중복 요소가 여러개면 첫번째로 그 중 가장 빠른 인덱스를 반환
- 없다면 -1을 반환한다.

```
const arr = [1, 2, 2, 3];

// 배열 arr에서 요소 2를 검색하여 첫 번째로 검색된 요소의 인덱스를 반환한다.
arr.indexOf(2);    // -> 1
// 배열 arr에 요소 4가 없으므로 -1을 반환한다.
arr.indexOf(4);    // -> -1
// 두 번째 인수는 검색을 시작할 인덱스다. 두 번째 인수를 생략하면 처음부터 검색한다.
arr.indexOf(2, 2); // -> 2
```

#### 27.8.3 Array.prototype.push(원본)

> 인수로 전달받은 값을 원본 배열에 마지막 요소로 추가한다.

```
const arr = [1, 2];

// 인수로 전달받은 모든 값을 원본 배열 arr의 마지막 요소로 추가하고 변경된 length 값을 반환한다.
let result = arr.push(3, 4);
console.log(result); // 4

// push 메서드는 원본 배열을 직접 변경한다.
console.log(arr); // [1, 2, 3, 4]
```

그러나 성능 면에서 좋지 않다. 대신 `length`를 이용하면 배열의 마지막에 요소를 직접 추가할 수 있다. 속도가 훨씬 빠르다.

```
const arr = [1, 2];

// arr.push(3)과 동일한 처리를 한다. 이 방법이 push 메서드보다 빠르다.
arr[arr.length] = 3;
console.log(arr); // [1, 2, 3]
```

스프레드 문법 또한 같은 역할을 한다.

```
const arr = [1, 2];

// ES6 스프레드 문법
const newArr = [...arr, 3];
console.log(newArr); // [1, 2, 3]
```

#### 27.8.4 Array.prototype.pop(원본)

마지막 요소를 제거하고 그 요소를 반환한다. 빈 배열에 사용하면 `undefined`를 반환한다.

```
const arr = [1, 2];

// 원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환한다.
let result = arr.pop();
console.log(result); // 2

// pop 메서드는 원본 배열을 직접 변경한다.
console.log(arr); // [1]
```

`push`와 `pop`을 통해 스택을 구현할 수 있다.

### 27.8.5 Array.prototype.unshift(원본)

인수로 전달받은 모든 값을 선두에 추가하고, 변경된 `length`프로퍼티를 반환한다.

```
const arr = [1, 2];

// 인수로 전달받은 모든 값을 원본 배열의 선두에 요소로 추가하고 변경된 length 값을 반환한다.
let result = arr.unshift(3, 4);
console.log(result); // 4

// unshift 메서드는 원본 배열을 직접 변경한다.
console.log(arr); // [3, 4, 1, 2]
```

이 또한 스프레드 문법을 사용하는 편이 좋다.

```
const arr = [1, 2];

// ES6 스프레드 문법
const newArr = [3, ...arr];
console.log(newArr); // [3, 1, 2]
```

### 27.8.6 Array.prototype.shift(원본)

배열의 첫째 요소를 제거하고 그 요소를 반환한다.

```
const arr = [1, 2];

// 원본 배열에서 첫 번째 요소를 제거하고 제거한 요소를 반환한다.
let result = arr.shift();
console.log(result); // 1

// shift 메서드는 원본 배열을 직접 변경한다.
console.log(arr); // [2]
```

`shift`와 `unshift`를 이용해 큐를 구현할 수 있다.

### 27.8.7 Array.prototype.concat

인수로 전달된 값들(배열 혹은 원시값)을 원본 배열의 마지막 요소로 추가한 새로운 배열을 반환한다.

```
const arr1 = [1, 2];
const arr2 = [3, 4];

// 배열 arr2를 원본 배열 arr1의 마지막 요소로 추가한 새로운 배열을 반환한다.
// 인수로 전달한 값이 배열인 경우 배열을 해체하여 새로운 배열의 요소로 추가한다.
let result = arr1.concat(arr2);
console.log(result); // [1, 2, 3, 4]

// 숫자를 원본 배열 arr1의 마지막 요소로 추가한 새로운 배열을 반환한다.
result = arr1.concat(3);
console.log(result); // [1, 2, 3]

// 배열 arr2와 숫자를 원본 배열 arr1의 마지막 요소로 추가한 새로운 배열을 반환한다.
result = arr1.concat(arr2, 5);
console.log(result); // [1, 2, 3, 4, 5]

// 원본 배열은 변경되지 않는다.
console.log(arr1); // [1, 2]
```

`push`와 `unshift`는 `concat`으로 대체할 수 있다.

```

const arr1 = [3, 4];

// unshift 메서드는 원본 배열을 직접 변경한다.
// 따라서 원본 배열을 변수에 저장해 두지 않으면 변경된 배열을 사용할 수 없다.
arr1.unshift(1, 2);
// unshift 메서드를 사용할 경우 원본 배열을 반드시 변수에 저장해 두어야 결과를 확인할 수 있다.
console.log(arr1); // [1, 2, 3, 4]

// push 메서드는 원본 배열을 직접 변경한다.
// 따라서 원본 배열을 변수에 저장해 두지 않으면 변경된 배열을 사용할 수 없다.
arr1.push(5, 6);
// push 메서드를 사용할 경우 원본 배열을 반드시 변수에 저장해 두어야 결과를 확인할 수 있다.
console.log(arr1); // [1, 2, 3, 4, 5, 6]

// unshift와 push 메서드는 concat 메서드로 대체할 수 있다.
const arr2 = [3, 4];

// concat 메서드는 원본 배열을 변경하지 않고 새로운 배열을 반환한다.
// arr1.unshift(1, 2)를 다음과 같이 대체할 수 있다.
let result = [1, 2].concat(arr2);
console.log(result); // [1, 2, 3, 4]

// arr1.push(5, 6)를 다음과 같이 대체할 수 있다.
result = result.concat(5, 6);
console.log(result); // [1, 2, 3, 4, 5, 6]
```

스프레드 문법으로 대체할 수 있다.

```
let result = [1, 2].concat([3, 4]);
console.log(result); // [1, 2, 3, 4]

// concat 메서드는 ES6의 스프레드 문법으로 대체할 수 있다.
result = [...[1, 2], ...[3, 4]];
console.log(result); // [1, 2, 3, 4]
```

> 결론적으로 `push/unshift`와 `concat` 대신에 스프레드 문법을 사용하는 것을 권장한다.

### 27.8.8 Array.prototype.splice(원본)

배열 중간에 요소를 추가, 삭제하는 경우 사용한다. 3개의 매개변수가 있다.

- start: 원본 배열의 요소 삭제하기 시작할 인덱스이다. 음수일 경우 배열 끝에서의 인덱스를 나타낸다.
- deleteCount: start 부터 시작해 제거할 요소의 개수이다. 0일경우 아무것도 제거하지 않는다.
- items: 제거한 위치에 삽입할 요소들이다. 생략하면 제거만 한다.

```
const arr = [1, 2, 3, 4];

// 원본 배열의 인덱스 1부터 2개의 요소를 제거하고 그 자리에 새로운 요소 20, 30을 삽입한다.
const result = arr.splice(1, 2, 20, 30);

// 제거한 요소가 배열로 반환된다.
console.log(result); // [2, 3]
// splice 메서드는 원본 배열을 직접 변경한다.
console.log(arr); // [1, 20, 30, 4]
```

배열에서 특정 요소를 제거하려면 `indexOf`를 사용해 인덱스를 취득하고, `splice`를 사용한다.

### 27.8.9 Array.prototype.slice

인수로 전달된 범위의 요소를 복사해 배열로 전달한다. 두개의 매개변수를 가진다.

- start: 복사를 시작할 인덱스. 음수는 배열 끝에서의 인덱스를 나타낸다.
- end: 복사를 종료할 인덱스. 이 인덱스의 요소는 복사되지 않는다. 생략 가능하며 생략하면 length 프로퍼티의 값이다.

```
const arr = [1, 2, 3];

// arr[0]부터 arr[1] 이전(arr[1] 미포함)까지 복사하여 반환한다.
arr.slice(0, 1); // -> [1]

// arr[1]부터 arr[2] 이전(arr[2] 미포함)까지 복사하여 반환한다.
arr.slice(1, 2); // -> [2]

// 원본은 변경되지 않는다.
console.log(arr); // [1, 2, 3]
```

인수를 모두 생략하면 얕은 복사를 통해 배열을 복사한다.

```
const todos = [
  { id: 1, content: 'HTML', completed: false },
  { id: 2, content: 'CSS', completed: true },
  { id: 3, content: 'Javascript', completed: false }
];

// 얕은 복사(shallow copy)
const _todos = todos.slice();
// const _todos = [...todos];

// _todos와 todos는 참조값이 다른 별개의 객체다.
console.log(_todos === todos); // false

// 배열 요소의 참조값이 같다. 즉, 얕은 복사되었다.
console.log(_todos[0] === todos[0]); // true
```

이를 이용해 `arguments, HTMLCollection, NodeList`같은 유사 배열 객체를 배열로 변환할 수 있다.

```
function sum() {
  // 유사 배열 객체를 배열로 변환(ES5)
  var arr = Array.prototype.slice.call(arguments);
  console.log(arr); // [1, 2, 3]

  return arr.reduce(function (pre, cur) {
    return pre + cur;
  }, 0);
}

console.log(sum(1, 2, 3)); // 6
```

### 27.8.10 Array.prototype.join

원본 배열의 요소들을 문자열로 변환하고, 구분자로 연결된 문자열을 반환한다.

```
const arr = [1, 2, 3, 4];

// 기본 구분자는 ','이다.
// 원본 배열 arr의 모든 요소를 문자열로 변환한 후, 기본 구분자 ','로 연결한 문자열을 반환한다.
arr.join(); // -> '1,2,3,4';

// 원본 배열 arr의 모든 요소를 문자열로 변환한 후, 빈문자열로 연결한 문자열을 반환한다.
arr.join(''); // -> '1234'

// 원본 배열 arr의 모든 요소를 문자열로 변환한 후, 구분자 ':'로 연결한 문자열을 반환한다.ㄴ
arr.join(':'); // -> '1:2:3:4'
```

### 27.8.11 Array.prototype.reverse(원본)

원본 배열의 순서를 뒤집는다.

```
const arr = [1, 2, 3];
const result = arr.reverse();

// reverse 메서드는 원본 배열을 직접 변경한다.
console.log(arr); // [3, 2, 1]
// 반환값은 변경된 배열이다.
console.log(result); // [3, 2, 1]
```

### 27.8.12 Array.prototype.fill(원본)

인수로 전달받은 값을 배열의 처음부터 끝까지 요소로 채워준다.

```
const arr = [1, 2, 3];

// 인수로 전달 받은 값 0을 배열의 처음부터 끝까지 요소로 채운다.
arr.fill(0);

// fill 메서드는 원본 배열을 직접 변경한다.
console.log(arr); // [0, 0, 0]
```

두번째 인수로 요소 채우기를 시작할 인덱슬르 전달하고, 세번째로 멈출 인덱스를 전달한다.

```
const arr = [1, 2, 3, 4, 5];

// 인수로 전달받은 값 0을 배열의 인덱스 1부터 3 이전(인덱스 3 미포함)까지 요소로 채운다.
arr.fill(0, 1, 3);

// fill 메서드는 원본 배열을 직접 변경한다.
console.log(arr); // [1, 0, 0, 4, 5]
```

### 27.8.13 Array.prototype.indcludes

배열 내에 특정 요소가 있는지 파악해 `true` 혹은 `false`를 전달한다. 첫째 인자로 검사할 대상, 두번째 인자로 인덱스를 전달할 수 있다.

```
const arr = [1, 2, 3];

// 배열에 요소 1이 포함되어 있는지 인덱스 1부터 확인한다.
arr.includes(1, 1); // -> false

// 배열에 요소 3이 포함되어 있는지 인덱스 2(arr.length - 1)부터 확인한다.
arr.includes(3, -1); // -> true
```

### 27.8.14 Array.prototype.flat

재귀적으로 함수를 평탄화한다. 인수로 깊이를 지정해 줄 수 있다. 기본값은 1이며 Infinity를 전달하면 모두를 평탄화한다.

```
// 중첩 배열을 평탄화하기 위한 깊이 값의 기본값은 1이다.
[1, [2, [3, [4]]]].flat();  // -> [1, 2, [3, [4]]]
[1, [2, [3, [4]]]].flat(1); // -> [1, 2, [3, [4]]]

// 중첩 배열을 평탄화하기 위한 깊이 값을 2로 지정하여 2단계 깊이까지 평탄화한다.
[1, [2, [3, [4]]]].flat(2); // -> [1, 2, 3, [4]]
// 2번 평탄화한 것과 동일하다.
[1, [2, [3, [4]]]].flat().flat(); // -> [1, 2, 3, [4]]

// 중첩 배열을 평탄화하기 위한 깊이 값을 Infinity로 지정하여 중첩 배열 모두를 평탄화한다.
[1, [2, [3, [4]]]].flat(Infinity); // -> [1, 2, 3, 4]
```

## 27.9 배열 고차 함수

> 고차함수: 함수를 인수로 전달받거나 함수를 반환하는 함수

불변성을 지향하는 함수형 프로그래밍에 기반을 둔다.

### 27.9.1 Array.prototype.sort(원본)

배열의 요소를 정렬한다. 기본적으로 오름차순 정렬이다.

```
const fruits = ['Banana', 'Orange', 'Apple'];

// 오름차순(ascending) 정렬
fruits.sort();

// sort 메서드는 원본 배열을 직접 변경한다.
console.log(fruits); // ['Apple', 'Banana', 'Orange']
```

숫자로 이루어진 배열을 정렬할 때 주의가 필요하다. 유니코드를 따르므로, 11이 2보다 앞서서 정렬될 수 있다. 따라서 비교함수를 인수로 전달해야한다. 비교 함수는 양수, 음수, 0을 반환하는데, 0보다 작으면 첫번째 인자를 우선하고, 0이면 정렬하지 않으며, 양수면 두번째 인수를 우선하여 정렬한다.

```
const points = [40, 100, 1, 5, 2, 25, 10];

// 숫자 배열의 오름차순 정렬. 비교 함수의 반환값이 0보다 작으면 a를 우선하여 정렬한다.
points.sort((a, b) => a - b);
console.log(points); // [1, 2, 5, 10, 25, 40, 100]

// 숫자 배열에서 최소/최대값 취득
console.log(points[0], points[points.length]); // 1

// 숫자 배열의 내림차순 정렬. 비교 함수의 반환값이 0보다 작으면 b를 우선하여 정렬한다.
points.sort((a, b) => b - a);
console.log(points); // [100, 40, 25, 10, 5, 2, 1]

// 숫자 배열에서 최대값 취득
console.log(points[0]); // 100
```

### 27.9.2 Array.prototype.forEach

`forEach`는 `for`문을 대체하는 고차함수이다. 자신의 내부에서 반복문을 실행하는, 즉, `for`문을 추상화한 고차 함수로 호출한 배열을 순회하며 콜백 함수로 수행해야 할 처리를 받아 반복 호출한다.

```
const numbers = [1, 2, 3];
let pows = [];

// forEach 메서드는 numbers 배열의 모든 요소를 순회하면서 콜백 함수를 반복 호출한다.
numbers.forEach(item => pows.push(item ** 2));
console.log(pows); // [1, 4, 9]

```

콜백 함수에서 3개의 인수를 받을 수 있다(배열의 요소값과 인덱스, 호출한 배열 자체). 이를 통해 원본 배열을 바꿀 수도 있다.

```
const numbers = [1, 2, 3];

// forEach 메서드는 원본 배열을 변경하지 않지만 콜백 함수를 통해 원본 배열을 변경할 수는 있다.
// 콜백 함수의 세 번째 매개변수 arr은 원본 배열 numbers를 가리킨다.
// 따라서 콜백 함수의 세 번째 매개변수 arr을 직접 변경하면 원본 배열 numbers가 변경된다.
numbers.forEach((item, index, arr) => { arr[index] = item ** 2; });
console.log(numbers); // [1, 4, 9]
```

반환값은 언제나 `undefined`이다.

```
const result = [1, 2, 3].forEach(console.log);
console.log(result); // undefined
```

`break`, `continue`를 사용할 수 없다. 또한 희소배열의 경우 존재하지 않는 요소는 순회 대상에서 제외된다.

```
[1, 2, 3].forEach(item => {
  console.log(item);
  if (item > 1) break; // SyntaxError: Illegal break statement
});

[1, 2, 3].forEach(item => {
  console.log(item);
  if (item > 1) continue;
  // SyntaxError: Illegal continue statement: no surrounding iteration statement
});

// 희소 배열
const arr = [1, , 3];

// for 문으로 희소 배열을 순회
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]); // 1, undefined, 3
}

// forEach 메서드는 희소 배열의 존재하지 않는 요소를 순회 대상에서 제외한다.
arr.forEach(v => console.log(v)); // 1, 3
```

`for`문보다 성능이 좋지는 않지만, 가독성이 뛰어나다.

### 27.9.3 Array.prototype.map

배열의 모든 요소를 순회하며 전달받은 콜백 함수를 반복 호출한다. 그리고 콜백 함수의 반환값들로 이루어진 새로운 배열을 반환한다.

```
const numbers = [1, 4, 9];

// map 메서드는 numbers 배열의 모든 요소를 순회하면서 콜백 함수를 반복 호출한다.
// 그리고 콜백 함수의 반환값들로 구성된 새로운 배열을 반환한다.
const roots = numbers.map(item => Math.sqrt(item));

// 위 코드는 다음과 같다.
// const roots = numbers.map(Math.sqrt);

// map 메서드는 새로운 배열을 반환한다
console.log(roots);   // [ 1, 2, 3 ]
// map 메서드는 원본 배열을 변경하지 않는다
console.log(numbers); // [ 1, 4, 9 ]
```

`forEach`가 `undefined`를 반환하는 반면, `map`은 새로운 배열을 반환한다.
이때 이 새로운 배열의 `length`프로퍼티 값과 호출한 배열의 `length`프로퍼티 값은 반드시 같다. 즉, 1:1 매핑한다.

`map`또한 콜백함수에서 요소값과 인덱스, 배열 자체를 전달받을 수 있다.

```
// map 메서드는 콜백 함수를 호출하면서 3개(요소값, 인덱스, this)의 인수를 전달한다.
[1, 2, 3].map((item, index, arr) => {
  console.log(`요소값: ${item}, 인덱스: ${index}, this: ${JSON.stringify(arr)}`);
  return item;
});
/*
요소값: 1, 인덱스: 0, this: [1,2,3]
요소값: 2, 인덱스: 1, this: [1,2,3]
요소값: 3, 인덱스: 2, this: [1,2,3]
*/
```

`map`의 두번째 인수로 콜백 함수 내부에서 `this`로 사용할 객체를 전달할 수 있다.

```
class Prefixer {
  constructor(prefix) {
    this.prefix = prefix;
  }

  add(arr) {
    return arr.map(function (item) {
      // 외부에서 this를 전달하지 않으면 this는 undefined를 가리킨다.
      return this.prefix + item;
    }, this); // map 메서드의 콜백 함수 내부에서 this로 사용할 객체를 전달
  }
}

const prefixer = new Prefixer('-webkit-');
console.log(prefixer.add(['transition', 'user-select']));
// ['-webkit-transition', '-webkit-user-select']
```

더 나은 방법은 화살표 함수를 사용하는 것이다.

```
class Prefixer {
  constructor(prefix) {
    this.prefix = prefix;
  }

  add(arr) {
    // 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조한다.
    return arr.map(item => this.prefix + item);
  }
}

const prefixer = new Prefixer('-webkit-');
console.log(prefixer.add(['transition', 'user-select']));
// ['-webkit-transition', '-webkit-user-select']
```

### 27.9.4 Array.prototype.filter

콜백 함수의 리턴값이 `true`인 요소로만 구성된 새로운 배열을 반환한다.

```
const numbers = [1, 2, 3, 4, 5];

// filter 메서드는 numbers 배열의 모든 요소를 순회하면서 콜백 함수를 반복 호출한다.
// 그리고 콜백 함수의 반환값이 true인 요소로만 구성된 새로운 배열을 반환한다.
// 다음의 경우 numbers 배열에서 홀수인 요소만을 필터링한다(1은 true로 평가된다).
const odds = numbers.filter(item => item % 2);
console.log(odds); // [1, 3, 5]
```

`filter`또한 콜백함수에서 요소값, 인덱스, 배열 자체를 전달받을 수 있다.

```
// filter 메서드는 콜백 함수를 호출하면서 3개(요소값, 인덱스, this)의 인수를 전달한다.
[1, 2, 3].filter((item, index, arr) => {
  console.log(`요소값: ${item}, 인덱스: ${index}, this: ${JSON.stringify(arr)}`);
  return item % 2;
});
/*
요소값: 1, 인덱스: 0, this: [1,2,3]
요소값: 2, 인덱스: 1, this: [1,2,3]
요소값:
```

`this`로 사용할 값을 전달받을 수도 있으며, 더 좋은 방법은 역시 화살표 함수를 이용하는 것이다.

`filter`는 배열에서 특정 요소를 제거하기 위해 사용할수도 있다.

```
class Users {
  constructor() {
    this.users = [
      { id: 1, name: 'Lee' },
      { id: 2, name: 'Kim' }
    ];
  }

  // 요소 추출
  findById(id) {
    // id가 일치하는 사용자만 반환한다.
    return this.users.filter(user => user.id === id);
  }

  // 요소 제거
  remove(id) {
    // id가 일치하지 않는 사용자를 제거한다.
    this.users = this.users.filter(user => user.id !== id);
  }
}

const users = new Users();

let user = users.findById(1);
console.log(user); // [{ id: 1, name: 'Lee' }]

// id가 1인 사용자를 제거한다.
users.remove(1);

user = users.findById(1);
console.log(user); // []
```

### 27.9.5 Array.prototype.reduce

자신을 호출한 배열의 모든 요소를 순회하며 인수로 전달받은 콜백 함수를 호출한다. 이 반환값을 다음 순회의 콜백 함수의 첫번째 인자로 전달하며 콜백함수를 호출해서 하나의 결과값을 만들어 반환한다.

첫번째 인자로 콜백함수, 두번째로 초기값을 전달받는다. 콜백함수에는 4개의 인수(초기값 또는 이전 콜백 함수의 반환값, 배열의 요소값과 인덱스, 배열 자체)가 전달된다.

```
// [1, 2, 3, 4]의 모든 요소의 누적을 구한다.
const sum = [1, 2, 3, 4].reduce((accumulator, currentValue, index, array) => accumulator + currentValue, 0);

console.log(sum); // 10
```

`reduce`는 하나의 값을 구해야 하는 경우 사용한다.

#### 평균 구하기

```
const values = [1, 2, 3, 4, 5, 6];

const average = values.reduce((acc, cur, i, { length }) => {
  // 마지막 순회가 아니면 누적값을 반환하고 마지막 순회면 누적값으로 평균을 구해 반환한다.
  return i === length - 1 ? (acc + cur) / length : acc + cur;
}, 0);

console.log(average); // 3.5
```

#### 최댓값 구하기

```
const values = [1, 2, 3, 4, 5];

const max = values.reduce((acc, cur) => (acc > cur ? acc : cur), 0);
console.log(max); // 5
```

물론 `Math.max`를 사용하는게 더 직관적이다.

#### 요소의 중복 횟수 구하기

```
const fruits = ['banana', 'apple', 'orange', 'orange', 'apple'];

const count = fruits.reduce((acc, cur) => {
  // 첫 번째 순회 시 acc는 초기값인 {}이고 cur은 첫 번째 요소인 'banana'다.
  // 초기값으로 전달받은 빈 객체에 요소값인 cur을 프로퍼티 키로, 요소의 개수를 프로퍼티 값으로
  // 할당한다. 만약 프로퍼티 값이 undefined(처음 등장하는 요소)이면 프로퍼티 값을 1로 초기화한다.
  acc[cur] = (acc[cur] || 0) + 1;
  return acc;
}, {});

// 콜백 함수는 총 5번 호출되고 다음과 같이 결과값을 반환한다.
/*
{banana: 1} => {banana: 1, apple: 1} => {banana: 1, apple: 1, orange: 1}
=> {banana: 1, apple: 1, orange: 2} => {banana: 1, apple: 2, orange: 2}
*/

console.log(count); // { banana: 1, apple: 2, orange: 2 }
```

#### 중첩 배열 평탄화

```
const values = [1, [2, 3], 4, [5, 6]];

const flatten = values.reduce((acc, cur) => acc.concat(cur), []);
// [1] => [1, 2, 3] => [1, 2, 3, 4] => [1, 2, 3, 4, 5, 6]

console.log(flatten); // [1, 2, 3, 4, 5, 6]
```

물론 `Array.prototype.flat`이 직관적이다.

#### 중복 요소 제거

```
const values = [1, 2, 1, 3, 5, 4, 5, 3, 4, 4];

const result = values.reduce(
  (unique, val, i, _values) =>
    // 현재 순회 중인 요소의 인덱스 i가 val의 인덱스와 같다면 val은 처음 순회하는 요소다.
    // 현재 순회 중인 요소의 인덱스 i가 val의 인덱스와 다르다면 val은 중복된 요소다.
    // 처음 순회하는 요소만 초기값 []가 전달된 unique 배열에 담아 반환하면 중복된 요소는 제거된다.
    _values.indexOf(val) === i ? [...unique, val] : unique,
  []
);

console.log(result); // [1, 2, 3, 5, 4]
```

`filter`가 더 직관적이다.
또한 `set`을 사용할수도 있다. 중복을 제거할때는 이를 추천한다.

```
const values = [1, 2, 1, 3, 5, 4, 5, 3, 4, 4];

// 중복을 허용하지 않는 Set 객체의 특성을 활용하여 배열에서 중복된 요소를 제거할 수 있다.
const result = [...new Set(values)];
console.log(result); // [1, 2, 3, 5, 4]
```

이처럼 `map, filter, some. find, every`같은 고차함수는 `reduce`를 사용해 구현할 수 있다.

`reduce`의 두번째 인수는 생략할 수 있다. 하지만 초기값은 전달하는 편이 언제나 안전하다.

```
const sum = [].reduce((acc, cur) => acc + cur);
// TypeError: Reduce of empty array with no initial value

sum = [].reduce((acc, cur) => acc + cur, 0);
console.log(sum); // 0
```

또한 객체의 특정 프로퍼티 값을 함산하는 경우를 생각해보자.

```
const products = [
  { id: 1, price: 100 },
  { id: 2, price: 200 },
  { id: 3, price: 300 }
];

// 1번째 순회 시 acc는 { id: 1, price: 100 }, cur은 { id: 2, price: 200 }이고
// 2번째 순회 시 acc는 300, cur은 { id: 3, price: 300 }이다.
// 2번째 순회 시 acc에 함수에 객체가 아닌 숫자값이 전달된다. 이때 acc.price는 undefined다.
const priceSum = products.reduce((acc, cur) => acc.price + cur.price);

console.log(priceSum); // NaN

priceSum = products.reduce((acc, cur) => acc + cur.price, 0);

console.log(priceSum); // 600
```

### 27.9.6 Array.prototype.some

> 배열을 순회하며 인수로 전달된 콜백함수를 호출한다. 콜백 함수의 리턴이 단 한번이라도 참이면 `true` 아니라면 `false`를 전달한다. 단, 빈 배열에서 호출한 경우 언제나 `false`를 반환한다. 마찬가지로 콜백 함수에서 요소값과 인덱스, 배열 자체를 전달받을 수 있다.

```
// 배열의 요소 중에 10보다 큰 요소가 1개 이상 존재하는지 확인
[5, 10, 15].some(item => item > 10); // -> true

// 배열의 요소 중에 0보다 작은 요소가 1개 이상 존재하는지 확인
[5, 10, 15].some(item => item < 0); // -> false

// 배열의 요소 중에 'banana'가 1개 이상 존재하는지 확인
['apple', 'banana', 'mango'].some(item => item === 'banana'); // -> true

// some 메서드를 호출한 배열이 빈 배열인 경우 언제나 false를 반환한다.
[].some(item => item > 3); // -> false
```

메서드의 두번째 인자로 `this`로 사용할 객체를 전달할 수 있다. 물론 좋은 방법은 화살표 함수를 사용하는 것이다.

### 27.9.7 Array.prototype.every

> 배열을 순회하며 인수로 전달된 콜백함수를 호출한다. 콜백 함수의 반환값이 전부 참이면 `true` 한번이라도 거짓이면 `false`를 전달한다. 단, 빈 배열에서 호출한 경우 언제나 `true`를 반환한다. 마찬가지로 콜백 함수에서 요소값과 인덱스, 배열 자체를 전달받을 수 있다.

```
// 배열의 모든 요소가 3보다 큰지 확인
[5, 10, 15].every(item => item > 3); // -> true

// 배열의 모든 요소가 10보다 큰지 확인
[5, 10, 15].every(item => item > 10); // -> false

// every 메서드를 호출한 배열이 빈 배열인 경우 언제나 true를 반환한다.
[].every(item => item > 3); // -> true
```

### 27.9.8 Array.prototype.find

> 반환값이 `true`인 첫번째 요소를 전달한다. 없다면 `undefined`를 반환한다. 마찬가지로 콜백 함수에서 요소값과 인덱스, 배열 자체를 전달받을 수 있다.

```
const users = [
  { id: 1, name: 'Lee' },
  { id: 2, name: 'Kim' },
  { id: 2, name: 'Choi' },
  { id: 3, name: 'Park' }
];

// id가 2인 첫 번째 요소를 반환한다. find 메서드는 배열이 아니라 요소를 반환한다.
users.find(user => user.id === 2); // -> {id: 2, name: 'Kim'}
```

메서드의 두번째 인자로 `this`로 사용할 객체를 전달할 수 있다. 물론 좋은 방법은 화살표 함수를 사용하는 것이다.

### 27.9.9 Array.prototype.findIndex

콜백함수를 호출해 반환값이 `true`인 첫번째 요소의 인덱스를 반환한다. 만약 `true`인 요소가 존재하지 않으면 -1을 리턴한다. 마찬가지로 콜백 함수에서 요소값과 인덱스, 배열 자체를 전달받을 수 있다.

```
const users = [
  { id: 1, name: 'Lee' },
  { id: 2, name: 'Kim' },
  { id: 2, name: 'Choi' },
  { id: 3, name: 'Park' }
];

// id가 2인 요소의 인덱스를 구한다.
users.findIndex(user => user.id === 2); // -> 1

// name이 'Park'인 요소의 인덱스를 구한다.
users.findIndex(user => user.name === 'Park'); // -> 3

// 위와 같이 프로퍼티 키와 프로퍼티 값으로 요소의 인덱스를 구하는 경우
// 다음과 같이 콜백 함수를 추상화할 수 있다.
function predicate(key, value) {
  // key와 value를 기억하는 클로저를 반환
  return item => item[key] === value;
}

// id가 2인 요소의 인덱스를 구한다.
users.findIndex(predicate('id', 2)); // -> 1

// name이 'Park'인 요소의 인덱스를 구한다.
users.findIndex(predicate('name', 'Park')); // -> 3
```

메서드의 두번째 인자로 `this`로 사용할 객체를 전달할 수 있다. 물론 좋은 방법은 화살표 함수를 사용하는 것이다.

### 27.9.10 Array.prototype.flatMap

`map`을 통해 만든 새로운 배열을 평탄화한다. 즉 `map`과 `flat`을 순차적으로 실행한다.

```
const arr = ['hello', 'world'];

// map과 flat을 순차적으로 실행
arr.map(x => x.split('')).flat();
// -> ['h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd']

// flatMap은 map을 통해 생성된 새로운 배열을 평탄화한다.
arr.flatMap(x => x.split(''));
// -> ['h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd']
```

단, 평탄화의 깊이를 지정할수는 없고, 1단계만 평탄화한다. 만약 깊이를 지정해야한다면 `flatMap`대신 `flat`과 `map`을 차례로 사용하자.

```
const arr = ['hello', 'world'];

// flatMap은 1단계만 평탄화한다.
arr.flatMap((str, index) => [index, [str, str.length]]);
// -> [[0, ['hello', 5]], [1, ['world', 5]]] => [0, ['hello', 5], 1, ['world', 5]]

// 평탄화 깊이를 지정해야 하면 flatMap 메서드를 사용하지 말고 map 메서드와 flat 메서드를 각각 호출한다.
arr.map((str, index) => [index, [str, str.length]]).flat(2);
// -> [[0, ['hello', 5]], [1, ['world', 5]]] => [0, 'hello', 5, 1, 'world', 5]
```

# 28장 Number

## 28.1 Number 생성자 함수

Number 객체는 생성자 함수 객체이다. 따라서 new 연산자와 함께 사용해서 Number인스턴스를 생성할 수 있다.

인수에 아무것도 전달하지 않고 new 연산자로 호출하면 [[NumberData]] 내부 슬롯에 0을 할당한 Number 래퍼 객체를 생성한다.

```js
const numObj = new Number();
console.log(numObj); // Number {[[PrimitiveValue]]: 0}
```

ES5 에서는 [[NumberData]]를 [[PrimitiveValue]]로 불렀다.

숫자를 전달하며 new 연산자와 함께 호출하면, 전달받은 숫자를 할당한 Number 래퍼 객체를 생성한다.

```js
const numObj = new Number(10);
console.log(numObj); // Number {[[PrimitiveValue]]: 10}
```

숫자가 아닌 값을 인수로 전달하면 숫자로 강제 변환하고, 그게 불가능하다면 NaN을 내부 슬롯에 할당한다.

```js
let numObj = new Number("10");
console.log(numObj); // Number {[[PrimitiveValue]]: 10}

numObj = new Number("Hello");
console.log(numObj); // Number {[[PrimitiveValue]]: NaN}
```

new 를 사용하지 않고 Number를 호출하면 인스턴스가 아닌 숫자를 반환한다. 이를 이용한 명시적 타입 변환이 가능하다.

```js
// 문자열 타입 => 숫자 타입
Number("0"); // -> 0
Number("-1"); // -> -1
Number("10.53"); // -> 10.53

// 불리언 타입 => 숫자 타입
Number(true); // -> 1
Number(false); // -> 0
```

## 28.2 Number 프로퍼티

### 28.2.1 Number.EPSILON

1과 1보다 큰 숫자 중에서 가장 작은 숫자와의 차이와 같다.

부동 소수점을 표현하기 위해 쓰이는 IEEE 754는 2진법으로 변환했을 때 무한소수가 되어 미세한 오차가 발생할 수밖에 없는 구조적 한계가 있다.

```js
0.1 + 0.2; // -> 0.30000000000000004
0.1 + 0.2 === 0.3; // -> false
```

이를 Number.EPSILON을 사용해서 해결할 수 있다.

```js
function isEqual(a, b) {
	// a와 b를 뺀 값의 절대값이 Number.EPSILON보다 작으면 같은 수로 인정한다.
	return Math.abs(a - b) < Number.EPSILON;
}

isEqual(0.1 + 0.2, 0.3); // -> true
```

### 28.2.2 Number.MAX_VALUE

JS에서 표현할 수 있는 가장 큰 양수값이다. 이보다 큰 숫자는 Infinity다.

```js
Number.MAX_VALUE; // -> 1.7976931348623157e+308
Infinity > Number.MAX_VALUE; // -> true
```

### 28.2.3 Number.MIN_VALUE

JS에서 표현할 수 있는 가장 작은 양수값이다. 이보다 작은 숫자는 0이다.

```js
Number.MIN_VALUE; // -> 5e-324
Number.MIN_VALUE > 0; // -> true
```

### 28.2.4 Number.MAX_SAFE_INTEGER

JS에서 안전하게 표현할 수 있는 가장 큰 정수값이다.

```js
Number.MAX_SAFE_INTEGER; // -> 9007199254740991
```

### 28.2.5 Number.MIN_SAFE_INTEGER

JS에서 안전하게 표현할 수 있는 가장 작은 정수값이다.

```js
Number.MIN_SAFE_INTEGER; // -> -9007199254740991
```

### 28.2.6 Number.POSITIVE_INFINITY

양의 무한대를 나타내는 숫자값 Infinity와 같다.

```js
Number.POSITIVE_INFINITY; // -> Infinity
```

### 28.2.7 Number.NEGATIVE_INFINITY

음의 무한대를 나타내는 숫자값 -Infinity와 같다.

```js
Number.NEGATIVE_INFINITY; // -> -Infinity
```

### 28.2.8 Number.NaN

NaN을 나타내는 숫자이다. window.NaN과 같다.

```js
Number.NaN; // -> NaN
```

## 28.3 Number 메서드

### 28.3.1 Number.isFinite

Infinity 혹은 -Infinity인지를 검사해 결과를 불리언으로 반환한다.

```js
// 인수가 정상적인 유한수이면 true를 반환한다.
Number.isFinite(0); // -> true
Number.isFinite(Number.MAX_VALUE); // -> true
Number.isFinite(Number.MIN_VALUE); // -> true

// 인수가 무한수이면 false를 반환한다.
Number.isFinite(Infinity); // -> false
Number.isFinite(-Infinity); // -> false
```

인수가 NaN이면 항상 false를 반환한다.
전달받은 인자를 숫자로 암묵적 변환하지 않는다. 따라서 숫자가 아닌 값이 주어지면 언제나 false를 반환한다.

```js
Number.isFinite(NaN); // -> false

// Number.isFinite는 인수를 숫자로 암묵적 타입 변환하지 않는다.
Number.isFinite(null); // -> false

// isFinite는 인수를 숫자로 암묵적 타입 변환한다. null은 0으로 암묵적 타입 변환된다.
isFinite(null); // -> true
```

### 28.3.2 Number.isInteger

숫자값이 정수인지를 검사하여 그 결과를 불리언으로 반환한다. 암묵적 타입 변환을 하지 않는다.

```js
// 인수가 정수이면 true를 반환한다.
Number.isInteger(0); // -> true
Number.isInteger(123); // -> true
Number.isInteger(-123); // -> true

// 0.5는 정수가 아니다.
Number.isInteger(0.5); // -> false
// '123'을 숫자로 암묵적 타입 변환하지 않는다.
Number.isInteger("123"); // -> false
// false를 숫자로 암묵적 타입 변환하지 않는다.
Number.isInteger(false); // -> false
// Infinity/-Infinity는 정수가 아니다.
Number.isInteger(Infinity); // -> false
Number.isInteger(-Infinity); // -> false
```

### 28.3.3. Number.isNaN

인수로 전달된 숫자값이 NaN인지 검사하여 결과를 불리언으로 반환한다.

```js
// 인수가 NaN이면 true를 반환한다.
Number.isNaN(NaN); // -> true
```

암묵적 타입 변환이 발생하지 않는다. 따라서 숫자가 아닌 값이 주어지면 언제난 false를 반환한다.

```js
// Number.isNaN은 인수를 숫자로 암묵적 타입 변환하지 않는다.
Number.isNaN(undefined); // -> false

// isFinite는 인수를 숫자로 암묵적 타입 변환한다. undefined는 NaN으로 암묵적 타입 변환된다.
isNaN(undefined); // -> true
```

### 28.3.4 Number.isSafeInteger

안전한 정수인지 검사하여 불리언 값을 반환한다. 암묵적 타입 변환이 발생하지 않는다.

```js
// 0은 안전한 정수이다.
Number.isSafeInteger(0); // -> true
// 1000000000000000은 안전한 정수이다.
Number.isSafeInteger(1000000000000000); // -> true

// 10000000000000001은 안전하지 않다.
Number.isSafeInteger(10000000000000001); // -> false
// 0.5은 정수가 아니다.
Number.isSafeInteger(0.5); // -> false
// '123'을 숫자로 암묵적 타입 변환하지 않는다.
Number.isSafeInteger("123"); // -> false
// false를 숫자로 암묵적 타입 변환하지 않는다.
Number.isSafeInteger(false); // -> false
// Infinity/-Infinity는 정수가 아니다.
Number.isSafeInteger(Infinity); // -> false
```

### 28.3.5 Number.prototype.toExponential

숫자를 지수 표기법으로 변환하여 반환한다. 매우 크거나 작은 수를 표기할 때 주로 사용하며, e 앞에 있는 숫자에 10의 n승을 곱하는 형식으로 수를 나타낸다. 인수로 소수점 이하로 표현할 자릿수를 전달할 수 있다.

```js
(77.1234).toExponential(); // -> "7.71234e+1"
(77.1234).toExponential(4); // -> "7.7123e+1"
(77.1234).toExponential(2); // -> "7.71e+1"
```

숫자 뒤의 .은 의미가 모호하기 때문에 숫자 리터럴을 전달할 경우 에러가 발생한다.

```js
77.toExponential(); // -> SyntaxError: Invalid or unexpected token
```

.뒤에 숫자가 이어지면 명백히 수소점 숫자의 소수 구분 기호이다. 따라서 두번째 . 은 프로퍼티 접근 연산자로 해석된다. 따라서 숫자 리터럴과 메서드를 함께 사용할 경우 혼란을 방지하기 위해 그룹 연산자를 사용하는 편이 좋다.

```js
(77.1234).toExponential(); // -> "7.71234e+1"
(77).toExponential(); // -> "7.7e+1"
```

JS는 수자 정수 부분과 소수 부분 사이에 공백을 허용하지 않는다. 따라서 숫자 뒤의 . 뒤에 공백이 오면 .을 프로퍼티 접근 연산자로 해석한다.

```js
(77).toExponential(); // -> "7.7e+1"
```

### 28.3.6 Number.prototype.toFixed

숫자를 반올림해 문자열로 반환한다. 소수점 이하 자리를 나타내는 0~20 사이의 정수값을 인수로 전달할 수 있다. 생략하면 0이 지정된다.

```js
// 소수점 이하 반올림. 인수를 생략하면 기본값 0이 지정된다.
(12345.6789).toFixed(); // -> "12346"
// 소수점 이하 1자리수 유효, 나머지 반올림
(12345.6789).toFixed(1); // -> "12345.7"
// 소수점 이하 2자리수 유효, 나머지 반올림
(12345.6789).toFixed(2); // -> "12345.68"
// 소수점 이하 3자리수 유효, 나머지 반올림
(12345.6789).toFixed(3); // -> "12345.679"
```

### 28.3.7 Number.prototype.toPrecision

인수로 받은 전체 자릿수까지 유효하도록 나머지 자릿수를 반환하도록 반올림하여 문자열로 반환한다. 전달받은 전체 자릿수로 표현 불가능함녀 지수 표기법으로 결과를 반환한다.
자릿수를 나타내는 0~21 사이의 정수값을 인수로 전ㄷ라할 수 있다. 생략하면 0이 지정된다.

```js
// 전체 자리수 유효. 인수를 전달하지 않으면 기본값 0이 전달된다.
(12345.6789).toPrecision(); // -> "12345.6789"
// 전체 1자리수 유효, 나머지 반올림
(12345.6789).toPrecision(1); // -> "1e+4"
// 전체 2자리수 유효, 나머지 반올림
(12345.6789).toPrecision(2); // -> "1.2e+4"
// 전체 6자리수 유효, 나머지 반올림
(12345.6789).toPrecision(6); // -> "12345.7"
```

### 28.3.8 Number.prototype.toString

toString 메서드는 숫자를 문자열로 변환하여 반환한다. 진법을 나타내는 2~36 사이의 정수값을 인수로 전달할 수 있다. 생략하면 기본 10진법이 지정된다.

```js
// 인수를 생략하면 10진수 문자열을 반환한다.
(10).toString(); // -> "10"
// 2진수 문자열을 반환한다.
(16).toString(2); // -> "10000"
// 8진수 문자열을 반환한다.
(16).toString(8); // -> "20"
// 16진수 문자열을 반환한다.
(16).toString(16); // -> "10"
```

# 29장 Math

Math는 정적 프로퍼티와 정적 메서드만 제공한다.

## 29.1 Math 프로퍼티

### 29.1.1 Math.PI

원주율을 반환한다.

## 29.2 Math 메서드

### 29.2.1 Math.abs

인수로 전달된 숫자의 절대값을 반환한다.

```js
Math.abs(-1); // -> 1
Math.abs("-1"); // -> 1
Math.abs(""); // -> 0
Math.abs([]); // -> 0
Math.abs(null); // -> 0
Math.abs(undefined); // -> NaN
Math.abs({}); // -> NaN
Math.abs("string"); // -> NaN
Math.abs(); // -> NaN
```

### 29.2.2 Math.round

인수로 전달된 숫자의 소수점 이하를 반올림한 정수를 반환한다.

```js
Math.round(1.4); // -> 1
Math.round(1.6); // -> 2
Math.round(-1.4); // -> -1
Math.round(-1.6); // -> -2
Math.round(1); // -> 1
Math.round(); // -> NaN
```

### 29.2.3 Math.ceil

숫자의 소수점 이하를 올림한 정수를 반환한다.

```js
Math.ceil(1.4); // -> 2
Math.ceil(1.6); // -> 2
Math.ceil(-1.4); // -> -1
Math.ceil(-1.6); // -> -1
Math.ceil(1); // -> 1
Math.ceil(); // -> NaN
```

### 29.2.4 Math.floor

숫자의 소수점 이하를 내림한 정수를 반환한다.

```js
Math.floor(1.9); // -> 1
Math.floor(9.1); // -> 9
Math.floor(-1.9); // -> -2
Math.floor(-9.1); // -> -10
Math.floor(1); // -> 1
Math.floor(); // -> NaN
```

### 29.2.5 Math.sqrt

숫자의 제곱근을 반환한다.

```js
Math.sqrt(9); // -> 3
Math.sqrt(-9); // -> NaN
Math.sqrt(2); // -> 1.414213562373095
Math.sqrt(1); // -> 1
Math.sqrt(0); // -> 0
Math.sqrt(); // -> NaN
```

### 29.2.6 Math.random

임의의 난수를 반환한다. 0에서 1 미만의 실수이다.

```js
Math.random(); // 0에서 1 미만의 랜덤 실수(0.8208720231391746)

/*
1에서 10 범위의 랜덤 정수 취득
1) Math.random으로 0에서 1 미만의 랜덤 실수를 구한 다음, 10을 곱해 0에서 10 미만의
랜덤 실수를 구한다.
2) 0에서 10 미만의 랜덤 실수에 1을 더해 1에서 10 범위의 랜덤 실수를 구한다.
3) Math.floor로 1에서 10 범위의 랜덤 실수의 소수점 이하를 떼어 버린 다음 정수를 반환한다.
*/
const random = Math.floor(Math.random() * 10 + 1);
console.log(random); // 1에서 10 범위의 정수
```

### 29.2.7 Math.pow

첫번째 인수를 밑으로, 두번째 인수를 지수로 거듭제곱한 결과를 반환한다.

```js
Math.pow(2, 8); // -> 256
Math.pow(2, -1); // -> 0.5
Math.pow(2); // -> NaN
```

지수 연산자가 가독성이 더 좋다.

```js
// ES7 지수 연산자
2 ** (2 ** 2); // -> 16
Math.pow(Math.pow(2, 2), 2); // -> 16
```

### 29.2.8 Math.max

인수로 전달된 수 중 최댓값을 반환한다. 인수가 전달되지 않으면 -Infinity를 반환한다.

```js
Math.max(1); // -> 1
Math.max(1, 2); // -> 2
Math.max(1, 2, 3); // -> 3
Math.max(); // -> -Infinity
```

배열을 전달받아 최대값을 구하려면 Function.prototype.apply 메서드 또는 스프레드 문법을 사용한다.

```js
// 배열 요소 중에서 최대값 취득
Math.max.apply(null, [1, 2, 3]); // -> 3

// ES6 스프레드 문법
Math.max(...[1, 2, 3]); // -> 3
```

### 29.2.9 Math.min

인수 중 가장 작은 수를 반환한다. 인수가 전달되지 않으면 Infinity를 반환한다.

```js
Math.min(1); // -> 1
Math.min(1, 2); // -> 1
Math.min(1, 2, 3); // -> 1
Math.min(); // -> Infinity
```

배열 중 최소값을 구하려면 Function.prototype.apply 메서드 또는 스프레드 문법을 사용한다.

```js
// 배열 요소 중에서 최소값 취득
Math.min.apply(null, [1, 2, 3]); // -> 1

// ES6 스프레드 문법
Math.min(...[1, 2, 3]); // -> 1
```

# 30장 Date

Date는 날짜와 시간을 위한 메서드를 제공하는 빌트인 객체이면서 생성자 함수이다.

UTC는 국제 표준시를 말한다. UTC 는 GMT로 불리기도 한다. 일상에서는 혼용되어서 사용되나, 기술적으로는 UTC가 사용된다.

KST는 UTC에 9시간을 더한 시간이다.

## 30.1 Date 생성자 함수

Date 객체는 내부적으로 날짜와 시간을 나타내는 정수값을 가진다. 이 값은 1970년 1월 1일 00:00:00을 기점으로 Date객체가 나타내는 날짜와 시간까지의 밀리초를 나타낸다. 예를 들어, 1970년 1월 2일 0시를 나타내는 Date 객체는 내부적으로 정수값 86,400,400 을 가진다. Date 객체는 기본적으로 현재 날짜와 시간을 나타내는 정수값을 가진다. Date 생성자 함수로 객체를 생성하는 방법은 다음과 같이 4가지가 있다.

### 30.1.1 new Date()

현재 날짜와 시간을 가지는 Date 객체를 반환한다. 내부적으로 날짜와 시간을 나타내는 정수값을 갖지만 Date 객체를 콘솔에 출력하면 기본적으로 날짜와 시간 정보를 출력한다.

```js
new Date(); // -> Mon Jul 06 2020 01:03:18 GMT+0900 (대한민국 표준시)
```

new 연산자 없이 호출하면 날짜와 시간 정보를 나타내는 문자열을 반환한다.

```js
Date(); // -> "Mon Jul 06 2020 01:10:47 GMT+0900 (대한민국 표준시)"
```

### 30.1.2 new Date(milliseconds)

숫자 타입의 밀리초를 인수로 전달하면 1970년 1월 1일 00:00:00을 기점으로 인수로 전달된 밀리초만큼 경과한 날짜와 시간을 나타내는 Date 객체를 나타낸다.

```js
// 한국 표준시 KST는 협정 세계시 UTC에 9시간을 더한 시간이다.
new Date(0); // -> Thu Jan 01 1970 09:00:00 GMT+0900 (대한민국 표준시)

/*
86400000ms는 1day를 의미한다.
1s = 1,000ms
1m = 60s * 1,000ms = 60,000ms
1h = 60m * 60,000ms = 3,600,000ms
1d = 24h * 3,600,000ms = 86,400,000ms
*/
new Date(86400000); // -> Fri Jan 02 1970 09:00:00 GMT+0900 (대한민국 표준시)
```

### 31.1.3 new Date(dateString)

날짜와 시간을 나타내는 문자열을 전달하면 지정된 날짜와 시간을 나타내는 Date 객체를 반환한다. 전달되는 문자열은 Date.parse 메서드에 의해 해석 가능한 형식이어야 한다.

```js
new Date("May 26, 2020 10:00:00");
// -> Tue May 26 2020 10:00:00 GMT+0900 (대한민국 표준시)

new Date("2020/03/26/10:00:00");
// -> Thu Mar 26 2020 10:00:00 GMT+0900 (대한민국 표준시)
```

### 31.1.4 new Date(year, month[, day, hour, minite, second, millisecond])

Date 생성자 함수에 연, 월, 일, 시, 분, 초, 밀리초를 의미하는 숫자를 인수로 전달하면 지정된 날자와 시간을 나타내는 Date 객체를 반환한다. 지정하지 않은 옵션 정보는 0 또는 1이다.
|인수|내용|
|--|--|
|year|연을 나타냄.1900년 이후의 정수|
|month|월을 나타냄. 0~11까지의 정수|
|day|일을 나타내는 1~31까지의 정수|
|hour|시를 나타내는 0~23까지의 정수|
|minute|분을 나타냄. 0~59까지의 정수|
|second|초를 나타냄. 0~59까지의 정수|
|millisecond|밀리초를 나타냄. 0~599까지의 정수|

연, 월을 지정하지 않은 경우 1970년 1월 1일 00:00:00을 나타내는 Date객체를 반환한다.

```js
// 월을 나타내는 2는 3월을 의미한다. 2020/3/1/00:00:00:00
new Date(2020, 2);
// -> Sun Mar 01 2020 00:00:00 GMT+0900 (대한민국 표준시)

// 월을 나타내는 2는 3월을 의미한다. 2020/3/26/10:00:00:00
new Date(2020, 2, 26, 10, 00, 00, 0);
// -> Thu Mar 26 2020 10:00:00 GMT+0900 (대한민국 표준시)

// 다음처럼 표현하면 가독성이 훨씬 좋다.
new Date("2020/3/26/10:00:00:00");
// -> Thu Mar 26 2020 10:00:00 GMT+0900 (대한민국 표준시)
```

## 30.2 Date 메서드

### 30.2.1 Date.now

1970년 1월 1일 00:00:00을 기점으로 현재 시간까지 경과한 밀리초를 숫자로 반환한다.

```js
const now = Date.now(); // -> 1593971539112

// Date 생성자 함수에 숫자 타입의 밀리초를 인수로 전달하면 1970년 1월 1일 00:00:00(UTC)을
// 기점으로 인수로 전달된 밀리초만큼 경과한 날짜와 시간을 나타내는 Date 객체를 반환한다.
// (30.1.2절 "new Date(milliseconds)" 참고)
new Date(now); // -> Mon Jul 06 2020 02:52:19 GMT+0900 (대한민국 표준시)
```

### 30.2.2 Date.parse

1970년 1월 1일 00:00:00을 기점으로 인수로 전달된 지정 시간까지의 밀리초를 숫자로 반환한다.

```js
// UTC
Date.parse("Jan 2, 1970 00:00:00 UTC"); // -> 86400000

// KST
Date.parse("Jan 2, 1970 09:00:00"); // -> 86400000

// KST
Date.parse("1970/01/02/09:00:00"); // -> 86400000
```

### 30.2.3 Date.UTC

1970년 1월 1일 00:00:00을 기점으로 인수로 전달된 지정 시간까지의 밀리초를 숫자로 반환한다. 이때 new Date(year, month[, day, hour, minite, second, millisecond])와 같은 형식의 인수를 사용해야한다.

```js
Date.UTC(1970, 0, 2); // -> 86400000
Date.UTC("1970/1/2"); // -> NaN
```

### 30.2.4 Date.prototype.getFullYear

Date 객체의 연도를 나타내는 정수를 반환한다.

```js
new Date("2020/07/24").getFullYear(); // -> 2020
```

### 30.2.5 Date.prototype.setFullYear

Date 객체에 연도를 나타내는 정수를 설정한다. 옵션으로 월, 일도 설정이 가능하다.

```js
const today = new Date();

// 년도 지정
today.setFullYear(2000);
today.getFullYear(); // -> 2000

// 년도/월/일 지정
today.setFullYear(1900, 0, 1);
today.getFullYear(); // -> 1900
```

### 30.2.6 Date.prototype.getMonth

Date 객체의 월을 나타내는 0~11 의 정수를 반환한다.

```js
new Date("2020/07/24").getMonth(); // -> 6
```

### 30.2.7 Date.prototype.setMonth

Date 객체에 월을 나타내는 0~11까지의 정수를 설정한다. 옵션으로 일도 설정이 가능하다.

```js
const today = new Date();

// 월 지정
today.setMonth(0); // 1월
today.getMonth(); // -> 0

// 월/일 지정
today.setMonth(11, 1); // 12월 1일
today.getMonth(); // -> 11
```

### 30.2.8 Date.prototype.getDate

Date 객체의 날짜(1~31)을 나타내는 정수를 반환한다.

```js
new Date("2020/07/24").getDate(); // -> 24
```

### 30.2.9 Date.prototype.setDate

Date 객체에 날짜(1~31)을 나타내는 정수를 설정한다.

```js
const today = new Date();

// 날짜 지정
today.setDate(1);
today.getDate(); // -> 1
```

### 30.2.10 Date.prototype.getDay

객체의 요일을 나타내는 정수(0~6)을 반환하다.

```js
new Date("2020/07/24").getDay(); // -> 5
```

### 30.2.11 Date.prototype.getHours

Date객체의 시간을 나타내는 정수를 반환한다.

```js
new Date("2020/07/24/12:00").getHours(); // -> 12
```

### 30.2.12 Date.prototype.setHours

Date객체에 시간을 나타내는 정수를 설정한다. 옵션으로 분, 초, 밀리초도 설정 가능하다.

```js
const today = new Date();

// 시간 지정
today.setHours(7);
today.getHours(); // -> 7

// 시간/분/초/밀리초 지정
today.setHours(0, 0, 0, 0); // 00:00:00:00
today.getHours(); // -> 0
```

### 30.2.13 Date.prototype.getMinutes

Date 객체의 분을 나타내는 정수를 반환한다.

```js
new Date("2020/07/24/12:30").getMinutes(); // -> 30
```

### 30.2.14 Date.prototype.setMinutes

Date 객체에 분을 나타내는 정수를 설정한다. 옵션을 초, 밀리초도 설정 가능하다.

```js
const today = new Date();

// 분 지정
today.setMinutes(50);
today.getMinutes(); // -> 50

// 분/초/밀리초 지정
today.setMinutes(5, 10, 999); // HH:05:10:999
today.getMinutes(); // -> 5
```

### 30.2.15 Date.prototype.getSeconds

Date 객체의 초를 나타내는 정수를 반환한다.

```js
new Date("2020/07/24/12:30:10").getSeconds(); // -> 10
```

### 30.2.16 Date.prototype.setSeconds

Date 객체에 초를 나타내는 정수를 설정한다. 옵션으로 밀리초도 설정 가능하다.

```js
const today = new Date();

// 초 지정
today.setSeconds(30);
today.getSeconds(); // -> 30

// 초/밀리초 지정
today.setSeconds(10, 0); // HH:MM:10:000
today.getSeconds(); // -> 10
```

### 30.2.17 Date.prototype.getMilliseconds

Date 객체의 밀리초를 나타내는 정수를 반환한다.

```js
new Date("2020/07/24/12:30:10:150").getMilliseconds(); // -> 150
```

### 30.2.18 Date.prototype.setMilliseconds

Date 객체에 밀리초를 나타내는 정수를 설정한다.

```js
const today = new Date();

// 밀리초 지정
today.setMilliseconds(123);
today.getMilliseconds(); // -> 123
```

### 30.2.19 Date.prototype.getTime

1970년 1월 1일 00:00:00을 기점으로 Date 객체의 시간까지 경과된 밀리초를 반환한다.

```js
new Date("2020/07/24/12:30").getTime(); // -> 1595561400000
```

### 30.2.20 Date.prototype.setTime

Date 객체에 1970년 1월 1일 00:00:00를 기점으로 경과된 밀리초를 설정한다.

```js
const today = new Date();

// 1970년 1월 1일 00:00:00(UTC)를 기점으로 경과된 밀리초 설정
today.setTime(86400000); // 86400000는 1day를 나타낸다.
console.log(today); // -> Fri Jan 02 1970 09:00:00 GMT+0900 (대한민국 표준시)
```

### 30.2.21 Date.prototype.getTimezondOffset

UTC와 Date 객체에 지정된 로캘 시간과의 차이를 분 단위로 반환한다.

```js
const today = new Date(); // today의 지정 로캘은 KST다.

//UTC와 today의 지정 로캘 KST와의 차이는 -9시간이다.
today.getTimezoneOffset() / 60; // -9
```

### 30.2.22 Date.prototype.toDateString

사람이 읽을 수 있는 형식의 문자열로 Date 객체의 날짜를 반환하다.

```js
const today = new Date("2020/7/24/12:30");

today.toString(); // -> Fri Jul 24 2020 12:30:00 GMT+0900 (대한민국 표준시)
today.toDateString(); // -> Fri Jul 24 2020
```

### 30.2.23 Date.prototype.toTimeString

사람이 읽을 수 있는 형식의 문자열로 Date 객체의 시간을 표현한 문자열을 반환하다.

```js
const today = new Date("2020/7/24/12:30");

today.toString(); // -> Fri Jul 24 2020 12:30:00 GMT+0900 (대한민국 표준시)
today.toTimeString(); // -> 12:30:00 GMT+0900 (대한민국 표준시)
```

### 30.2.24 Date.prototype.toISOString

ISO 8610 형식으로 Date 객체의 날짜와 시간을 표현한 문자열을 반환한다.

```js
const today = new Date("2020/7/24/12:30");

today.toString(); // -> Fri Jul 24 2020 12:30:00 GMT+0900 (대한민국 표준시)
today.toISOString(); // -> 2020-07-24T03:30:00.000Z

today.toISOString().slice(0, 10); // -> 2020-07-24
today.toISOString().slice(0, 10).replace(/-/g, ""); // -> 20200724
```

### 30.2.25 Date.prototype.toLocaleString

인수로 전달한 로캘을 기준으로 Date 객체의 날짜와 시간을 표현한 문자열을 반환한다. 인수를 생략한 경우 브라우저가 동작중인 시스템의 로캘을 적용한다.

```js
const today = new Date("2020/7/24/12:30");

today.toString(); // -> Fri Jul 24 2020 12:30:00 GMT+0900 (대한민국 표준시)
today.toLocaleString(); // -> 2020. 7. 24. 오후 12:30:00
today.toLocaleString("ko-KR"); // -> 2020. 7. 24. 오후 12:30:00
today.toLocaleString("en-US"); // -> 7/24/2020, 12:30:00 PM
today.toLocaleString("ja-JP"); // -> 2020/7/24 12:30:00
```

### 30.2.26 Date.prototype.toLocaleTimeString

인수로 전달한 로캘을 기준으로 Date 객체의 시간을 표현한 문자열을 반환한다. 인수를 생략한 경우 브라우저가 동작 중인 시스템의 로캘을 적용한다.

```js
const today = new Date("2020/7/24/12:30");

today.toString(); // -> Fri Jul 24 2020 12:30:00 GMT+0900 (대한민국 표준시)
today.toLocaleTimeString(); // -> 오후 12:30:00
today.toLocaleTimeString("ko-KR"); // -> 오후 12:30:00
today.toLocaleTimeString("en-US"); // -> 12:30:00 PM
today.toLocaleTimeString("ja-JP"); // -> 12:30:00
```

## Date 활용 시계 예제

```js
(function printNow() {
	const today = new Date();

	const dayNames = [
		"(일요일)",
		"(월요일)",
		"(화요일)",
		"(수요일)",
		"(목요일)",
		"(금요일)",
		"(토요일)",
	];
	// getDay 메서드는 해당 요일(0 ~ 6)을 나타내는 정수를 반환한다.
	const day = dayNames[today.getDay()];

	const year = today.getFullYear();
	const month = today.getMonth() + 1;
	const date = today.getDate();
	let hour = today.getHours();
	let minute = today.getMinutes();
	let second = today.getSeconds();
	const ampm = hour >= 12 ? "PM" : "AM";

	// 12시간제로 변경
	hour %= 12;
	hour = hour || 12; // hour가 0이면 12를 재할당

	// 10미만인 분과 초를 2자리로 변경
	minute = minute < 10 ? "0" + minute : minute;
	second = second < 10 ? "0" + second : second;

	const now = `${year}년 ${month}월 ${date}일 ${day} ${hour}:${minute}:${second} ${ampm}`;

	console.log(now);

	// 1초마다 printNow 함수를 재귀 호출한다. 41.2.1절 "setTimeout / clearTimeout" 참고
	setTimeout(printNow, 1000);
})();
```

# 31장 RegExp

## 31.1 정규 표현식이란?

> 일정한 패턴을 가진 문자열의 집합을 표현하기 위해 사용하는 형식 언어

- 자바스크립트의 고유 문법이 아님
- 문자열 대상 패턴 매칭 기능 제공 - 특정 패턴과 일치하는 문자열을 검색하거나 추출 또는 치환 가능
- 주석과 공백을 허용하지 않고, 여러 기호를 혼합해서 가독성이 좋지 않음

## 31.2 정규 표현식 생성

> 리터럴과 생성자 함수를 이용 가능하다

---

리터럴은 패턴과 플래그로 구성된다. `//`는 시작기호와 종료 기호이며 이 사이에 패턴이 들어간다. 종료 기호 뒤에 오는 것이 플래그이다.

리터럴은 다음과 같이 생성한다

```js
const target = "Is this all there is?";

// 패턴: is
// 플래그: i => 대소문자를 구별하지 않고 검색한다.
const regexp = /is/i;

// test 메서드는 target 문자열에 대해 정규표현식 regexp의 패턴을 검색하여 매칭 결과를 불리언 값으로 반환한다.
regexp.test(target); // -> true
```

생성자 함수를 사용할수도 있다.

```js
const target = "Is this all there is?";

const regexp = new RegExp(/is/i); // ES6
// const regexp = new RegExp(/is/, 'i');
// const regexp = new RegExp('is', 'i');

regexp.test(target); // -> true
```

## 31.3 RegExp 메서드

### 31.3.1 exec

> 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색해 매칭 **결과를 배열로 반환한다.** 결과가 없으면 `null`을 반환한다.

```js
const target = "Is this all there is?";
const regExp = /is/;

regExp.exec(target); // -> ["is", index: 5, input: "Is this all there is?", groups: undefined]
```

### 31.3.2 test

> 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색해 매칭 **결과를 불리언으로 반환한다.**

```js
const target = "Is this all there is?";
const regExp = /is/;

regExp.test(target); // -> true
```

### 31.3.3 match

> 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색해 매칭 **결과를 배열로 반환한다.** g플래그가 지정되면 모든 매칭 결과를 배열로 반환한다.

```js
const target = "Is this all there is?";
const regExp = /is/;

target.match(regExp); // -> ["is", index: 5, input: "Is this all there is?", groups: undefined]
```

```js
const target = "Is this all there is?";
const regExp = /is/g;

target.match(regExp); // -> ["is", "is"]
```

## 31.4 플래그

> 검색 방식을 설정한다

- i: 대소문자를 구별하지 않고 패턴을 검색
- g: 패턴과 일치하는 모든 문자열을 전역 검색
- m: 문자열의 행이 바뀌어도 패턴 검색을 계속한다.

플래그는 옵션이며, 하나 이상의 플래그를 사용할 수 있다.

플래그를 사용하지 않으면, 대소문자 구별해서 일치하는 첫번째 대상만 검색하고 종료한다.

```js
const target = "Is this all there is?";

// target 문자열에서 is 문자열을 대소문자를 구별하여 한 번만 검색한다.
target.match(/is/);
// -> ["is", index: 5, input: "Is this all there is?", groups: undefined]

// target 문자열에서 is 문자열을 대소문자를 구별하지 않고 한 번만 검색한다.
target.match(/is/i);
// -> ["Is", index: 0, input: "Is this all there is?", groups: undefined]

// target 문자열에서 is 문자열을 대소문자를 구별하여 전역 검색한다.
target.match(/is/g);
// -> ["is", "is"]

// target 문자열에서 is 문자열을 대소문자를 구별하지 않고 전역 검색한다.
target.match(/is/gi);
// -> ["Is", "is", "is"]
```

## 31.5 패턴

> 일정한 규칙을 표현하기 위해 사용.

- `/`를 사용해 열고 닫음
- 따옴표 생략

### 31.5.1 문자열 검색

패턴에 문자 혹은 문자열을 지정하면 검색 대상 문자열에서 패턴으로 지정한 문자 또는 문자열을 검색함

- 플래그를 생략했을 경우 대소문자 구별해 정규 표현식과 매치한 첫 번째 결과만 반환한다.

```js
const target = "Is this all there is?";

// 'is' 문자열과 매치하는 패턴. 플래그가 생략되었으므로 대소문자를 구별한다.
const regExp = /is/;

// target과 정규 표현식이 매치하는지 테스트한다.
regExp.test(target); // -> true

// target과 정규 표현식의 매칭 결과를 구한다.
target.match(regExp);
// -> ["is", index: 5, input: "Is this all there is?", groups: undefined]
```

대소문자를 구별하지 않으려면 i를 사용한다.

```js
const target = "Is this all there is?";

// 'is' 문자열과 매치하는 패턴. 플래그 i를 추가하면 대소문자를 구별하지 않는다.
const regExp = /is/i;

target.match(regExp);
// -> ["Is", index: 0, input: "Is this all there is?", groups: undefined]
```

문자열을 전역 검색하려면 g를 사용한다.

```js
const target = "Is this all there is?";

// 'is' 문자열과 매치하는 패턴.
// 플래그 g를 추가하면 대상 문자열 내에서 패턴과 일치하는 모든 문자열을 전역 검색한다.
const regExp = /is/gi;

target.match(regExp); // -> ["Is", "is", "is"]
```

### 31.5.2 임의의 문자열 검색

.은 임의의 문자열 하나를 의미한다.

```js
const target = "Is this all there is?";

// 임의의 3자리 문자열을 대소문자를 구별하여 전역 검색한다.
const regExp = /.../g;

target.match(regExp); // -> ["Is ", "thi", "s a", "ll ", "the", "re ", "is?"]
```

### 31.5.3 반복 검색

{m,n}은 최소 m개, 최대 n개의 패턴이 반복됨을 의미한다. 콤마 뒤에 공백이 있으면 정상 작동하지 않는다.

```js
const target = "A AA B BB Aa Bb AAA";

// 'A'가 최소 1번, 최대 2번 반복되는 문자열을 전역 검색한다.
const regExp = /A{1,2}/g;

target.match(regExp); // -> ["A", "AA", "A", "AA", "A"]
```

{n}은 패턴이 n번 반복된다.

```js
const target = "A AA B BB Aa Bb AAA";

// 'A'가 2번 반복되는 문자열을 전역 검색한다.
const regExp = /A{2}/g;

target.match(regExp); // -> ["AA", "AA"]
```

{n,}은 패턴이 최소 n번 이상 반복된다.

```js
const target = "A AA B BB Aa Bb AAA";

// 'A'가 최소 2번 이상 반복되는 문자열을 전역 검색한다.
const regExp = /A{2,}/g;

target.match(regExp); // -> ["AA", "AAA"]
```

- 는 패턴이 최소 한번 이상 반복된다.

```js
const target = "A AA B BB Aa Bb AAA";

// 'A'가 최소 한 번 이상 반복되는 문자열('A, 'AA', 'AAA', ...)을 전역 검색한다.
const regExp = /A+/g;

target.match(regExp); // -> ["A", "AA", "A", "AAA"]
```

?는 패턴이 최대 한번까지 반복된다. 즉, 반복되지 않을 수도 있다

```js
const target = "color colour";

// 'colo' 다음 'u'가 최대 한 번(0번 포함) 이상 반복되고 'r'이 이어지는 문자열 'color', 'colour'를 전역 검색한다.
const regExp = /colou?r/g;

target.match(regExp); // -> ["color", "colour"]
```

### 31.5.4 OR 검색

`|` 는 or의 의미이다.

```js
const target = "A AA B BB Aa Bb";

// 'A' 또는 'B'를 전역 검색한다.
const regExp = /A|B/g;

target.match(regExp); // -> ["A", "A", "A", "B", "B", "B", "A", "B"]
```

분해되지 않은 단어 레벨로 검색하고 싶으면 + 를 사용한다.

```js
const target = "A AA B BB Aa Bb";

// 'A' 또는 'B'가 한 번 이상 반복되는 문자열을 전역 검색한다.
// 'A', 'AA', 'AAA', ... 또는 'B', 'BB', 'BBB', ...
const regExp = /A+|B+/g;

target.match(regExp); // -> ["A", "AA", "B", "BB", "A", "B"]
```

범위를 지정하려면 `[]` 내에 `-` 를 사용한다.

```js
const target = "A AA B BB Aa Bb";

// 'A' 또는 'B'가 한 번 이상 반복되는 문자열을 전역 검색한다.
// 'A', 'AA', 'AAA', ... 또는 'B', 'BB', 'BBB', ...
const regExp = /[AB]+/g;

target.match(regExp); // -> ["A", "AA", "B", "BB", "A", "B"]
```

대소문자 구별없이 알파벳을 검색하려면 다음과 같다.

```js
const target = "A AA BB ZZ Aa Bb";

// 'A' ~ 'Z'가 한 번 이상 반복되는 문자열을 전역 검색한다.
// 'A', 'AA', 'AAA', ... 또는 'B', 'BB', 'BBB', ... ~ 또는 'Z', 'ZZ', 'ZZZ', ...
const regExp = /[A-Z]+/g;

target.match(regExp); // -> ["A", "AA", "BB", "ZZ", "A", "B"]
```

`\d` 는 숫자를 의미하며, `\D` 는 숫자가 아닌 문자를 의미한다.

```js
const target = "AA BB 12,345";

// '0' ~ '9' 또는 ','가 한 번 이상 반복되는 문자열을 전역 검색한다.
let regExp = /[\d,]+/g;

target.match(regExp); // -> ["12,345"]

// '0' ~ '9'가 아닌 문자(숫자가 아닌 문자) 또는 ','가 한 번 이상 반복되는 문자열을 전역 검색한다.
regExp = /[\D,]+/g;

target.match(regExp); // -> ["AA BB ", ","]
```

`\w` 는 알파벳, 숫자, 언더스코어를 의미한다. `\W` 는 알파벳, 숫자, 언더스코어가 아닌 문자이다.

### 31.5.5 NOT 검색

`[...]` 내부의 `^` 은 not의 의미를 가진다.

```js
const target = "AA BB 12 Aa Bb";

// 숫자를 제외한 문자열을 전역 검색한다.
const regExp = /[^0-9]+/g;

target.match(regExp); // -> ["AA BB ", " Aa Bb"]
```

### 31.5.6 시작 위치로 검색

`[...]` 외부의 `^` 은 시작을 의미한다.

```js
const target = "https://poiemaweb.com";

// 'https'로 시작하는지 검사한다.
const regExp = /^https/;

regExp.test(target); // -> true
```

### 31.5.7 마지막 위치로 검색

`$` 는 문자열의 마지막을 의미한다.

```js
const target = "https://poiemaweb.com";

// 'com'으로 끝나는지 검사한다.
const regExp = /com$/;

regExp.test(target); // -> true
```

# 32장 String

## 32.1 String 생성자 함수

String 객체는 생성자 함수 객체이다. 따라서 `new` 연산자와 함께 호출해 String 인스턴스를 생성할 수 있다.
인수를 전달하지 않고 `new` 와 함께 호출하면 `[[StringData]]` 내부 슬롯에 빈 문자열을 할당한 String 래퍼 객체를 생성한다.

```js
const strObj = new String();
console.log(strObj); // String {length: 0, [[PrimitiveValue]]: ""}
```

이때 접근할 수 없는 `[[PrimitiveValue]]` 내부 프로퍼티는 `[[StringData]]` 내부 슬롯을 가리킨다.

만약에 인수로 문자열을 전달하면서 `new` 연산자와 함께 호출하면 `[[StringData]]` 내부 슬롯에 인수로 전달받은 문자열을 할당한 String 래퍼 객체를 생성한다.

```js
const strObj = new String("Lee");
console.log(strObj);
// String {0: "L", 1: "e", 2: "e", length: 3, [[PrimitiveValue]]: "Lee"}
```

String 래퍼 객체는 `length` 프로퍼티와 인덱스를 나타내는 숫자 형식의 문자열을 프로퍼티 키로, 각 문자열은 프로퍼티 값으로 가지는 유사 배열 객체이면서 이터러블이다. 따라서 인덱스를 사용해 각 문자에 접근이 가능하다. 단, 문자열은 원시 값이므로 변경할 수 없다. 이때 에러는 발생하지 않는다.

```js
// 문자열은 원시값이므로 변경할 수 없다. 이때 에러가 발생하지 않는다.
strObj[0] = "S";
console.log(strObj); // 'Lee'
```

인수로 문자열이 아닌 값을 전달하면 문자열로 강제 변환한 후, `[[StringData]]` 내부 슬롯에 변환된 문자열을 할당한 String 래퍼 객체를 생성한다.

```js
let strObj = new String(123);
console.log(strObj);
// String {0: "1", 1: "2", 2: "3", length: 3, [[PrimitiveValue]]: "123"}

strObj = new String(null);
console.log(strObj);
// String {0: "n", 1: "u", 2: "l", : "l", length: 4, [[PrimitiveValue]]: "null"}
```

`new` 연산자를 사용하지 않고 String 생성자 함수를 호출하면 인스턴스가 아닌 문자열을 반환한다.

```js
// 숫자 타입 => 문자열 타입
String(1); // -> "1"
String(NaN); // -> "NaN"
String(Infinity); // -> "Infinity"

// 불리언 타입 => 문자열 타입
String(true); // -> "true"
String(false); // -> "false"
```

## 32.2 length 프로퍼티

문자열에 있는 문자 개수를 반환한다.

```js
"Hello".length; // -> 5
"안녕하세요!".length; // -> 6
```

## 32.3 String 메서드

String의 메서드는 언제나 새로운 문자열을 반환한다.

### 32.3.1 String.prototype.indexOf

> 대상 문자열에서 인수로 전달받은 문자열을 검색해 첫 번째 인덱스를 반환한다. 검색에 실패하면 -1을 반환한다.

```js
const str = "Hello World";

// 문자열 str에서 'l'을 검색하여 첫 번째 인덱스를 반환한다.
str.indexOf("l"); // -> 2

// 문자열 str에서 'or'을 검색하여 첫 번째 인덱스를 반환한다.
str.indexOf("or"); // -> 7

// 문자열 str에서 'x'를 검색하여 첫 번째 인덱스를 반환한다. 검색에 실패하면 -1을 반환한다.
str.indexOf("x"); // -> -1
```

두번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.

```js
// 문자열 str의 인덱스 3부터 'l'을 검색하여 첫 번째 인덱스를 반환한다.
str.indexOf("l", 3); // -> 3
```

문자열에 특정 문자열이 존재하는지 확인할 때 유용하다.

```js
if (str.indexOf("Hello") !== -1) {
	// 문자열 str에 'Hello'가 포함되어 있는 경우에 처리할 내용
}
```

물론 이는 `includes` 메서드를 확인하면 가독성이 더 좋다.

```js
if (str.includes("Hello")) {
	// 문자열 str에 'Hello'가 포함되어 있는 경우에 처리할 내용
}
```

### 32.3.2 String.prototype.search

> 대상 문자열에서 인수로 전달받은 정규 표현식과 매치하는 문자열을 검색해 일치하는 문자열의 인덱스를 반환한다. 검색에 실패하면 -1을 반환한다.

```js
const str = "Hello world";

// 문자열 str에서 정규 표현식과 매치하는 문자열을 검색하여 일치하는 문자열의 인덱스를 반환한다.
str.search(/o/); // -> 4
str.search(/x/); // -> -1
```

### 32.3.3 String.prototype.includes

> 대상 문자열에서 인수로 전달받은 문자열이 포함되어 있는지를 확인하고 결과를 불리언으로 전달한다.

```js
const str = "Hello world";

str.includes("Hello"); // -> true
str.includes(""); // -> true
str.includes("x"); // -> false
str.includes(); // -> false
```

2번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.

```js
const str = "Hello world";

// 문자열 str의 인덱스 3부터 'l'이 포함되어 있는지 확인
str.includes("l", 3); // -> true
str.includes("H", 3); // -> false
```

### 32.3.4 String.prototype.startsWith

> 대상 문자열이 인수로 전달받은 문자열로 시작하는지를 확인하고 결과를 불리언으로 전달한다.

```js
const str = "Hello world";

// 문자열 str이 'He'로 시작하는지 확인
str.startsWith("He"); // -> true
// 문자열 str이 'x'로 시작하는지 확인
str.startsWith("x"); // -> false
```

2번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.

```js
// 문자열 str의 인덱스 5부터 시작하는 문자열이 ' '로 시작하는지 확인
str.startsWith(" ", 5); // -> true
```

### 32.3.5 String.prototype.endsWith

> 대상 문자열이 인수로 전달받은 문자열로 끝나는지를 확인하고 결과를 불리언으로 전달한다.

```js
const str = "Hello world";

// 문자열 str이 'ld'로 끝나는지 확인
str.endsWith("ld"); // -> true
// 문자열 str이 'x'로 끝나는지 확인
str.endsWith("x"); // -> false
```

2번째 인수로 검색할 문자열의 길이를 전달할 수 있다.

```js
// 문자열 str의 처음부터 5자리까지('Hello')가 'lo'로 끝나는지 확인
str.endsWith("lo", 5); // -> true
```

### 32.3.6 String.prototype.charAt

> 대상 문자열이 인수로 전달받은 인덱스에 위치한 문자를 검색해 반환한다.

```js
const str = "Hello";

for (let i = 0; i < str.length; i++) {
	console.log(str.charAt(i)); // H e l l o
}
```

인덱스는 0~(문자열의 길이 -1) 사이의 정수여야 한다. 범위를 벗어난 정수면 빈 문자열을 반환한다.

```js
// 인덱스가 문자열의 범위(0 ~ str.length-1)를 벗어난 경우 빈문자열을 반환한다.
str.charAt(5); // -> ''
```

### 32.3.7 String.prototype.substring

> 대상 문자열에서 첫번째 인수로 받은 인덱스 위치의 문자 ~ 두번째 인수로 전달받은 인덱스에 위치하는 문자의 바로 직전까지의 문자 를 반환한다.

```js
const str = "Hello World";

// 인덱스 1부터 인덱스 4 이전까지의 부분 문자열을 반환한다.
str.substring(1, 4); // -> ell
```

두번째 인수를 생략하면 첫번째 인수의 인덱스 ~ 끝까지의 문자를 반환한다.

```js
const str = "Hello World";

// 인덱스 1부터 마지막 문자까지 부분 문자열을 반환한다.
str.substring(1); // -> 'ello World'
```

첫 번째 인수는 두 번째 인수보다 작아야 정상이지만, 다음과 같은 경우에도 작동한다.

- 첫번째 인수 > 두번째 인수인 경우 둘은 교체된다.
- 인수 <0 이나 NaN 인 경우 0으로 취급된다.
- 인수 > 문자열의 길이 인 경우 인수는 문자열의 길이로 취급된다.

```js
const str = "Hello World"; // str.length == 11

// 첫 번째 인수 > 두 번째 인수인 경우 두 인수는 교환된다.
str.substring(4, 1); // -> 'ell'

// 인수 < 0 또는 NaN인 경우 0으로 취급된다.
str.substring(-2); // -> 'Hello World'

// 인수 > 문자열의 길이(str.length)인 경우 인수는 문자열의 길이(str.length)으로 취급된다.
str.substring(1, 100); // -> 'ello World'
str.substring(20); // -> ''
```

`indexOf` 메서드와 함께 사용하면 특정 문자열 기준 앞뒤 부분 문자열을 취득할 수 있다.

```js
const str = "Hello World";

// 스페이스를 기준으로 앞에 있는 부분 문자열 취득
str.substring(0, str.indexOf(" ")); // -> 'Hello'

// 스페이스를 기준으로 뒤에 있는 부분 문자열 취득
str.substring(str.indexOf(" ") + 1, str.length); // -> 'World'
```

### 32.3.8 String.prototype.slice

> substring과 동일하게 동작한다. 다만 두번째 인수에 음수를 전달할 경우, 문자열의 뒤에서부터 시작해 문자열을 잘라서 반환한다.

```js
const str = "hello world";

// substring과 slice 메서드는 동일하게 동작한다.
// 0번째부터 5번째 이전 문자까지 잘라내어 반환
str.substring(0, 5); // -> 'hello'
str.slice(0, 5); // -> 'hello'

// 인덱스가 2인 문자부터 마지막 문자까지 잘라내어 반환
str.substring(2); // -> 'llo world'
str.slice(2); // -> 'llo world'

// 인수 < 0 또는 NaN인 경우 0으로 취급된다.
str.substring(-5); // -> 'hello world'
// slice 메서드는 음수인 인수를 전달할 수 있다. 뒤에서 5자리를 잘라내어 반환한다.
str.slice(-5); // ⟶ 'world'
```

### 32.3.9 String.prototype.toUpperCase

> 대상 문자열을 모두 대문자로 변경한 문자열을 반환한다.

```js
const str = "Hello World!";

str.toUpperCase(); // -> 'HELLO WORLD!'
```

### 32.3.10 String.prototype.toLowerCase

> 대상 문자열을 모두 소문자로 변경한 문자열을 반환한다.

```js
const str = "Hello World!";

str.toLowerCase(); // -> 'hello world!'
```

### 32.3.11 String.prototype.trim

> 대상 문자열의 앞 뒤의 공백 문자를 제거한 문자열을 반환한다.

```js
const str = "   foo  ";

str.trim(); // -> 'foo'
```

`trimStart`, `trimEnd` 메서드를 사용해 앞 또는 뒤를 선택할 수 있다.

```js
const str = "   foo  ";

// String.prototype.{trimStart,trimEnd} : Proposal stage 4
str.trimStart(); // -> 'foo  '
str.trimEnd(); // -> '   foo'
```

`replace` 메서드에 정규표현식을 인수로 전달해 공백 문자를 제거 가능하다.

```js
const str = "   foo  ";

// 첫 번째 인수로 전달한 정규 표현식에 매치하는 문자열을 두 번째 인수로 전달한 문자열로 치환한다.
str.replace(/\s/g, ""); // -> 'foo'
str.replace(/^\s+/g, ""); // -> 'foo  '
str.replace(/\s+$/g, ""); // -> '   foo'
```

### 32.3.12 String.prototype.repeat

> 해당 문자열을 인수로 전달받은 정수만큼 반복해 연결한 새로운 문자열을 반환한다. 0일때는 빈 문자열, 음수면 RangeError을 발생시킨다. 인수를 생략하면 0으로 설정된다.

```js
const str = "abc";

str.repeat(); // -> ''
str.repeat(0); // -> ''
str.repeat(1); // -> 'abc'
str.repeat(2); // -> 'abcabc'
str.repeat(2.5); // -> 'abcabc' (2.5 → 2)
str.repeat(-1); // -> RangeError: Invalid count value
```

### 32.3.13 String.prototype.replace

> 첫번째 인수로 받은 문자열 혹은 정규표현식을 검색해 두번째 인수로 받은 문자열로 치환한 문자열을 반환한다.

```js
const str = "Hello world";

// str에서 첫 번째 인수 'world'를 검색하여 두 번째 인수 'Lee'로 치환한다.
str.replace("world", "Lee"); // -> 'Hello Lee'
```

결과가 여러개면 첫번째 검색 결과만 치환한다.

```js
const str = "Hello world world";

str.replace("world", "Lee"); // -> 'Hello Lee world'
```

특수 교체 패턴을 사용할 수 있다.

```js
const str = "Hello world";

// 특수한 교체 패턴을 사용할 수 있다. ($& => 검색된 문자열)
str.replace("world", "<strong>$&</strong>");
```

첫번째 인수로 정규 표현식을 사용할 수 있다.

```js
const str = "Hello Hello";

// 'hello'를 대소문자를 구별하지 않고 전역 검색한다.
str.replace(/hello/gi, "Lee"); // -> 'Lee Lee'
```

두번째 인수로 치환 함수를 전달할 수 있다. 첫번째 인수의 매치 결과를 두번째 인수의 인수로 전달한다.

```js
// 카멜 케이스를 스네이크 케이스로 변환하는 함수
function camelToSnake(camelCase) {
	// /.[A-Z]/g는 임의의 한 문자와 대문자로 이루어진 문자열에 매치한다.
	// 치환 함수의 인수로 매치 결과가 전달되고, 치환 함수가 반환한 결과와 매치 결과를 치환한다.
	return camelCase.replace(/.[A-Z]/g, match => {
		console.log(match); // 'oW'
		return match[0] + "_" + match[1].toLowerCase();
	});
}

const camelCase = "helloWorld";
camelToSnake(camelCase); // -> 'hello_world'

// 스네이크 케이스를 카멜 케이스로 변환하는 함수
function snakeToCamel(snakeCase) {
	// /_[a-z]/g는 _와 소문자로 이루어진 문자열에 매치한다.
	// 치환 함수의 인수로 매치 결과가 전달되고, 치환 함수가 반환한 결과와 매치 결과를 치환한다.
	return snakeCase.replace(/_[a-z]]/g, match => {
		console.log(match); // '_w'
		return match[1].toUpperCase();
	});
}

const snakeCase = "hello_world";
snakeToCamel(snakeCase); // -> 'helloWorld'
```

### 32.3.14 String.prototype.split

> 첫번쨰 인수로 전달한 문자열 혹은 정규표현식을 검색해 문자열을 구분하고, 분리된 각 문자열로 이루어진 배열을 반환한다. 빈 문자열이 인수로 전달되면 각 문자가 분리되고, 인수를 생략하면 문자열 전체를 단일 요소로 하는 배열을 반환한다.

```js
const str = "How are you doing?";

// 공백으로 구분(단어로 구분)하여 배열로 반환한다.
str.split(" "); // -> ["How", "are", "you", "doing?"]

// \s는 여러 가지 공백 문자(스페이스, 탭 등)를 의미한다. 즉, [\t\r\n\v\f]와 같은 의미다.
str.split(/\s/); // -> ["How", "are", "you", "doing?"]

// 인수로 빈 문자열을 전달하면 각 문자를 모두 분리한다.
str.split(""); // -> ["H", "o", "w", " ", "a", "r", "e", " ", "y", "o", "u", " ", "d", "o", "i", "n", "g", "?"]

// 인수를 생략하면 대상 문자열 전체를 단일 요소로 하는 배열을 반환한다.
str.split(); // -> ["How are you doing?"]
```

두번째 인수로 배열의 길이를 지정할 수 있다.

```js
// 공백으로 구분하여 배열로 반환한다. 단, 배열의 길이는 3이다
str.split(" ", 3); // -> ["How", "are", "you"]
```

배열을 지정하기에, 배열 메서드를 사용해 문자열을 역순으로 뒤집을 수 있다.

```js
// 인수로 전달받은 문자열을 역순으로 뒤집는다.
function reverseString(str) {
	return str.split("").reverse().join("");
}

reverseString("Hello world!"); // -> '!dlrow olleH'
```

# 34장 이터러블

## 34.1 이터레이션 프로토콜

ES6 에선 순회 가능한 데이터 컬렉션을 이터레이션 프로토콜을 준수하는 이터러블로 통일하여 `for...of` 문, 스프레드 문법, 배열 디스트럭처링 할당의 대상으로 사용할 수 있도록 일원화했다.

이터레이션 프로토콜에는 **이터러블 프로토콜**과 **이터레이션 프로토콜**이 있다.

- 이터러블 프로토콜: Symbol.iterator를 프로퍼티 키로 사용한 메서드를 직접 구현하거나, 프로토타입 체인을 통해 상속받은 Symbol.iterator 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환한다. 이러한 규약을 이터러블 프로토콜이라 하며, **이터러블 프로토콜을 준수한 객체를 이터블이라 한다. 이터러블은 for…of문으로 순회할 수 있으며 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 있다.**

- 이터레이터 프로토콜: Symbol.iterator 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환한다. 이터레이너는 next 메서드를 소유하며 next 메서드를 호출하면 이터러블을 순회하며 value와 done 프로퍼티를 갖는 이터레이터 리절트 객체를 반환한다. 이러한 규약을 이터레이터 프로토콜이라 하며, 이터레이터 프로토콜을 준수한 객체를 이터레이터라 한다. 이터레이터는 이터러블 요소를 탐색하기 위한 포인터 역할을 한다.

### 34.1.1 이터러블

> 이터러블 프로토콜을 준수한 객체를 이터러블이라고 한다.

이터러블인지 확은하는 함수는 다음과 같이 구현 가능하다.

```js
const isIterable = v => v !== null && typeof v[Symbol.iterator] === "function";

// 배열, 문자열, Map, Set 등은 이터러블이다.
isIterable([]); // -> true
isIterable(""); // -> true
isIterable(new Map()); // -> true
isIterable(new Set()); // -> true
isIterable({}); // -> false
```

배열은 이터러블이다. \*\*이터러블은 `for...of` 문으로 순회할 수 있으며, 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 있다.

```js
const array = [1, 2, 3];

// 배열은 Array.prototype의 Symbol.iterator 메서드를 상속받는 이터러블이다.
console.log(Symbol.iterator in array); // true

// 이터러블인 배열은 for...of 문으로 순회 가능하다.
for (const item of array) {
	console.log(item); // 1 2 3
}

// 이터러블인 배열은 스프레드 문법의 대상으로 사용할 수 있다.
console.log([...array]); // [1, 2, 3]

// 이터러블인 배열은 배열 디스트럭처링 할당의 대상으로 사용할 수 있다.
const [a, ...rest] = array;
console.log(a, rest); // 1, [2, 3]
```

`Symbol.iterator` 메서드를 직접 구현하지 않거나 상속받지 않은 일반 객체는 이터러블 프로토콜을 준수한 이터러블이 아니다. 따라서 일반 객체는 `for...of` 문으로 순회할 수 없으며 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 없다.

```js
const obj = { a: 1, b: 2 };

// 일반 객체는 Symbol.iterator 메서드를 구현하거나 상속받지 않는다.
// 따라서 일반 객체는 이터러블 프로토콜을 준수한 이터러블이 아니다.
console.log(Symbol.iterator in obj); // false

// 이터러블이 아닌 일반 객체는 for...of 문으로 순회할 수 없다.
for (const item of obj) {
	// -> TypeError: obj is not iterable
	console.log(item);
}

// 이터러블이 아닌 일반 객체는 배열 디스트럭처링 할당의 대상으로 사용할 수 없다.
const [a, b] = obj; // -> TypeError: obj is not iterable
```

하지만 일반 객체도 이터러블 프로토콜을 준수하도록 구현하면 이터러블이 된다.

### 34.1.2 이터레이터

> 이터러블의 `Symbol.iterator` 메서드가 반환한 이터레이터는 `next` 메서드를 가진다.

```js
// 배열은 이터러블 프로토콜을 준수한 이터러블이다.
const array = [1, 2, 3];

// Symbol.iterator 메서드는 이터레이터를 반환한다.
const iterator = array[Symbol.iterator]();

// Symbol.iterator 메서드가 반환한 이터레이터는 next 메서드를 갖는다.
console.log("next" in iterator); // true
```

이터레이터의 `next` 메서드는 순회를 위한 포인터 역할을 한다. 즉, `next` 메서드를 호출하면 이터러블을 순차적으로 한 단계씩 순회하며 순회 결과를 나타내는 이터레이터 리절트 객체를 반환한다.

```js
// 배열은 이터러블 프로토콜을 준수한 이터러블이다.
const array = [1, 2, 3];

// Symbol.iterator 메서드는 이터레이터를 반환한다. 이터레이터는 next 메서드를 갖는다.
const iterator = array[Symbol.iterator]();

// next 메서드를 호출하면 이터러블을 순회하며 순회 결과를 나타내는 이터레이터 리절트 객체를
// 반환한다. 이터레이터 리절트 객체는 value와 done 프로퍼티를 갖는 객체다.
console.log(iterator.next()); // { value: 1, done: false }
console.log(iterator.next()); // { value: 2, done: false }
console.log(iterator.next()); // { value: 3, done: false }
console.log(iterator.next()); // { value: undefined, done: true }
```

`next` 메서드가 반환하는 이터레이터 리절트 객체의 `value` 프로퍼트는 현재 순회중인 이터러블의 값이며, `done` 프로퍼티는 순회 완료 여부를 나타낸다.

## 34.2 빌트인 이터러블

JS에서는 이터레이션 프로토콜을 준수한 객체인 빌트인 이터러블을 제공한다.
|빌트인 이터러블|`Symbol.iterator` 메서드|
|--|--|
|Arry|`Array.prototype[Symbol.iterator]`|
|String|`String.prototype[Symbol.iterator]`|
|Map|`Map.prototype[Symbol.iterator]`|
|TypedArray|`TypedArray.prototype[Symbol.iterator]`|
|arguments|`arguments[Symbol.iterator]`|
|Dom컬렉션|`NodeList.prototype[Symbol.iterator]`, `HtmlCollection.prototype[Symbol.iterator]`|

## 34.3 `for...of` 문

> 이터러블을 순회하며 이터러블의 요소를 변수에 할당한다.

`for...of` 문은 내부적으로 이터레이터의 `next` 메서드를 호출해서 이터러블을 순회하며 `next` 메서드가 반환한 이터레이터 리절트 객체의 `value` 프로퍼티 값을 `for...of` 문의 변수에 할당한다. `done` 프로퍼티 값이 `false` 면 순회를 계속하고, `true` 면 중단한다.

```js
for (const item of [1, 2, 3]) {
	// item 변수에 순차적으로 1, 2, 3이 할당된다.
	console.log(item); // 1 2 3
}
```

이 내부 동작을 `for` 문으로 표현하면 다음과 같다.

```js
// 이터러블
const iterable = [1, 2, 3];

// 이터러블의 Symbol.iterator 메서드를 호출하여 이터레이터를 생성한다.
const iterator = iterable[Symbol.iterator]();

for (;;) {
	// 이터레이터의 next 메서드를 호출하여 이터러블을 순회한다. 이때 next 메서드는 이터레이터 리절트 객체를 반환한다.
	const res = iterator.next();

	// next 메서드가 반환한 이터레이터 리절트 객체의 done 프로퍼티 값이 true이면 이터러블의 순회를 중단한다.
	if (res.done) break;

	// 이터레이터 리절트 객체의 value 프로퍼티 값을 item 변수에 할당한다.
	const item = res.value;
	console.log(item); // 1 2 3
}
```

## 34.4 이터러블과 유사 배열 객체

유사 배열 객체는 인덱스로 프로퍼티 값에 접근할 수 있고, `length` 프로퍼티를 가지는 객체를 말한다. `for` 문으로 순회 가능하고, 인덱스를 프로퍼티 키로 가지므로 배열처럼 프로퍼티 값에 접근이 가능하다.

```js
// 유사 배열 객체
const arrayLike = {
	0: 1,
	1: 2,
	2: 3,
	length: 3,
};

// 유사 배열 객체는 length 프로퍼티를 갖기 때문에 for 문으로 순회할 수 있다.
for (let i = 0; i < arrayLike.length; i++) {
	// 유사 배열 객체는 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있다.
	console.log(arrayLike[i]); // 1 2 3
}
```

유사 배열 객체는 일반 객체다. 따라서 `for...of` 문으로 순회가 불가능하다.

```js
// 유사 배열 객체는 이터러블이 아니기 때문에 for...of 문으로 순회할 수 없다.
for (const item of arrayLike) {
	console.log(item); // 1 2 3
}
// -> TypeError: arrayLike is not iterable
```

arguments, NodeList, HTMLCollection 등은 유사 배열 객체이면서 이터러블이다. 그러나 모든 유사 배열 객체가 이터러블인 것은 아니다. 다만 `Array.from` 메서드를 사용해 배열로 간단히 변환할 수 있다.

```js
// 유사 배열 객체
const arrayLike = {
	0: 1,
	1: 2,
	2: 3,
	length: 3,
};

// Array.from은 유사 배열 객체 또는 이터러블을 배열로 변환한다
const arr = Array.from(arrayLike);
console.log(arr); // [1, 2, 3]
```

## 34.5 이터레이션 프로토콜의 중요성

- 이터러블은 `for...of` 문, 스프레드 문법, 배열 디스트럭처링 할당과 같은 데이터 소비자에 의해 사용되므로, **데이터 공급자**의 역할을 한다고 할 수 있다.
- 만약 데이터 공급자별로 순회 방식이 다르다면, 데이터 소비자는 다양한 방법들을 모두 지원해야 할 것이다. 그러나 데이터 공급자가 이터레이션 프로토콜을 지키도록 규정하면 데이터 소비자 역시 이터레이션 프로토콜만 지원하면 된다.
- **즉, 이터레이션 프로토콜은 데이터 소비자와 데이터 공급자를 연결하는 인터페이스 역할을 한다.**

## 34.6 사용자 정의 이터러블

### 34.6.1 사용자 정의 이터러블 구현

일반 객체도 이터레이션 프로토콜을 준수하도록 구현하면 사용자 정의 이터러블이 된다. 피보나치 수열을 구현한 간단한 사용자 정의 이터러블을 구현해 보자.

```js
// 피보나치 수열을 구현한 사용자 정의 이터러블
const fibonacci = {
	// Symbol.iterator 메서드를 구현하여 이터러블 프로토콜을 준수한다.
	[Symbol.iterator]() {
		let [pre, cur] = [0, 1]; // "36.1. 배열 디스트럭처링 할당" 참고
		const max = 10; // 수열의 최대값

		// Symbol.iterator 메서드는 next 메서드를 소유한 이터레이터를 반환해야 하고
		// next 메서드는 이터레이터 리절트 객체를 반환해야 한다.
		return {
			next() {
				[pre, cur] = [cur, pre + cur]; // "36.1. 배열 디스트럭처링 할당" 참고
				// 이터레이터 리절트 객체를 반환한다.
				return { value: cur, done: cur >= max };
			},
		};
	},
};

// 이터러블인 fibonacci 객체를 순회할 때마다 next 메서드가 호출된다.
for (const num of fibonacci) {
	console.log(num); // 1 2 3 5 8
}
```

이터레이션 프로토콜을 준수하도록 `Symbol.iterator` 메서드를 구현하고, `Symbol.iterator` 메서드가 `next` 메서드를 갖는 이터레이터를 반환하도록 한다. `next` 메서드는 `done` 과 `value` 프로퍼티를 가지는 이터레이터 리절트 객체를 반환한다. `for...of` 문은 `done` 프로퍼티가 `true` 가 될때까지 반복한다.

이터러블은 `for...of` 뿐 아니라 스프레드, 배열 디스트럭처링 할당에도 사용할 수 있다.

```js
// 이터러블은 스프레드 문법의 대상이 될 수 있다.
const arr = [...fibonacci];
console.log(arr); // [ 1, 2, 3, 5, 8 ]

// 이터러블은 배열 디스트럭처링 할당의 대상이 될 수 있다.
const [first, second, ...rest] = fibonacci;
console.log(first, second, rest); // 1 2 [ 3, 5, 8 ]
```

### 34.6.2 이터러블을 생성하는 함수

앞선 예시에서는 수열의 최대값 `max` 를 가지고 있었다. 즉, 최대값이 고정되어 있고 외부에서 전달한 값으로 바꿀 수 없단 아쉬움이 있었다. 이를 최대값을 인수로 전달받아 이터러블을 반환하는 함수를 만들어 수정해보자.

```js
// 피보나치 수열을 구현한 사용자 정의 이터러블을 반환하는 함수. 수열의 최대값을 인수로 전달받는다.
const fibonacciFunc = function (max) {
	let [pre, cur] = [0, 1];

	// Symbol.iterator 메서드를 구현한 이터러블을 반환한다.
	return {
		[Symbol.iterator]() {
			return {
				next() {
					[pre, cur] = [cur, pre + cur];
					return { value: cur, done: cur >= max };
				},
			};
		},
	};
};

// 이터러블을 반환하는 함수에 수열의 최대값을 인수로 전달하면서 호출한다.
for (const num of fibonacciFunc(10)) {
	console.log(num); // 1 2 3 5 8
}
```

### 34.6.3 이터러블이면서 이터레이터인 객체를 생성하는 함수

암선 `fibonacciFunc` 함수는 이터러블을 반환한다. 이터레이터를 생성하려면 이터러블의 `Symbol.iterator` 메서드를 호출해야 한다.

```js
// fibonacciFunc 함수는 이터러블을 반환한다.
const iterable = fibonacciFunc(5);
// 이터러블의 Symbol.iterator 메서드는 이터레이터를 반환한다.
const iterator = iterable[Symbol.iterator]();

console.log(iterator.next()); // { value: 1, done: false }
console.log(iterator.next()); // { value: 2, done: false }
console.log(iterator.next()); // { value: 3, done: false }
console.log(iterator.next()); // { value: 5, done: true }
```

이터러블이면서 이터레이터인 객체를 생성하면 `Symbol.iterator` 메서드를 호출하지 않아도 된다. `Symbol.iterator` 메서드는 `this` 를 반환하므로 `next` 메서드를 가지는 이터레이터를 반환한다.

```js
// 이터러블이면서 이터레이터인 객체. 이터레이터를 반환하는 Symbol.iterator 메서드와
// 이터레이션 리절트 객체를 반환하는 next 메서드를 소유한다.
{
  [Symbol.iterator]() { return this; },
  next() {
    return { value: any, done: boolean };
  }
}
```

앞에서 살펴본 `fibonacciFunc` 함수를 이터러블이면서 이터레이터인 객체를 생성하여 반환하는 함수로 변경해보자.

```js
// 이터러블이면서 이터레이터인 객체를 반환하는 함수
const fibonacciFunc = function (max) {
	let [pre, cur] = [0, 1];

	// Symbol.iterator 메서드와 next 메서드를 소유한 이터러블이면서 이터레이터인 객체를 반환
	return {
		[Symbol.iterator]() {
			return this;
		},
		// next 메서드는 이터레이터 리절트 객체를 반환
		next() {
			[pre, cur] = [cur, pre + cur];
			return { value: cur, done: cur >= max };
		},
	};
};

// iter는 이터러블이면서 이터레이터다.
let iter = fibonacciFunc(10);

// iter는 이터러블이므로 for...of 문으로 순회할 수 있다.
for (const num of iter) {
	console.log(num); // 1 2 3 5 8
}

// iter는 이터러블이면서 이터레이터다
iter = fibonacciFunc(10);

// iter는 이터레이터이므로 이터레이션 리절트 객체를 반환하는 next 메서드를 소유한다.
console.log(iter.next()); // { value: 1, done: false }
console.log(iter.next()); // { value: 2, done: false }
console.log(iter.next()); // { value: 3, done: false }
console.log(iter.next()); // { value: 5, done: false }
console.log(iter.next()); // { value: 8, done: false }
console.log(iter.next()); // { value: 13, done: true }
```

### 34.6.4 무한 이터러블과 지연 평가

무한 이터러블을 생성하는 함수를 정의해서 무한 수열을 간단히 구현해보자.

```js
// 무한 이터러블을 생성하는 함수
const fibonacciFunc = function () {
	let [pre, cur] = [0, 1];

	return {
		[Symbol.iterator]() {
			return this;
		},
		next() {
			[pre, cur] = [cur, pre + cur];
			// 무한을 구현해야 하므로 done 프로퍼티를 생략한다.
			return { value: cur };
		},
	};
};

// fibonacciFunc 함수는 무한 이터러블을 생성한다.
for (const num of fibonacciFunc()) {
	if (num > 10000) break;
	console.log(num); // 1 2 3 5 8...4181 6765
}

// 배열 디스트럭처링 할당을 통해 무한 이터러블에서 3개의 요소만 취득한다.
const [f1, f2, f3] = fibonacciFunc();
console.log(f1, f2, f3); // 1 2 3
```

이터러블은 데이터 공급자의 역할을 한다. 배열과 문자열 등은 모든 데이터를 메모리에 이미 확보한 이후 데이터를 공급한다. 하지만 위의 이터러블은 지연평가를 통해 데이터를 생성한다. 데이터가 필요한 시점이 되면 그제서야 비로소 데이터를 생성하는 것이다. 즉, 평가 결과가 필요할 때까지 평가를 늦추는 기법이 지연 평가다.

위 예제에서는 `for...of` 문이나 배열 디스트럭처링 할당 등이 시작되기 전까지 데이터를 생성하지 않는다. 이처럼 지연 평가를 사용하면 빠른 실행 속도와 불필요한 메모리 소비 단속, 무한 표현의 가능 등의 장점이 존재한다.

# 35장 스프레드 문법

> 스프레드 문법은 여러 값들의 집합(배열, 객체 등)을 펼쳐서 개별적인 값들의 목록으로 만든다.

- 스프레드 문법의 대상은 `for...of` 문으로 순회할 수 있는 이터러블에 한정된다.

```js
// ...[1, 2, 3]은 [1, 2, 3]을 개별 요소로 분리한다(→ 1, 2, 3)
console.log(...[1, 2, 3]); // 1 2 3

// 문자열은 이터러블이다.
console.log(..."Hello"); // H e l l o

// Map과 Set은 이터러블이다.
console.log(
	...new Map([
		["a", "1"],
		["b", "2"],
	])
); // [ 'a', '1' ] [ 'b', '2' ]
console.log(...new Set([1, 2, 3])); // 1 2 3

// 이터러블이 아닌 일반 객체는 스프레드 문법의 대상이 될 수 없다.
console.log(...{ a: 1, b: 2 });
// TypeError: Found non-callable @@iterator
```

- 스프레드 문법의 결과는 값이 아니기 때문에, 변수에 할당할 수 없다.

```js
// 스프레드 문법의 결과는 값이 아니다.
const list = ...[1, 2, 3]; // SyntaxError: Unexpected token ...
```

스프레드 문법의 결과문은, 쉼표로 구분한 값의 목록을 사용하는 문맥에서만 사용할 수 있다.

- 함수 호출문의 인수 목록
- 배열 리터럴의 요소 목록
- 객체 리터럴의 프로퍼티 목록

## 35.1 함수 호출문의 인수 목록에서 사용하는 경우

```js
const arr = [1, 2, 3];

// 배열 arr의 요소 중에서 최대값을 구하기 위해 Math.max를 사용한다.
const max = Math.max(arr); // -> NaN
```

이 경우 숫자가 아닌 배열을 전달했기에 `NaN` 을 반환했다.

이전에는 배열의 목록을 인수로 전달하고 싶은 경우, `apply` 메서드를 사용했다.

```js
var arr = [1, 2, 3];

// apply 함수의 2번째 인수(배열)는 apply 함수가 호출하는 함수의 인수 목록이다.
// 따라서 배열이 펼쳐져서 인수로 전달되는 효과가 있다.
var max = Math.max.apply(null, arr); // -> 3
```

스프레드 문법을 사용했을 때, 가독성이 더 좋은 것을 발견할 수 있다.

```js
const arr = [1, 2, 3];

// 스프레드 문법을 사용하여 배열 arr을 1, 2, 3으로 펼쳐서 Math.max에 전달한다.
// Math.max(...[1, 2, 3])은 Math.max(1, 2, 3)과 같다.
const max = Math.max(...arr); // -> 3
```

스프레드 문법은 Rest 파라미터와 형태가 동일해 혼동할 수 있으니 주의한다. 둘의 차이점은 다음과 같다.

- Rest: 목록 => 배열
- 스프레드: 배열 => 목록

즉, 둘은 서로 반대의 개념이다.

```js
// Rest 파라미터는 인수들의 목록을 배열로 전달받는다.
function foo(...rest) {
	console.log(rest); // 1, 2, 3 -> [ 1, 2, 3 ]
}

// 스프레드 문법은 배열과 같은 이터러블을 펼쳐서 개별적인 값들의 목록을 만든다.
// [1, 2, 3] -> 1, 2, 3
foo(...[1, 2, 3]);
```

## 35.2 배열 리터럴 내부에서 사용하는 경우

### 35.2.1 concat

2개의 배열을 하나로 결합하고 싶을 때 `concat` 메서드를 사용했다.

```js
// ES5
var arr = [1, 2].concat([3, 4]);
console.log(arr); // [1, 2, 3, 4]
```

스프레드 문법을 사용하면 별도의 메서드 사용 없이 결합이 가능하다.

```js
// ES6
const arr = [...[1, 2], ...[3, 4]];
console.log(arr); // [1, 2, 3, 4]
```

### 35.2.2 splice

splice메서드의 세 번째 인수로 배열을 전달하면 배열 자체가 추가된다.

```js
// ES5
var arr1 = [1, 4];
var arr2 = [2, 3];

// 세 번째 인수 arr2를 해체하여 전달해야 한다.
// 그렇지 않으면 arr1에 arr2 배열 자체가 추가된다.
arr1.splice(1, 0, arr2);

// 기대한 결과는 [1, [2, 3], 4]가 아니라 [1, 2, 3, 4]다.
console.log(arr1); // [1, [2, 3], 4]
```

위와 같은 경우 `apply` 메서드를 사용해 `splice` 메서드를 호출해야 한다.

```js
// ES5
var arr1 = [1, 4];
var arr2 = [2, 3];

/*
apply 메서드의 2번째 인수(배열)는 apply 메서드가 호출한 splice 메서드의 인수 목록이다.
apply 메서드의 2번째 인수 [1, 0].concat(arr2)는 [1, 0, 2, 3]으로 평가된다.
따라서 splice 메서드에 apply 메서드의 2번째 인수 [1, 0, 2, 3]이 해체되어 전달된다.
즉, arr1[1]부터 0개의 요소를 제거하고 그 자리(arr1[1])에 새로운 요소(2, 3)를 삽입한다.
*/
Array.prototype.splice.apply(arr1, [1, 0].concat(arr2));
console.log(arr1); // [1, 2, 3, 4]
```

스프레드 문법을 사용하면 간결하고 가독성이 좋게 표현할 수 있다.

```js
// ES6
const arr1 = [1, 4];
const arr2 = [2, 3];

arr1.splice(1, 0, ...arr2);
console.log(arr1); // [1, 2, 3, 4]
```

### 35.2.3 배열 복사

ES5에서 배열의 복사는 `slice` 메서드를 사용했다.

```js
// ES5
var origin = [1, 2];
var copy = origin.slice();

console.log(copy); // [1, 2]
console.log(copy === origin); // false
```

스프레드 문법을 사용하면 간결하고 가독성이 좋게 표현할 수 있다.

```js
// ES6
const origin = [1, 2];
const copy = [...origin];

console.log(copy); // [1, 2]
console.log(copy === origin); // false
```

### 35.2.4 이터러블을 배열로 변환

ES5에서 이터러블을 배열로 전환하려면, `apply` 혹은 `call` 메서드를 사용해 `slice` 메서드를 호출해야한다.

```js
// ES5
function sum() {
	// 이터러블이면서 유사 배열 객체인 arguments를 배열로 변환
	var args = Array.prototype.slice.call(arguments);

	return args.reduce(function (pre, cur) {
		return pre + cur;
	}, 0);
}

console.log(sum(1, 2, 3)); // 6
```

이 방법은 이터러블이 아닌 유사 배열 객체도 배열로 변환이 가능하다.

```js
// 이터러블이 아닌 유사 배열 객체
const arrayLike = {
	0: 1,
	1: 2,
	2: 3,
	length: 3,
};

const arr = Array.prototype.slice.call(arrayLike); // -> [1, 2, 3]
console.log(Array.isArray(arr)); // true
```

스프레드 문법을 사용하면 좀 더 간편하게 이터러블을 배열로 변환 가능하다.

```js
// ES6
function sum() {
	// 이터러블이면서 유사 배열 객체인 arguments를 배열로 변환
	return [...arguments].reduce((pre, cur) => pre + cur, 0);
}

console.log(sum(1, 2, 3)); // 6
```

이보다 더 나은 방법은 Rest 파라미터를 사용하는 것이다.

```js
// Rest 파라미터 args는 함수에 전달된 인수들의 목록을 배열로 전달받는다.
const sum = (...args) => args.reduce((pre, cur) => pre + cur, 0);

console.log(sum(1, 2, 3)); // 6
```

단, 이터러블이 아닌 유사 배열 객체는 스프레드 문법의 대상이 될 수 없다.

```js
// 이터러블이 아닌 유사 배열 객체
const arrayLike = {
	0: 1,
	1: 2,
	2: 3,
	length: 3,
};

const arr = [...arrayLike];
// TypeError: object is not iterable (cannot read property Symbol(Symbol.iterator))
```

이터러블이 아닌 유사 배열 객체를 배열로 변경하려면 `Array.from` 메서드를 사용한다.

```js
// Array.from은 유사 배열 객체 또는 이터러블을 배열로 변환한다
Array.from(arrayLike); // -> [1, 2, 3]
```

## 35.3 객체 리터럴 내부에서 사용하는 경우

스프레드문법은 일반 객체를 대상으로도 사용이 허가된다.

```js
// 스프레드 프로퍼티
// 객체 복사(얕은 복사)
const obj = { x: 1, y: 2 };
const copy = { ...obj };
console.log(copy); // { x: 1, y: 2 }
console.log(obj === copy); // false

// 객체 병합
const merged = { x: 1, y: 2, ...{ a: 3, b: 4 } };
console.log(merged); // { x: 1, y: 2, a: 3, b: 4 }
```

이전에는 `Object.assign` 메서드를 사용해 여러개의 객체를 병합하고, 특정 프로퍼티를 변경 또는 추가했다.

```js
// 객체 병합. 프로퍼티가 중복되는 경우, 뒤에 위치한 프로퍼티가 우선권을 갖는다.
const merged = Object.assign({}, { x: 1, y: 2 }, { y: 10, z: 3 });
console.log(merged); // { x: 1, y: 10, z: 3 }

// 특정 프로퍼티 변경
const changed = Object.assign({}, { x: 1, y: 2 }, { y: 100 });
console.log(changed); // { x: 1, y: 100 }

// 프로퍼티 추가
const added = Object.assign({}, { x: 1, y: 2 }, { z: 0 });
console.log(added); // { x: 1, y: 2, z: 0 }
```

스프레드 프로퍼티는 `Object.assign` 메서드를 대체할 수 있는 간편한 문법이다.

```js
// 객체 병합. 프로퍼티가 중복되는 경우, 뒤에 위치한 프로퍼티가 우선권을 갖는다.
const merged = { ...{ x: 1, y: 2 }, ...{ y: 10, z: 3 } };
console.log(merged); // { x: 1, y: 10, z: 3 }

// 특정 프로퍼티 변경
const changed = { ...{ x: 1, y: 2 }, y: 100 };
// changed = { ...{ x: 1, y: 2 }, ...{ y: 100 } }
console.log(changed); // { x: 1, y: 100 }

// 프로퍼티 추가
const added = { ...{ x: 1, y: 2 }, z: 0 };
// added = { ...{ x: 1, y: 2 }, ...{ z: 0 } }
console.log(added); // { x: 1, y: 2, z: 0 }
```

# 36장 디스트럭처링 할당

> 구조화된 배열과 같은 이터러블 또는 객체를 디스트럭처링하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다. 필요한 값만 추출해서 변수에 할당할 때 유용한다.

## 36.1 배열 디스트럭처링 할당

```js
// ES5
var arr = [1, 2, 3];

var one = arr[0];
var two = arr[1];
var three = arr[2];

console.log(one, two, three); // 1 2 3
```

**배열 디스트럭처링 할당의 대상은 이터러블이어야 하며, 할당 기준은 배열의 인덱스다. 즉, 순서대로 할당된다.**

```js
const arr = [1, 2, 3];

// ES6 배열 디스트럭처링 할당
// 변수 one, two, three를 선언하고 배열 arr을 디스트럭처링하여 할당한다.
// 이때 할당 기준은 배열의 인덱스다.
const [one, two, three] = arr;

console.log(one, two, three); // 1 2 3
```

배열 디스트럭처링 할당을 위해서는 할당 연산자 왼쪽에 할당받을 변수를 선언해야 한다. 이때 배열 리터럴 형태로 선언한다.

```js
const [x, y] = [1, 2];
```

우변이 이터러블이 아니면 에러가 발생한다.

```js
const [x, y]; // SyntaxError: Missing initializer in destructuring declaration

const [a, b] = {}; // TypeError: {} is not iterable
```

선언과 할당을 분리할수도 있으나, 이 경우 `const` 키워드를 사용할 수 없으므로 권장하지 않는다.

```js
let x, y;
[x, y] = [1, 2];
```

배열 디스트럭처링은 순서대로 할당된다. 이때 변수의 개수와 이터러블의 요소 개수가 반드시 일치할 필요는 없다.

```js
const [a, b] = [1, 2];
console.log(a, b); // 1 2

const [c, d] = [1];
console.log(c, d); // 1 undefined

const [e, f] = [1, 2, 3];
console.log(e, f); // 1 2

const [g, , h] = [1, 2, 3];
console.log(g, h); // 1 3
```

기본값을 설정할 수 있다.

```js
// 기본값
const [a, b, c = 3] = [1, 2];
console.log(a, b, c); // 1 2 3

// 기본값보다 할당된 값이 우선한다.
const [e, f = 10, g = 3] = [1, 2];
console.log(e, f, g); // 1 2 3
```

필요한 요소만 추출해 변수에 할당하고 싶을 때 유용하다.

```js
// url을 파싱하여 protocol, host, path 프로퍼티를 갖는 객체를 생성해 반환한다.
function parseURL(url = "") {
	// '://' 앞의 문자열(protocol)과 '/' 이전의 '/'으로 시작하지 않는 문자열(host)과 '/' 이후의 문자열(path)을 검색한다.
	const parsedURL = url.match(/^(\w+):\/\/([^/]+)\/(.*)$/);
	console.log(parsedURL);
	/*
  [
    'https://developer.mozilla.org/ko/docs/Web/JavaScript',
    'https',
    'developer.mozilla.org',
    'ko/docs/Web/JavaScript',
    index: 0,
    input: 'https://developer.mozilla.org/ko/docs/Web/JavaScript',
    groups: undefined
  ]
  */

	if (!parsedURL) return {};

	// 배열 디스트럭처링 할당을 사용하여 이터러블에서 필요한 요소만 추출한다.
	const [, protocol, host, path] = parsedURL;
	return { protocol, host, path };
}

const parsedURL = parseURL(
	"https://developer.mozilla.org/ko/docs/Web/JavaScript"
);
console.log(parsedURL);
/*
{
  protocol: 'https',
  host: 'developer.mozilla.org',
  path: 'ko/docs/Web/JavaScript'
}
*/
```

Rest 요소를 사용할 수 있다. 이는 반드시 마지막에 위치해야 한다.

```js
// Rest 요소
const [x, ...y] = [1, 2, 3];
console.log(x, y); // 1 [ 2, 3 ]
```

## 36.2 객체 디스트럭처링 할당

객체 디스트럭처링 할당 기준은 프로퍼티 키다. 즉, 순서가 의미가 없고, 프로퍼티 키와 변수 이름이 같으면 할당된다.

```js
const user = { firstName: "Ungmo", lastName: "Lee" };

// ES6 객체 디스트럭처링 할당
// 변수 lastName, firstName을 선언하고 user 객체를 디스트럭처링하여 할당한다.
// 이때 프로퍼티 키를 기준으로 디스트럭처링 할당이 이루어진다. 순서는 의미가 없다.
const { lastName, firstName } = user;

console.log(firstName, lastName); // Ungmo Lee
```

마찬가지로 왼쪽에 프로퍼티 값을 할당받을 변수를 객체 리터럴 형태로 선언한다.

```js
const { lastName, firstName } = { firstName: "Ungmo", lastName: "Lee" };
```

객체의 프로퍼티 키와 다른 이름으로 프로퍼티 값을 할당 받으려면 다음과 같이 변수를 선언한다.

```js
const user = { firstName: "Ungmo", lastName: "Lee" };

// 프로퍼티 키를 기준으로 디스트럭처링 할당이 이루어진다.
// 프로퍼티 키가 lastName인 프로퍼티 값을 ln에 할당하고,
// 프로퍼티 키가 firstName인 프로퍼티 값을 fn에 할당한다.
const { lastName: ln, firstName: fn } = user;

console.log(fn, ln); // Ungmo Lee
```

기본값을 설정할 수 있다.

```js
const { firstName = "Ungmo", lastName } = { lastName: "Lee" };
console.log(firstName, lastName); // Ungmo Lee

const { firstName: fn = "Ungmo", lastName: ln } = { lastName: "Lee" };
console.log(fn, ln); // Ungmo Lee
```

프로퍼티 키로 필요한 프로퍼티 값만 추출하여 변수에 할당하고 싶을 때 유용하다.

```js
const str = "Hello";
// String 래퍼 객체로부터 length 프로퍼티만 추출한다.
const { length } = str;
console.log(length); // 5

const todo = { id: 1, content: "HTML", completed: true };
// todo 객체로부터 id 프로퍼티만 추출한다.
const { id } = todo;
console.log(id); // 1
```

인수로 전달받는 함수의 매개변수에도 사용할 수 있다.

```js
function printTodo(todo) {
	console.log(
		`할일 ${todo.content}은 ${todo.completed ? "완료" : "비완료"} 상태입니다.`
	);
}

printTodo({ id: 1, content: "HTML", completed: true });
// 할일 HTML은 완료 상태입니다.

// 객체 디스트럭처링 사용
function printTodo({ content, completed }) {
	console.log(`할일 ${content}은 ${completed ? "완료" : "비완료"} 상태입니다.`);
}

printTodo({ id: 1, content: "HTML", completed: true });
// 할일 HTML은 완료 상태입니다
```

배열 요소가 객체인 경우 배열 디스트럭처링과 객체 디스트럭처링을 혼용할 수 있다.

```js
const todos = [
	{ id: 1, content: "HTML", completed: true },
	{ id: 2, content: "CSS", completed: false },
	{ id: 3, content: "JS", completed: false },
];

// todos 배열의 두 번째 요소인 객체로부터 id 프로퍼티만 추출한다.
const [, { id }] = todos;
console.log(id); // 2
```

중첩 객체는 다음과 같이 사용한다.

```js
const user = {
	name: "Lee",
	address: {
		zipCode: "03068",
		city: "Seoul",
	},
};

// address 프로퍼티 키로 객체를 추출하고 이 객체의 city 프로퍼티 키로 값을 추출한다.
const {
	address: { city },
} = user;
console.log(city); // 'Seoul'
```

Rest 프로퍼티 사용이 가능하다. 단, 마지막에 위치해야 한다.

```js
// Rest 프로퍼티
const { x, ...rest } = { x: 1, y: 2, z: 3 };
console.log(x, rest); // 1 { y: 2, z: 3 }
```

# 39장 DOM

> DOM은 HTML문서의 계층적 구조와 정보를 표현하며 이를 제어할 수 있는 API, 즉 프로퍼티와 메서드를 제공하는 **트리 자료구조**다.

## 39.1 노드

### 39.1.1 HTML요소와 노드 객체

HTML요소는 렌더링 엔진에 의해 파싱되어 DOM을 구성하는 요소 노드 객체로 변환됨.

- 어트리뷰트(속성) - 어트리뷰트 노드
- 텍스트 콘텐츠 - 텍스트 노드

HTML요소는 중첩 관계에 따라서 부자관계를 가진다. 이러한 관계를 반영해 모든 노드 객체들을 트리자료로 구성한다.

---

**트리 자료구조**

트리 자료구조는 노드들의 **계층관계**로 이뤄진다. 즉, 부모 노드와 자식 노드의 계층적 구조를 표현하는 **비선형 자료구조**이다.

- 하나의 최상위 노드 (= 루트 노드. 부모가 없음)
  - 0개 이상의 자식 노드를 가짐
- 리프 노드 (=자식 노드가 없는 노드)

---

**노드 객체로 구성된 트리 자료구조를 DOM, 혹은 DOM트리라고 부르기도 한다.**

### 39.1.2 노드 객체의 타입

다음을 파싱한다고 생각해보자

```html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<link rel="stylesheet" href="style.css" />
	</head>
	<body>
		<ul>
			<li id="apple">Apple</li>
			<li id="banana">Banana</li>
			<li id="orange">Orange</li>
		</ul>
		<script src="app.js"></script>
	</body>
</html>
```

렌더링 엔진은 이를 파싱하여 DOM을 생성한다. DOM을 이루는 노드의 종류는 총 12개가 있으며, 이 중 중요한 노드 타입은 다음과 같다.

**문서 노드**

- DOM트리의 최상위 노드(=루트 노드). document 객체임.
- HTML 문서 자체를 가리킴.
- window의 document 프로퍼티에 바인딩 되어 있음
- JS코드는 분리되어 있어도 하나의 window객체를 공유함. 따라서 하나의 document객체를 바라봄. 즉, 유일함.
- DOM의 다른 노드에 접근하기 위한 진입점 역할을 한다.

**요소 노드**

- HTML 요소를 가리킴
- 요소의 중첩에 따라 부자 관계를 가지며, 이 관계를 통해 정보를 구조화함
- 요소 노드는 문서의 구조를 표현함

**어트리뷰트(속성) 노드**

- HTML의 어트리뷰트(속성)을 가리킴
- HTML요소와 연결되어 있음
  - HTML요소의 부모 노드와 연결된게 아님. 즉, 요소 노드의 형제 노드는 아님.
  - 따라서 어트리뷰트 노드에 접근하기 위해서는 요소 노드에 먼저 접근해야 함

**텍스트 노드**

- HTML요소의 텍스트를 가리킴
- 문서의 정보를 표현함
- 요소 노드의 자식 노드. 따라서 텍스트 노드에 접근하기 위해선 요소 노드에 먼저 접근해야 함
- 리프 노드. 즉, DOM트리의 최종단.

### 39.1.3 노드 객체의 상속 구조

노드 객체는 자신의 구조와 정보를 제공할 수 있는 API를 사용할 수 있다.
DOM을 구성하는 노드 객체는 호스트 객체이다. 하지만 노드 객체도 자바스크립트 객체이므로 프로토타입에 의한 상속 구조를 가진다.

우선 모든 노드 객체는 Object, EventTarget, Node 인터페이스를 상속받는다.

- 문서 노드 - Document, HTMLDocument 인터페이스
- 어트리뷰트 노드 - Attr 인터페이스
- 텍스트 노드 - CharacterData 인터페이스
- 요소 노드 - Element 인터페이스 + 각 태그별 인터페이스(HTMLUListElement 등)

예를 들어, input 요소를 파싱하여 객체화한 input 요소 노드 객체는 HTMLInpuElement, HTMLElement, Element, Node, EventTarget, Object의 prototype에 바인딩 된 프로토타입 객체를 상속받는다.

```html
<!DOCTYPE html>
<html>
	<body>
		<input type="text" />
		<script>
			// input 요소 노드 객체를 선택
			const $input = document.querySelector("input");

			// input 요소 노드 객체의 프로토타입 체인
			console.log(
				Object.getPrototypeOf($input) === HTMLInputElement.prototype,
				Object.getPrototypeOf(HTMLInputElement.prototype) ===
					HTMLElement.prototype,
				Object.getPrototypeOf(HTMLElement.prototype) === Element.prototype,
				Object.getPrototypeOf(Element.prototype) === Node.prototype,
				Object.getPrototypeOf(Node.prototype) === EventTarget.prototype,
				Object.getPrototypeOf(EventTarget.prototype) === Object.prototype
			); // 모두 true
		</script>
	</body>
</html>
```

input요소 노드 객체는 다양한 특성을 가지는 객체이고, 특성을 나타내는 기능들을 상속을 통해 제공받는다.
|input 요소 노드 객체의 특성|프로토타입을 제공하는 객체|
|--|--|
|객체|Object|
|이벤트를 발생시키는 객체|EventTarget|
|트리 자료구조의 노드 객체|Node|
|브라우저가 렌더링할 수 있는 웹 문서의 요소를 표현하는 객체| Element|
|웹 문서의 요소 중에서 HTML요소를 표현하는 객체|HTMLElement|
|HTML 요소 중에서 input 요소를 표현하는 객체|HTMLInputElement|

이러한 노드 객체의 상속 구조는 개발자 도구의 Elements 패널 우측의 Properties 패널에서 확인 가능하다.

노드 객체는 공통적으로 가지는 기능과, 노드 타입에 따라 고유한 기능이 있다.

---

**공통적인 기능**

모든 노드는 이벤트를 발생시킬 수 있는데, 이벤트와 관련된 기능(addEventListner 기능 등)은 EventTarget 인터페이스가 제공한다.
트리 탐색 기능이나 노드 정보 제공 기능은 Node 인터페이스가 담당한다.
요소 노드가 가지는 공통적인 기능은 HTMLElement 인터페이스가 담당한다.

**요소에 따라 고유한 기능**

필요한 기능을 제공하는 인터페이스는 HTML 요소의 종류에 따라 각각 다르다.

---

공통된 기능일수록 프로토타입 체인의 상위, 개별적인 고유 기능일수록 프로토타입 체인의 하위에 프로토타입 체인을 구축하여 상속 구조를 가진다.

DOM은 HTML 문서의 계층적 구조와 정보를 표현하는 것은 물론 노드 객체의 종류, 즉, 노드 타입에 따라 피룡한 기능을 프로퍼티와 메서드의 집합인 DOM API로 제공한다. 이 DOM API를 통해 HTML 구조나 내용 또는 스타일 등을 동적으로 조작할 수 있다.

즉 중요한 것은 DOM API를 통해 노드에 접근하고, HTML의 구조와 내용, 스타일 등을 동적으로 변경하는 방법을 익히는 것이다.

## 39.2 요소 노트 취득

HTML 구조와 내용, 스타일등을 동적으로 변경하려면, 먼저 **요소 노드를 취득해야한다.** 요소 노드의 취득은 HTML요소를 조작하는 시작점이다.

### 39.2.1 id를 이용한 요소 노드 취득

Document.prototype.getElementById 메서드는 인수로 전달한 id 값을 갖는 하나의 요소 노드를 탐색해 반환한다. Document.prototype의 프로퍼티이므로, 반드시 document 노드를 통해 호출해야한다.

```html
<!DOCTYPE html>
<html>
	<body>
		<ul>
			<li id="apple">Apple</li>
			<li id="banana">Banana</li>
			<li id="orange">Orange</li>
		</ul>
		<script>
			// id 값이 'banana'인 요소 노드를 탐색하여 반환한다.
			// 두 번째 li 요소가 파싱되어 생성된 요소 노드가 반환된다.
			const $elem = document.getElementById("banana");

			// 취득한 요소 노드의 style.color 프로퍼티 값을 변경한다.
			$elem.style.color = "red";
		</script>
	</body>
</html>
```

id값은 문서 내에서 유일한 값이어야 한다. HTML 문서 내에서 id가 여러개 중복되더라도 오류를 내지 않는다는 점에 주의하자. 이때는 해당 id값을 가지는 첫번째 요소를 반환한다. **getElementById**는 언제나 단 하나의 요소 노드를 반환한다.

```html
<!DOCTYPE html>
<html>
	<body>
		<ul>
			<li id="banana">Apple</li>
			<li id="banana">Banana</li>
			<li id="banana">Orange</li>
		</ul>
		<script>
			// getElementById 메서드는 언제나 단 하나의 요소 노드를 반환한다.
			// 첫 번째 li 요소가 파싱되어 생성된 요소 노드가 반환된다.
			const $elem = document.getElementById("banana");

			// 취득한 요소 노드의 style.color 프로퍼티 값을 변경한다.
			$elem.style.color = "red";
		</script>
	</body>
</html>
```

해당 id값을 가지는 HTML 요소가 존재하지 않는 경우 null을 반환한다.

```html
<!DOCTYPE html>
<html>
	<body>
		<ul>
			<li id="apple">Apple</li>
			<li id="banana">Banana</li>
			<li id="orange">Orange</li>
		</ul>
		<script>
			// id 값이 'grape'인 요소 노드를 탐색하여 반환한다. null이 반환된다.
			const $elem = document.getElementById("grape");

			// 취득한 요소 노드의 style.color 프로퍼티 값을 변경한다.
			$elem.style.color = "red";
			// -> TypeError: Cannot read property 'style' of null
		</script>
	</body>
</html>
```

HTML요소에 id 속성을 부여하면, id값과 동일한 이름의 전역 변수가 암묵적으로 선언되고 해당 노드 객체가 할당되는 효과기 있다.

```html
<!DOCTYPE html>
<html>
	<body>
		<div id="foo"></div>
		<script>
			// id 값과 동일한 이름의 전역 변수가 암묵적으로 선언되고 해당 노드 객체가 할당된다.
			console.log(foo === document.getElementById("foo")); // true

			// 암묵적 전역으로 생성된 전역 프로퍼티는 삭제되지만 전역 변수는 삭제되지 않는다.
			delete foo;
			console.log(foo); // <div id="foo"></div>
		</script>
	</body>
</html>
```

하지만 id값과 동일한 이름의 전역 변수가 선언되어 있으면 이 전역 변수에 노드 객체가 재할당되지 않는다.

```html
<!DOCTYPE html>
<html>
	<body>
		<div id="foo"></div>
		<script>
			let foo = 1;

			// id 값과 동일한 이름의 전역 변수가 이미 선언되어 있으면 노드 객체가 재할당되지 않는다.
			console.log(foo); // 1
		</script>
	</body>
</html>
```

### 39.2.2 태그 이름을 이용한 요소 노드 취득

Document.prototype/Element.prototype.getElementsByTagName 메서드는 인수로 전달한 태그 이름을 가지는 모든 요소 노드들을 탐색하여 반환한다. 이 메서드는 여러 요소 노드 객체를 가지는 DOM 컬랙션 객체인 HTMLCollection 객체를 반환한다.

```html
<!DOCTYPE html>
<html>
	<body>
		<ul>
			<li id="apple">Apple</li>
			<li id="banana">Banana</li>
			<li id="orange">Orange</li>
		</ul>
		<script>
			// 태그 이름이 li인 요소 노드를 모두 탐색하여 반환한다.
			// 탐색된 요소 노드들은 HTMLCollection 객체에 담겨 반환된다.
			// HTMLCollection 객체는 유사 배열 객체이면서 이터러블이다.
			const $elems = document.getElementsByTagName("li");

			// 취득한 모든 요소 노드의 style.color 프로퍼티 값을 변경한다.
			// HTMLCollection 객체를 배열로 변환하여 순회하며 color 프로퍼티 값을 변경한다.
			[...$elems].forEach(elem => {
				elem.style.color = "red";
			});
		</script>
	</body>
</html>
```

함수의 하나의 값만 반환할 수 있으므로, 여러개의 값을 반환하려면 객체 혹은 배열같은 자료구조에 담아야 한다. HTMLCollection 객체는 유사 배열 객체이면서 이터러블이다.

HTML 문서의 모든 요소 노드를 취득하려면 \* 를 인수로 전달한다.

```js
// 모든 요소 노드를 탐색하여 반환한다.
const $all = document.getElementsByTagName("*");
// -> HTMLCollection(8) [html, head, body, ul, li#apple, li#banana, li#orange, script, apple: li#apple, banana: li#banana, orange: li#orange]
```

getElementsByTagName 메서드는 Document.prototype과 Element.prototype에 정의된 메서드가 있다.

- Document.prototype.getElementsByTagName - document를 통해 호출하며 DOM 전체에서 요소 노드를 탐색해 반환.
- Element.prototype.getElementsByTagName - 특정 요소 노드를 통해 호출, 해당 요소 노드의 자손 노드 중에서 요소 노드를 탐색하여 반환

```html
<!DOCTYPE html>
<html>
	<body>
		<ul id="fruits">
			<li>Apple</li>
			<li>Banana</li>
			<li>Orange</li>
		</ul>
		<ul>
			<li>HTML</li>
		</ul>
		<script>
			// DOM 전체에서 태그 이름이 li인 요소 노드를 모두 탐색하여 반환한다.
			const $lisFromDocument = document.getElementsByTagName("li");
			console.log($lisFromDocument); // HTMLCollection(4) [li, li, li, li]

			// #fruits 요소의 자손 노드 중에서 태그 이름이 li인 요소 노드를 모두
			// 탐색하여 반환한다.
			const $fruits = document.getElementById("fruits");
			const $lisFromFruits = $fruits.getElementsByTagName("li");
			console.log($lisFromFruits); // HTMLCollection(3) [li, li, li]
		</script>
	</body>
</html>
```

만약 해당 태그 이름을 가지는 요소가 없을 경우 빈 HTMLCollection 객체를 반환한다.

### 39.2.3 class 를 통해 요소 노드 취득

Document.prototype/Element.prototype.getElementsByClassName 메서드는 인수로 전달한 class 어트리뷰트 값을 갖는 모든 요소 노드들을 탐색하여 반환한다. 공백으로 구분해 여러 개의 class를 지정할 수 있다. 이 메서드 또한 HTMLCollection 객체를 반환한다.

```html
<!DOCTYPE html>
<html>
	<body>
		<ul>
			<li class="fruit apple">Apple</li>
			<li class="fruit banana">Banana</li>
			<li class="fruit orange">Orange</li>
		</ul>
		<script>
			// class 값이 'fruit'인 요소 노드를 모두 탐색하여 HTMLCollection 객체에 담아 반환한다.
			const $elems = document.getElementsByClassName("fruit");

			// 취득한 모든 요소의 CSS color 프로퍼티 값을 변경한다.
			[...$elems].forEach(elem => {
				elem.style.color = "red";
			});

			// class 값이 'fruit apple'인 요소 노드를 모두 탐색하여 HTMLCollection 객체에 담아 반환한다.
			const $apples = document.getElementsByClassName("fruit apple");

			// 취득한 모든 요소 노드의 style.color 프로퍼티 값을 변경한다.
			[...$apples].forEach(elem => {
				elem.style.color = "blue";
			});
		</script>
	</body>
</html>
```

getElementsByClassName 메서드는 Document.prototype과 Element.prototype에 정의된 메서드가 있다.

- Document.prototype.getElementsByClassName - document를 통해 호출하며 DOM 전체에서 요소 노드를 탐색해 반환.
- Element.prototype.getElementsByClassName - 특정 요소 노드를 통해 호출, 해당 요소 노드의 자손 노드 중에서 요소 노드를 탐색하여 반환

```html
<!DOCTYPE html>
<html>
	<body>
		<ul id="fruits">
			<li class="apple">Apple</li>
			<li class="banana">Banana</li>
			<li class="orange">Orange</li>
		</ul>
		<div class="banana">Banana</div>
		<script>
			// DOM 전체에서 class 값이 'banana'인 요소 노드를 모두 탐색하여 반환한다.
			const $bananasFromDocument = document.getElementsByClassName("banana");
			console.log($bananasFromDocument); // HTMLCollection(2) [li.banana, div.banana]

			// #fruits 요소의 자손 노드 중에서 class 값이 'banana'인 요소 노드를 모두 탐색하여 반환한다.
			const $fruits = document.getElementById("fruits");
			const $bananasFromFruits = $fruits.getElementsByClassName("banana");

			console.log($bananasFromFruits); // HTMLCollection [li.banana]
		</script>
	</body>
</html>
```

만약 해당 클래스를 가지는 요소가 없을 경우 빈 HTMLCollection 객체를 반환한다.

### 39.2.4 CSS 선택자를 이용한 요소 취득

CSS 선택자는 스타일을 적용하고자 하는 HTML 요소를 특정할 때 사용하는 문법이다.

```js
/* 전체 선택자: 모든 요소를 선택 */
* { ... }
/* 태그 선택자: 모든 p 태그 요소를 모두 선택 */
p { ... }
/* id 선택자: id 값이 'foo'인 요소를 모두 선택 */
#foo { ... }
/* class 선택자: class 값이 'foo'인 요소를 모두 선택 */
.foo { ... }
/* 어트리뷰트 선택자: input 요소 중에 type 어트리뷰트 값이 'text'인 요소를 모두 선택 */
input[type=text] { ... }
/* 후손 선택자: div 요소의 후손 요소 중 p 요소를 모두 선택 */
div p { ... }
/* 자식 선택자: div 요소의 자식 요소 중 p 요소를 모두 선택 */
div > p { ... }
/* 인접 형제 선택자: p 요소의 형제 요소 중에 p 요소 바로 뒤에 위치하는 ul 요소를 선택 */
p + ul { ... }
/* 일반 형제 선택자: p 요소의 형제 요소 중에 p 요소 뒤에 위치하는 ul 요소를 모두 선택 */
p ~ ul { ... }
/* 가상 클래스 선택자: hover 상태인 a 요소를 모두 선택 */
a:hover { ... }
/* 가상 요소 선택자: p 요소의 콘텐츠의 앞에 위치하는 공간을 선택
   일반적으로 content 프로퍼티와 함께 사용된다. */
p::before { ... }
```

Document.prototype/Element.prototype.querySelector 는 인수로 전달한 CSS 선택자를 만족시키는 하나의 요소 노드를 탐색하여 반환한다.

- CSS 선택자를 만족시키는 요소가 여러개면 첫번째 요소 노드만 반환한다.
- CSS 선택자를 만족시키는 요소가 존재하지 않으면 null을 반환한다.
- CSS 선택자가 문법에 맞지 않으면 DOMException 에러가 발생한다.

```html
<!DOCTYPE html>
<html>
	<body>
		<ul>
			<li class="apple">Apple</li>
			<li class="banana">Banana</li>
			<li class="orange">Orange</li>
		</ul>
		<script>
			// class 어트리뷰트 값이 'banana'인 첫 번째 요소 노드를 탐색하여 반환한다.
			const $elem = document.querySelector(".banana");

			// 취득한 요소 노드의 style.color 프로퍼티 값을 변경한다.
			$elem.style.color = "red";
		</script>
	</body>
</html>
```

Document.prototype/Element.prototype.querySelectorAll 메서드는 인수로 전달한 CSS 선택자를 만족하는 모든 요소 노드를 탐색하여 반환한다. 이 메서드는 여러 노드 객체를 가지는 DOM 컬렉션 객체인 NodeList 객체를 반환한다. NodeList 객체는 유사 배열 객체이면서 이터러블이다.

- CSS 선택자를 만족시키는 요소가 없으면 빈 NodeList 객체를 반환
- CSS 선택자가 문법에 맞지 않으면 DOMException 에러가 발생한다.

모든 요소 노드를 취득하려면 querySelectorAll 메서드의 인수로 \* 를 전달한다.

querySelector, querySelectorAll 메서드는 Document.prototype과 Element.prototype에 정의된 메서드가 있다.

- Document.prototype - document를 통해 호출하며 DOM 전체에서 요소 노드를 탐색해 반환.
- Element.prototype - 특정 요소 노드를 통해 호출, 해당 요소 노드의 자손 노드 중에서 요소 노드를 탐색하여 반환

---

일반적으로 querySelector, querySelectorAll 메서드는 getElementBy~, 메서드보다 다소 느린 것으로 알려져 있다. 하지만 **CSS 선택자 문법을 사용해 좀 더 구체적인 조건으로 요소 노드를 취득하고, 일관된 방식으로 요소 노드를 취득할 수 있는 장점**이 있다.
따라서 id 속성이 있는 요소 노드를 취득하는 경우엔 getElementById 메서드를 사용하고, 그 외에는 querySelector, querySelectorAll 메서드를 사용하는 것을 권장한다.

---

### 39.2.5 특정 요소 노드를 취득할 수 있는지 확인ㄷ

Element.prototype.matches 메서드는 CSS 선택자를 통해 특정 요소 노드를 취득할 수 있는지 확인한다.

```html
<!DOCTYPE html>
<html>
	<body>
		<ul id="fruits">
			<li class="apple">Apple</li>
			<li class="banana">Banana</li>
			<li class="orange">Orange</li>
		</ul>
	</body>
	<script>
		const $apple = document.querySelector(".apple");

		// $apple 노드는 '#fruits > li.apple'로 취득할 수 있다.
		console.log($apple.matches("#fruits > li.apple")); // true

		// $apple 노드는 '#fruits > li.banana'로 취득할 수 없다.
		console.log($apple.matches("#fruits > li.banana")); // false
	</script>
</html>
```

이 메서드는 이벤트 위임을 사용할 때 매우 유용하다.

### 39.2.6 HTMLCollection 과 NodeList

HTMLCollection 과 NodeList 모두 여러개의 결과값을 반환하기 위한 DOM 컬렉션 객체이다. 모두 유사 배열 객체이면서 이터러블이기 때문에 **for..of 문으로 순회하거나 스프레드 문법을 사용해 간단히 배열로 변환할 수 있다.**

HTMLCollection 객체는 노드 객체를 실시간으로 반영하는 살아있는 객체라는 것이다. 즉, 언제나 실시간 정보를 반영해 작동한다. NodeList의 경우, 상태 변화를 실시간으로 반영하지 않지만, 경우에 따라 실시간으로 반영할 때가 있다.

---

**HTMLCollection**

HTMLCollection 객체는 노드 객체의 상태변화를 실시간으로 반영한다.

```html
<!DOCTYPE html>
<head>
	<style>
		.red {
			color: red;
		}
		.blue {
			color: blue;
		}
	</style>
</head>
<html>
	<body>
		<ul id="fruits">
			<li class="red">Apple</li>
			<li class="red">Banana</li>
			<li class="red">Orange</li>
		</ul>
		<script>
			// class 값이 'red'인 요소 노드를 모두 탐색하여 HTMLCollection 객체에 담아 반환한다.
			const $elems = document.getElementsByClassName("red");
			// 이 시점에 HTMLCollection 객체에는 3개의 요소 노드가 담겨 있다.
			console.log($elems); // HTMLCollection(3) [li.red, li.red, li.red]

			// HTMLCollection 객체의 모든 요소의 class 값을 'blue'로 변경한다.
			for (let i = 0; i < $elems.length; i++) {
				$elems[i].className = "blue";
			}

			// HTMLCollection 객체의 요소가 3개에서 1개로 변경되었다.
			console.log($elems); // HTMLCollection(1) [li.red]
		</script>
	</body>
</html>
```

코드의 의도는 모든 li요소의 글자색을 파란색으로 바꾸는 것이다. 하지만 실제로는 두번째 요소는 여전히 빨간색을 유지한다. 이는 HTMLCollection이 실시간 정보를 반영하기 때문이다. 즉, 첫번째 반복에서 class를 blue로 바꿨기에, HTMLCollection의 길이는 줄어들고, 두번째 반복에서 마지막 요소의 class를 blue를 바꾸고 반복문이 종료된다.

이러한 현상은 for문을 역방향으로 순회하거나, while문을 사용하는 방법으로 해결할 수 있다. 가장 간단한 해결책은 HTMLCollection객체를 사용하지 않는 것이다. 이를 배열로 변환하면 이러한 부작용들을 피하고, 배열의 고차함수들을 사용할 수 있다.

```js
// for 문을 역방향으로 순회
for (let i = $elems.length - 1; i >= 0; i--) {
	$elems[i].className = "blue";
}

// while 문으로 HTMLCollection에 요소가 남아 있지 않을 때까지 무한 반복
let i = 0;
while ($elems.length > i) {
	$elems[i].className = "blue";
}

// 유사 배열 객체이면서 이터러블인 HTMLCollection을 배열로 변환하여 순회
[...$elems].forEach(elem => (elem.className = "blue"));
```

**NodeList**

HTMLCollection의 부작용을 해결하기 위해 querySelectorAll 메서드를 사용하는 방법도 있다. 이는 NodeList객체를 반환한다.

```js
// querySelectorAll은 DOM 컬렉션 객체인 NodeList를 반환한다.
const $elems = document.querySelectorAll(".red");

// NodeList 객체는 NodeList.prototype.forEach 메서드를 상속받아 사용할 수 있다.
$elems.forEach(elem => (elem.className = "blue"));
```

NodeList객체는 NodeList.prototype.forEach 메서드를 상속받아 사용할 수 있다. 이 외에도 item, entries, keys, values 메서드를 제공한다.

NodeList 객체는 정적 상태를 유지하나, childNodes 프로퍼티가 반환하는 NodeList 객체는 live 객체로 작동하므로 주의한다.

```html
<!DOCTYPE html>
<html>
	<body>
		<ul id="fruits">
			<li>Apple</li>
			<li>Banana</li>
		</ul>
	</body>
	<script>
		const $fruits = document.getElementById("fruits");

		// childNodes 프로퍼티는 NodeList 객체(live)를 반환한다.
		const { childNodes } = $fruits;
		console.log(childNodes instanceof NodeList); // true

		// $fruits 요소의 자식 노드는 공백 텍스트 노드(39.3.1절 "공백 텍스트 노드" 참고)를 포함해 모두 5개다.
		console.log(childNodes); // NodeList(5) [text, li, text, li, text]

		for (let i = 0; i < childNodes.length; i++) {
			// removeChild 메서드는 $fruits 요소의 자식 노드를 DOM에서 삭제한다.
			// (39.6.9절 "노드 삭제" 참고)
			// removeChild 메서드가 호출될 때마다 NodeList 객체인 childNodes가 실시간으로 변경된다.
			// 따라서 첫 번째, 세 번째 다섯 번째 요소만 삭제된다.
			$fruits.removeChild(childNodes[i]);
		}

		// 예상과 다르게 $fruits 요소의 모든 자식 노드가 삭제되지 않는다.
		console.log(childNodes); // NodeList(2) [li, li]
	</script>
</html>
```

따라서 노드 객체의 상태 변경과 상관없이 안전하게 DOM 컬렉션을 사용하려면 HTMLCollection이나 NodeList 모두 배열로 변환하여 사용하는 것을 권장한다. 둘 모두 유사 배열 객체이며 이터러블이므로 스프레드 문법이나 Array.from 메서드를 사용해 간단히 배열로 변경할 수 있다.

```html
<!DOCTYPE html>
<html>
	<body>
		<ul id="fruits">
			<li>Apple</li>
			<li>Banana</li>
		</ul>
	</body>
	<script>
		const $fruits = document.getElementById("fruits");

		// childNodes 프로퍼티는 NodeList 객체(live)를 반환한다.
		const { childNodes } = $fruits;

		// 스프레드 문법을 사용하여 NodeList 객체를 배열로 변환한다.
		[...childNodes].forEach(childNode => {
			$fruits.removeChild(childNode);
		});

		// $fruits 요소의 모든 자식 노드가 모두 삭제되었다.
		console.log(childNodes); // NodeList []
	</script>
</html>
```

## 39.3 노드 탐색

요소 노드를 취득 후, 이를 기점으로 부모, 형제 자식 노드를 탐색해야 할 때가 있다.

```html
<ul id="fruits">
	<li class="apple">Apple</li>
	<li class="banana">Banana</li>
	<li class="orange">Orange</li>
</ul>
```

위에서는 ul#fruits 를 취득 후 자식 노드를 탐색할 수 있고, li#banana를 취득해 형제 노드 혹은 부모 노드를 탐색할 수 있다.

이러한 탐색을 위해 Node, Element 인터페이스는 트리 탐색 프로퍼티를 제공한다.

- Node.prototype : parentNode, previousSibling, firstChild, childNodes
- Element.prototype : previousElementSibling, nextElementSibling, children

노드 탐색 프로퍼티는 모두 읽기 전용 접근자 프로퍼티이다. 따라서 여기에 값을 할당하면 에러 없이 무시된다.

### 39.3.1 공백 텍스트 노드

HTML 요소 사이의 스페이스 ,탭, 개행 등의 공백 문자는 텍스트 노드를 생성한다. 이를 공백 텍스트 노드라고 한다.

```html
<!DOCTYPE html>
<html>
	<body>
		<ul id="fruits">
			<li class="apple">Apple</li>
			<li class="banana">Banana</li>
			<li class="orange">Orange</li>
		</ul>
	</body>
</html>
```

에디터에서 HTML 문서에 스페이스, 탭, 엔터를 입력하면 공백 문자가 추가된다. 이러한 공백 문자는 공백 텍스트 노드를 생성한다.

### 39.3.2 자식 노드 탐색

다음과 같은 탐색 프로퍼티를 사용한다.
|프로퍼티|설명|
|--|--|
|Node.prototype.childNodes|자식 노드를 **모두** 탐색해 NodeList 에 담아 반환한다. 여기엔 **텍스트 노드가 포함될 수 있다.**|
|Element.prototype.children| 자식 노드 중 **요소 노드만** 탐색해 HTMLCollection에 담아 반환한다. 여기엔 **텍스트 노드가 포함될 수 없다.**|
||Node.prototype.firstChild|첫번쨰 자식 노드를 반환한다. **텍스트 노드이거나 요소 노드이다.**|
||Node.prototype.lastChild|마지막 자식 노드를 반환한다. **텍스트 노드이거나 요소 노드이다.**|
|Element.prototype.firstElementChild|첫번째 자식 노드를 반환한다. **요소 노드만 반환한다.**|
|Element.prototype.lastElementChild|마지막 자식 노드를 반환한다. **요소 노드만 반환한다.**|

```html
<!DOCTYPE html>
<html>
	<body>
		<ul id="fruits">
			<li class="apple">Apple</li>
			<li class="banana">Banana</li>
			<li class="orange">Orange</li>
		</ul>
	</body>
	<script>
		// 노드 탐색의 기점이 되는 #fruits 요소 노드를 취득한다.
		const $fruits = document.getElementById("fruits");

		// #fruits 요소의 모든 자식 노드를 탐색한다.
		// childNodes 프로퍼티가 반환한 NodeList에는 요소 노드뿐만 아니라 텍스트 노드도 포함되어 있다.
		console.log($fruits.childNodes);
		// NodeList(7) [text, li.apple, text, li.banana, text, li.orange, text]

		// #fruits 요소의 모든 자식 노드를 탐색한다.
		// children 프로퍼티가 반환한 HTMLCollection에는 요소 노드만 포함되어 있다.
		console.log($fruits.children);
		// HTMLCollection(3) [li.apple, li.banana, li.orange]

		// #fruits 요소의 첫 번째 자식 노드를 탐색한다.
		// firstChild 프로퍼티는 텍스트 노드를 반환할 수도 있다.
		console.log($fruits.firstChild); // #text

		// #fruits 요소의 마지막 자식 노드를 탐색한다.
		// lastChild 프로퍼티는 텍스트 노드를 반환할 수도 있다.
		console.log($fruits.lastChild); // #text

		// #fruits 요소의 첫 번째 자식 노드를 탐색한다.
		// firstElementChild 프로퍼티는 요소 노드만 반환한다.
		console.log($fruits.firstElementChild); // li.apple

		// #fruits 요소의 마지막 자식 노드를 탐색한다.
		// lastElementChild 프로퍼티는 요소 노드만 반환한다.
		console.log($fruits.lastElementChild); // li.orange
	</script>
</html>
```

### 39.3.3 자식 노드 존재 확인

이를 위해선 Node.prototype.hasChildNodes 메서드를 사용한다. 존재하면 true, 아니면 false를 반환한다. 마찬가지로 텍스트 노드를 포함해 확인한다.

```html
<!DOCTYPE html>
<html>
	<body>
		<ul id="fruits"></ul>
	</body>
	<script>
		// 노드 탐색의 기점이 되는 #fruits 요소 노드를 취득한다.
		const $fruits = document.getElementById("fruits");

		// #fruits 요소에 자식 노드가 존재하는지 확인한다.
		// hasChildNodes 메서드는 텍스트 노드를 포함하여 자식 노드의 존재를 확인한다.
		console.log($fruits.hasChildNodes()); // true
	</script>
</html>
```

자식 중 텍스트 노드가 아닌 요소 노드가 있는지 확인하려면 children.length 또는 Element의 childElementCount 프로퍼티를 사용한다.

```html
<!DOCTYPE html>
<html>
	<body>
		<ul id="fruits"></ul>
	</body>
	<script>
		// 노드 탐색의 기점이 되는 #fruits 요소 노드를 취득한다.
		const $fruits = document.getElementById("fruits");

		// hasChildNodes 메서드는 텍스트 노드를 포함하여 자식 노드의 존재를 확인한다.
		console.log($fruits.hasChildNodes()); // true

		// 자식 노드 중에 텍스트 노드가 아닌 요소 노드가 존재하는지는 확인한다.
		console.log(!!$fruits.children.length); // 0 -> false
		// 자식 노드 중에 텍스트 노드가 아닌 요소 노드가 존재하는지는 확인한다.
		console.log(!!$fruits.childElementCount); // 0 -> false
	</script>
</html>
```

### 39.3.4 요소 노드의 텍스트 노드 탐색

요소 노드의 텍스트 노드는 요소 노드의 자식 노드다. 이는 firstChild 프로퍼티로 접근할 수 있다. 이 프로퍼티가 반환한 노드는 텍스트 노드이거나 요소 노드이다.

```html
<!DOCTYPE html>
<html>
	<body>
		<div id="foo">Hello</div>
		<script>
			// 요소 노드의 텍스트 노드는 firstChild 프로퍼티로 접근할 수 있다.
			console.log(document.getElementById("foo").firstChild); // #text
		</script>
	</body>
</html>
```

### 39.3.5 부모 노드 탐색

부모 노드를 탐색하려면 Node.prototype.parentNode 프로퍼티를 사용한다. 부모 노드가 텍스트 노드인 경우는 없다.

```html
<!DOCTYPE html>
<html>
	<body>
		<ul id="fruits">
			<li class="apple">Apple</li>
			<li class="banana">Banana</li>
			<li class="orange">Orange</li>
		</ul>
	</body>
	<script>
		// 노드 탐색의 기점이 되는 .banana 요소 노드를 취득한다.
		const $banana = document.querySelector(".banana");

		// .banana 요소 노드의 부모 노드를 탐색한다.
		console.log($banana.parentNode); // ul#fruits
	</script>
</html>
```

### 39.3.6 형제 노드 탐색

다음과 같은 탐색 프로퍼티를 사용한다. 단, 어트리뷰트 노드는 형제 노드가 아니므로 반환되지 않는다. 즉, 텍스트 혹은 요소 노드만 반환한다.
|프로퍼티|설명|
|--|--|
|Node.prototype.previousSibling|자신의 이전 형제 노드를 탐색하여 반환한다. **요소 노드거나, 텍스트 노드이다.**|
|Node.prototype.nextSibling|자신의 다음 형제 노드를 탐색해 반환한다. **요소 노드거나, 텍스트 노드이다.**|
|Element.prototype.previousElementSibling|이전 형제 요소노드를 탐색하여 반환한다. **오로지 요소 노드를 반환한다.**|
|Element.prototype.nextElementSibling|다음 형제 요소 노드를 탐색해 반환한다. **오로지 요소 노드를 반환한다.**|

```html
<!DOCTYPE html>
<html>
	<body>
		<ul id="fruits">
			<li class="apple">Apple</li>
			<li class="banana">Banana</li>
			<li class="orange">Orange</li>
		</ul>
	</body>
	<script>
		// 노드 탐색의 기점이 되는 #fruits 요소 노드를 취득한다.
		const $fruits = document.getElementById("fruits");

		// #fruits 요소의 첫 번째 자식 노드를 탐색한다.
		// firstChild 프로퍼티는 요소 노드뿐만 아니라 텍스트 노드를 반환할 수도 있다.
		const { firstChild } = $fruits;
		console.log(firstChild); // #text

		// #fruits 요소의 첫 번째 자식 노드(텍스트 노드)의 다음 형제 노드를 탐색한다.
		// nextSibling 프로퍼티는 요소 노드뿐만 아니라 텍스트 노드를 반환할 수도 있다.
		const { nextSibling } = firstChild;
		console.log(nextSibling); // li.apple

		// li.apple 요소의 이전 형제 노드를 탐색한다.
		// previousSibling 프로퍼티는 요소 노드뿐만 아니라 텍스트 노드를 반환할 수도 있다.
		const { previousSibling } = nextSibling;
		console.log(previousSibling); // #text

		// #fruits 요소의 첫 번째 자식 요소 노드를 탐색한다.
		// firstElementChild 프로퍼티는 요소 노드만 반환한다.
		const { firstElementChild } = $fruits;
		console.log(firstElementChild); // li.apple

		// #fruits 요소의 첫 번째 자식 요소 노드(li.apple)의 다음 형제 노드를 탐색한다.
		// nextElementSibling 프로퍼티는 요소 노드만 반환한다.
		const { nextElementSibling } = firstElementChild;
		console.log(nextElementSibling); // li.banana

		// li.banana 요소의 이전 형제 요소 노드를 탐색한다.
		// previousElementSibling 프로퍼티는 요소 노드만 반환한다.
		const { previousElementSibling } = nextElementSibling;
		console.log(previousElementSibling); // li.apple
	</script>
</html>
```

## 39.4 노드 정보 취득

다음과 같은 노드 정보 프로퍼티를 사용한다.
|프로퍼티|설명|
|--|--|
|Node.prototype.nodeType|노드 타입을 나타내는 상수를 반환한다. 요소 노드는 1, 텍스트 노드는 3, 문서 노드는 9를 반환한다.|
|Node.prototype.nodeName|요소 노드: 태그 이름("LI" 등)을 반환. 텍스트 노드 "#text" 문자열을 반환. 문서 노드 "#document" 문자열을 반환.|

```html
<!DOCTYPE html>
<html>
	<body>
		<div id="foo">Hello</div>
	</body>
	<script>
		// 문서 노드의 노드 정보를 취득한다.
		console.log(document.nodeType); // 9
		console.log(document.nodeName); // #document

		// 요소 노드의 노드 정보를 취득한다.
		const $foo = document.getElementById("foo");
		console.log($foo.nodeType); // 1
		console.log($foo.nodeName); // DIV

		// 텍스트 노드의 노드 정보를 취득한다.
		const $textNode = $foo.firstChild;
		console.log($textNode.nodeType); // 3
		console.log($textNode.nodeName); // #text
	</script>
</html>
```

## 39.5 요소 노드의 텍스트 조작

### 39.5.1 nodeValue

nodeValue 프로퍼티는 참조와 할당 둘 다 가능하다. 노드 객체의 nodeValue 프로퍼티를 참조하면 노드 객체의 값을 반환한다. 이는 즉 텍스트 노드의 텍스트이다. 따라서 문서 혹은 요소 노드의 nodeValue 프로퍼티를 참조하면 null을 반환한다.

```html
<!DOCTYPE html>
<html>
	<body>
		<div id="foo">Hello</div>
	</body>
	<script>
		// 문서 노드의 nodeValue 프로퍼티를 참조한다.
		console.log(document.nodeValue); // null

		// 요소 노드의 nodeValue 프로퍼티를 참조한다.
		const $foo = document.getElementById("foo");
		console.log($foo.nodeValue); // null

		// 텍스트 노드의 nodeValue 프로퍼티를 참조한다.
		const $textNode = $foo.firstChild;
		console.log($textNode.nodeValue); // Hello
	</script>
</html>
```

따라서 요소 노드의 텍스트를 변경하려면 다음과 같은 순서 처리가 필요하다.

1. 텍스트를 변경할 요소 노드를 취득해 해당 요소 노드의 텍스트 노드를 탐색한다.
2. 탐색한 텍스트 노드의 nodeValue 프로퍼티를 사용해 값을 변경한다.

```html
<!DOCTYPE html>
<html>
	<body>
		<div id="foo">Hello</div>
	</body>
	<script>
		// 1. #foo 요소 노드의 자식 노드인 텍스트 노드를 취득한다.
		const $textNode = document.getElementById("foo").firstChild;

		// 2. nodeValue 프로퍼티를 사용하여 텍스트 노드의 값을 변경한다.
		$textNode.nodeValue = "World";

		console.log($textNode.nodeValue); // World
	</script>
</html>
```

### 39.5.2 textContent

이는 setter와 getter 모두 존재하는 접근자 프로퍼티로, 요소 노다의 텍스트와 모든 자손 노드의 텍스트를 모두 취득하거나 변경한다.
이 프로퍼티를 참조하면 요소 노드의 콘텐츠 영역(시작 태그와 종료 태그 사이) 내의 텍스트를 모두 반환한다. 다시 말해, 요소 노드의 childNodes 프로퍼티가 반환한 모든 노드들의 텍스트 노드의 값을 모두 반환한다. 이떄, HTML마크업은 무시된다.

```html
<!DOCTYPE html>
<html>
	<body>
		<div id="foo">Hello <span>world!</span></div>
	</body>
	<script>
		// #foo 요소 노드의 텍스트를 모두 취득한다. 이때 HTML 마크업은 무시된다.
		console.log(document.getElementById("foo").textContent); // Hello world!
	</script>
</html>
```

nodeValue를 사용하면 textContent를 사용할 떄와 비교해 더 복잡하다.

```html
<!DOCTYPE html>
<html>
	<body>
		<div id="foo">Hello <span>world!</span></div>
	</body>
	<script>
		// #foo 요소 노드는 텍스트 노드가 아니다.
		console.log(document.getElementById("foo").nodeValue); // null
		// #foo 요소 노드의 자식 노드인 텍스트 노드의 값을 취득한다.
		console.log(document.getElementById("foo").firstChild.nodeValue); // Hello
		// span 요소 노드의 자식 노드인 텍스트 노드의 값을 취득한다.
		console.log(document.getElementById("foo").lastChild.firstChild.nodeValue); // world!
	</script>
</html>
```

만약 콘텐츠 영역에 자식 요소 노드가 없고 텍스트만 존재하면 firstChild.nodeValue와 textContent는 같은 결과를 반환한다. 이때 textContent를 사용하면 더 간결하게 코드를 작성할 수 있다.

```html
<!DOCTYPE html>
<html>
	<body>
		<!-- 요소 노드의 콘텐츠 영역에 다른 요소 노드가 없고 텍스트만 존재 -->
		<div id="foo">Hello</div>
	</body>
	<script>
		const $foo = document.getElementById("foo");

		// 요소 노드의 콘텐츠 영역에 자식 요소 노드가 없고 텍스트만 존재한다면
		// firstChild.nodeValue와 textContent는 같은 결과를 반환한다.
		console.log($foo.textContent === $foo.firstChild.nodeValue); // true
	</script>
</html>
```

요소 노드의 textContent 프로퍼티에 문자열을 할당하면 요소 노드의 모든 자식 노드가 제거되고 할당한 문자열이 텍스트로 추가된다. 이때 문자열에 HTML 마크업이 포함되어 있더라도 문자열 그대로 인식되어 텍스트로 취급된다. 즉, HTML 마크업이 파싱되지 않는다.

```html
<!DOCTYPE html>
<html>
	<body>
		<div id="foo">Hello <span>world!</span></div>
	</body>
	<script>
		// #foo 요소 노드의 모든 자식 노드가 제거되고 할당한 문자열이 텍스트로 추가된다.
		// 이때 HTML 마크업이 파싱되지 않는다.
		document.getElementById("foo").textContent = "Hi <span>there!</span>";
	</script>
</html>
```

같은 동작을 하는 innerText 프로퍼티가 있다. 이는 다음과 같은 이유로 사용하지 않는 것이 좋다.

- CSS에 순종적이다. CSS에 의해 비표시되고 있다면 해당 요소의 텍스트를 반환하지 않는다.
- CSS를 고려해야 하므로 textContent 프로퍼티보다 느리다.

# 40장 이벤트

## 40.1 이벤트 드리븐 프로그래밍

- 브라우저는 특정 사건이 발생하면 이를 감지해 이벤트를 발생 시킴
- 애플리케이션이 어떤 특정 이벤트에 반응하여 어떤 일을 하고 싶으면 브라우저에게 그 사건을 알려 호출을 위임함
- 호출될 함수: 이벤트 핸들러
- 브라우저에게 이벤트 헨들러의 호출을 위임하는 것: 이벤트 핸들러 등록

이때, 개발자가 명시적으로 함수를 호출하는 것이 아니라, 브라우저에게 함수 호출을 위임함.

이처럼, 이벤트와 이벤트 핸들러를 통해 애플리케이션은 상호작용을 함.

- 이벤트 드리븐 프로그래밍: 프로그램의 흐름을 이벤트 중심으로 제어하는 프로그램 방식

## 40.3 이벤트 핸들러 등록

이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을 이벤트 핸들러 등록이라고 한다. 방법에는 3가지가 있다.

### 40.3.1 이벤트 핸들러 어트리뷰트 방식

```js
<!DOCTYPE html>
<html>
<body>
 <button onclick="sayHi('Lee')">Click me!</button>
 <script>
   function sayHi(name) {
     console.log(`Hi! ${name}.`);
   }
 </script>
</body>
</html>
```

HTML요소의 어트리뷰트 중 이벤트에 대응하는 이벤트 핸들러의 어트리뷰트 값에 문을 할당하는 방식.

- 어트리뷰트는 주로 on접두사 + 이벤트 타입으로 이루어짐
- 이때 함수 참조가 아닌 호출문의 문을 할당함
- 사실 이벤트 핸들러의 등록은 호출이 아니라 참조를 등록해야함. 그러나 이 방식은 암묵적으로 생성될 이벤트 핸들러의 몸체를 가리킴. 즉, 해당 함수를 암묵적으로 생성하고, 동일한 이름의 이벤트 핸들러 프로퍼티에 할당함
- 이 방식은 이벤트 헨들러에 인수를 전달하기 위해서임. 만약 참조를 전달해야하면 인수를 전달하기가 곤란함

```js
<!-- 이벤트 핸들러에 인수를 전달하기 곤란하다. -->
<button onclick="sayHi">Click me!</button>
```
